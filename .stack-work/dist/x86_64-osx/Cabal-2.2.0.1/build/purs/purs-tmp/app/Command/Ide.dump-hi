
==================== FINAL INTERFACE ====================
2019-01-24 14:18:11.603303 UTC

interface main:Command.Ide 8043
  interface hash: 24a9313622061ddd4982612b8efa5a88
  ABI hash: d6cca3a97691e618549fca8f5ad987f3
  export-list hash: 4098c6f14be30bbf00b3543391d7bfa0
  orphan hash: f093885e030cefd46b059d17f1d2e12f
  flag hash: 8d22a2f3c18ce9233ef9cbac450ab669
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: True
  where
exports:
  Command.Ide.command
module dependencies:
package dependencies: Glob-0.9.2 aeson-1.3.1.1
                      aeson-better-errors-0.9.1.0 ansi-terminal-0.8.0.4
                      ansi-wl-pprint-0.6.8.2 array-0.5.2.0 async-2.2.1
                      attoparsec-0.13.2.2 auto-update-0.1.4 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0
                      bower-json-1.0.0.1 boxes-0.1.5 bytestring-0.10.8.2 cereal-0.5.5.0
                      clock-0.7.2 colour-2.3.4 conduit-1.3.0.3 conduit-extra-1.3.0
                      containers-0.5.11.0 data-ordlist-0.4.7.0 deepseq-1.4.3.0
                      directory-1.3.1.5 dlist-0.8.0.4 easy-file-0.2.2
                      edit-distance-0.2.2.1 exceptions-0.10.0 fast-logger-2.4.11
                      filepath-1.4.2 fsnotify-0.3.0.1 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 hfsevents-0.1.6 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      lifted-base-0.2.3.12 microlens-0.4.9.1 microlens-ghc-0.4.9
                      microlens-mtl-0.1.11.1 microlens-platform-0.3.10
                      microlens-th-0.4.2.1 monad-control-1.0.2.3 monad-logger-0.3.28.5
                      monad-loops-0.4.3 mtl-2.2.2 network-2.6.3.6 old-locale-1.0.0.7
                      old-time-1.1.0.3 optparse-applicative-0.14.2.0 parallel-3.2.1.1
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 process-1.6.3.0 protolude-0.2.2 purescript-0.12.2
                      random-1.1 regex-base-0.93.2 regex-tdfa-1.2.3.1 resourcet-1.2.1
                      safe-0.3.17 scientific-0.3.6.2 sourcemap-0.1.6 split-0.2.3.3
                      stm-2.4.5.0 stm-chans-3.0.0.4 stringsearch-0.3.6.6 syb-0.7
                      tagged-0.8.5 template-haskell-2.13.0.0 text-1.2.3.0
                      th-abstraction-0.2.8.0 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.5.0 transformers-base-0.4.5.2 unix-2.7.2.2
                      unix-compat-0.5.0.1 unix-time-0.3.8 unliftio-core-0.1.1.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: regex-tdfa-1.2.3.1:Text.Regex.TDFA.ByteString
         regex-tdfa-1.2.3.1:Text.Regex.TDFA.ByteString.Lazy
         regex-tdfa-1.2.3.1:Text.Regex.TDFA.Sequence
         regex-tdfa-1.2.3.1:Text.Regex.TDFA.String
         regex-base-0.93.2:Text.Regex.Base.Context
         unix-time-0.3.8:Data.UnixTime.Diff syb-0.7:Data.Generics.Instances
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         stm-2.4.5.0:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         text-1.2.3.0:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         network-2.6.3.6:Network.Socket colour-2.3.4:Data.Colour
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bower-json-1.0.0.1:Web.Bower.PackageMeta.Internal
                         clock-0.7.2:System.Clock
                         conduit-1.3.0.3:Data.Conduit.Internal.Conduit
                         conduit-1.3.0.3:Data.Conduit.Internal.Pipe
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         monad-logger-0.3.28.5:Control.Monad.Logger
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2:Control.Monad.Logger
                         purescript-0.12.2:Language.PureScript.AST.Declarations
                         purescript-0.12.2:Language.PureScript.AST.Operators
                         purescript-0.12.2:Language.PureScript.AST.SourcePos
                         purescript-0.12.2:Language.PureScript.Comments
                         purescript-0.12.2:Language.PureScript.Docs.RenderedCode.Types
                         purescript-0.12.2:Language.PureScript.Docs.Types
                         purescript-0.12.2:Language.PureScript.Environment
                         purescript-0.12.2:Language.PureScript.Ide.Reexports
                         purescript-0.12.2:Language.PureScript.Ide.Types
                         purescript-0.12.2:Language.PureScript.Kinds
                         purescript-0.12.2:Language.PureScript.Label
                         purescript-0.12.2:Language.PureScript.Make.Monad
                         purescript-0.12.2:Language.PureScript.Names
                         purescript-0.12.2:Language.PureScript.PSString
                         purescript-0.12.2:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2:Language.PureScript.Types
                         resourcet-1.2.1:Control.Monad.Trans.Resource.Internal
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  aeson-1.3.1.1:Data.Aeson 108dfb08de41cf77aad4693ac1dc3d44
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Concurrent ef40f102578b6e7296c2a2358b631ee7
import  -/  base-4.11.1.0:Control.Exception.Base 6b3335161fe9c47efeac02d92d6dc212
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Conc.Sync 0f06fc4d7792ea35160385e7175366ba
import  -/  base-4.11.1.0:GHC.Exception e1b7fe1dbd1d0e3fb049e1163c71a5e8
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.IO.Encoding 16ea661955bbe0a66051e53af57f16a3
import  -/  base-4.11.1.0:GHC.IO.Exception acc060dca2e46d8b8275d06ee7d5d60d
import  -/  base-4.11.1.0:GHC.IO.Handle fb550f271baae6fe7b19205b8166986b
import  -/  base-4.11.1.0:GHC.IO.Handle.FD e69f914efff91201d4bcd54a391a46dd
import  -/  base-4.11.1.0:GHC.IO.Handle.Types d85072f60d88fceac27e39e3cbd01092
import  -/  base-4.11.1.0:GHC.IO.IOMode 925d7d58f693b23bffdd8cdbdf9d203b
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:System.Exit a7af6f90beaa15182d3a20667d878df0
import  -/  base-4.11.1.0:System.IO ce09fff7d191d14067bddc2efd9b53a4
import  -/  base-4.11.1.0:System.IO.Error e9cae3ab377d64b36ad020e6acace3fb
import  -/  base-4.11.1.0:System.Info 4e7bc9cbd0dbb03b6dcb82d8fa133a2b
import  -/  bytestring-0.10.8.2:Data.ByteString 6d0008c12e5c3acd7278a6b95640b4e2
import  -/  bytestring-0.10.8.2:Data.ByteString.Char8 801fee6d15f5471654463d991475364a
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Char8 5c0364969ac6eb9d0c5aa887f86b8c66
import  -/  directory-1.3.1.5:System.Directory bc76216f25ffcaf1c91b529f41ea3bf7
import  -/  directory-1.3.1.5:System.Directory.Internal.Common 88eeec2dd4e3d7d63bc24c2d657e6981
import  -/  filepath-1.4.2:System.FilePath a538d436328dd004b88f7d29a8b244c0
import  -/  filepath-1.4.2:System.FilePath.Posix c021b7a40cfcdd9b08724b5bb7566b59
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  monad-logger-0.3.28.5:Control.Monad.Logger ae6f9fbc4451af5ecbeab48dfdfd01ee
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  network-2.6.3.6:Network 7f7a1db77b5ecf19b3fda67be81f16be
import  -/  network-2.6.3.6:Network.BSD 60f053e64bcacc037c61e349495102f3
import  -/  network-2.6.3.6:Network.Socket 0a27c5d33ecfd552721dd7e47c9f173e
import  -/  network-2.6.3.6:Network.Socket.Internal af2cb1ca411a338f4846b994baabce94
import  -/  network-2.6.3.6:Network.Socket.Types 277f0a43aa213d3d1b0f904626308550
import  -/  optparse-applicative-0.14.2.0:Options.Applicative d95e0b32490502bba50f41d6948c00e0
import  -/  optparse-applicative-0.14.2.0:Options.Applicative.Builder c6546faa9e09bef2ac2df9eff4a77f61
import  -/  optparse-applicative-0.14.2.0:Options.Applicative.Extra b48c7bfd920b8a9e933e034981589447
import  -/  optparse-applicative-0.14.2.0:Options.Applicative.Types 7d35983d2990cf2ee861dc28ddfea4a2
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  protolude-0.2.2:Protolude.Bool cdac0e1e4ccf4064999c851029bcfcb2
import  -/  protolude-0.2.2:Protolude.Show 647c8eca43b2ee3522a904f63ff69e38
import  -/  purescript-0.12.2:Language.PureScript.Ide a6160c6a598660676b7c65cedeaa018f
import  -/  purescript-0.12.2:Language.PureScript.Ide.Command a515164b4f34d128fa16c63e93566e2b
import  -/  purescript-0.12.2:Language.PureScript.Ide.Error b6eb0f8da112a6cbb4342061d1afef05
import  -/  purescript-0.12.2:Language.PureScript.Ide.Logging 7a72afda66c50413f726f7fcff793207
import  -/  purescript-0.12.2:Language.PureScript.Ide.Types 4bb81e9de3788f7f63a68a23e190eb73
import  -/  purescript-0.12.2:Language.PureScript.Ide.Util 23feade20e7d884b8e398315c4ffa11e
import  -/  purescript-0.12.2:Language.PureScript.Ide.Watcher 52e18ed70b9336109f5829f4f239455b
import  -/  stm-2.4.5.0:Control.Concurrent.STM 5ec97830246fb15a85b4d8cd8209f698
import  -/  template-haskell-2.13.0.0:Language.Haskell.TH.Syntax 3e32e309555ba250b4e64084f1389487
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.IO f7dcaf653a3b760ece6adefe76040164
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
3fa568a2a7b48c2a77277d0015870b64
  $fShowServerOptions :: GHC.Show.Show Command.Ide.ServerOptions
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Command.Ide.ServerOptions
                  Command.Ide.$fShowServerOptions_$cshowsPrec
                  Command.Ide.$fShowServerOptions_$cshow
                  Command.Ide.$fShowServerOptions_$cshowList -}
3fa568a2a7b48c2a77277d0015870b64
  $fShowServerOptions1 :: Command.Ide.ServerOptions -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U,1*U(U),U,U,U,U)>,
     Unfolding: (\ (w :: Command.Ide.ServerOptions) ->
                 case w of ww { Command.Ide.ServerOptions ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Command.Ide.$w$cshowsPrec 0# ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 }) -}
ad21999f525273c25550c35f9fa5a26a
  $fShowServerOptions2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
3fa568a2a7b48c2a77277d0015870b64
  $fShowServerOptions_$cshow ::
    Command.Ide.ServerOptions -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U,1*U(U),U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Command.Ide.ServerOptions) ->
                 Command.Ide.$fShowServerOptions_$cshowsPrec
                   Command.Ide.$fShowServerOptions2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3fa568a2a7b48c2a77277d0015870b64
  $fShowServerOptions_$cshowList ::
    [Command.Ide.ServerOptions] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Command.Ide.ServerOptions]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Command.Ide.ServerOptions
                   Command.Ide.$fShowServerOptions1
                   ls
                   s) -}
3fa568a2a7b48c2a77277d0015870b64
  $fShowServerOptions_$cshowsPrec ::
    GHC.Types.Int -> Command.Ide.ServerOptions -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,U,U,1*U(U),U,U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Command.Ide.ServerOptions) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Command.Ide.ServerOptions ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 Command.Ide.$w$cshowsPrec
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 } }) -}
f45ec02803199f9bb97e8ddfa90abe19
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fApplicativeExceptT_$s$fFunctorExceptT @ e)
                  (Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     Command.Ide.$s$fApplicativeExceptT_v
                     (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT
                        @ Language.PureScript.Ide.Types.IdeEnvironment))
                  (Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cliftA2
                     @ e)
                  (Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c<*
                     @ e) -}
81e526dc81451c0f7a260cce536dc4a4
  $s$fApplicativeExceptT_$c<*> ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
      (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ e
                   @ a
                   @ b
                   (w2 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            (a -> b))
                   (w3 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            a) ->
                 Control.Monad.Trans.Except.$w$c<*>
                   @ (Control.Monad.Trans.Reader.ReaderT
                        Language.PureScript.Ide.Types.IdeEnvironment
                        (Control.Monad.Logger.LoggingT GHC.Types.IO))
                   @ e
                   (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT
                      @ Language.PureScript.Ide.Types.IdeEnvironment)
                   @ a
                   @ b
                   w2
                   w3) -}
d03831e4c61655090954c8ebcb987f74
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
      a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e
                           (Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Ide.Types.IdeEnvironment
                              (Control.Monad.Logger.LoggingT GHC.Types.IO))
                           b)
                   (r1 :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                 let {
                   ds :: Control.Monad.Logger.LoggingT
                           GHC.Types.IO (Data.Either.Either e a)
                   = m1
                       `cast`
                     (Control.Monad.Trans.Except.N:ExceptT[0]
                          <e>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Ide.Types.IdeEnvironment
                             (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                          <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                      <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                      <Data.Either.Either e a>_N)
                       r1
                 } in
                 (\ (r :: Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ())
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e a>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                    Data.Either.Right x
                    -> ((k `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <e>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Ide.Types.IdeEnvironment
                                 (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                              <b>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                          <*>_N
                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                          <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                          <Data.Either.Either e b>_N)
                           r1)
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e b>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)
                         ipv } })
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    e b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R
                                                        <Data.Either.Either e b>_N)))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e
                    (Control.Monad.Trans.Reader.ReaderT
                       Language.PureScript.Ide.Types.IdeEnvironment
                       (Control.Monad.Logger.LoggingT GHC.Types.IO))
                    a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e
                         (Control.Monad.Trans.Reader.ReaderT
                            Language.PureScript.Ide.Types.IdeEnvironment
                            (Control.Monad.Logger.LoggingT GHC.Types.IO))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <Language.PureScript.Ide.Types.IdeEnvironment>_R
                               <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                               <Data.Either.Either
                                  e b>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO)>_R
                                                     <b>_N)) -}
d559527598c28103a3869c023b0f5fb9
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c<* ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
      a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         a
  {- Arity: 2, Strictness: <L,C(C(C1(U(U,1*U))))><L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.Except.ExceptT
                           e
                           (Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Ide.Types.IdeEnvironment
                              (Control.Monad.Logger.LoggingT GHC.Types.IO))
                           a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Trans.Reader.ReaderT
                        Language.PureScript.Ide.Types.IdeEnvironment
                        (Control.Monad.Logger.LoggingT GHC.Types.IO))
                   @ e
                   Command.Ide.$s$fApplicativeExceptT_v
                   (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT
                      @ Language.PureScript.Ide.Types.IdeEnvironment)
                   @ b
                   @ a
                   (\ (x1 :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                    let {
                      logger :: Control.Monad.Logger.LoggingT
                                  GHC.Types.IO (Data.Either.Either e a)
                      = x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Control.Monad.Trans.Reader.ReaderT
                                Language.PureScript.Ide.Types.IdeEnvironment
                                (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                             <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N
                                         <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                         <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                         <Data.Either.Either e a>_N)
                          x1
                    } in
                    (\ (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                    -> Control.Monad.Logger.LogSource
                                    -> Control.Monad.Logger.LogLevel
                                    -> System.Log.FastLogger.LogStr.LogStr
                                    -> GHC.Types.IO ())
                       (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case (logger
                             `cast`
                           (Control.Monad.Logger.N:LoggingT[0]
                                <GHC.Types.IO>_R <Data.Either.Either e a>_N)
                             loggerFn)
                            `cast`
                          (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                            s of ds { (#,#) ipv ipv1 ->
                     (# ipv,
                        Control.Monad.Trans.Except.$fApplicativeExceptT1
                          @ a
                          @ b
                          @ e
                          ipv1 #) })
                      `cast`
                    ((<Language.Haskell.TH.Syntax.Loc
                       -> Control.Monad.Logger.LogSource
                       -> Control.Monad.Logger.LogLevel
                       -> System.Log.FastLogger.LogStr.LogStr
                       -> GHC.Types.IO ()>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <Data.Either.Either
                                       e (b -> a)>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                  <GHC.Types.IO>_R
                                                                  <Data.Either.Either
                                                                     e (b -> a)>_N)))
                     `cast`
                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Language.PureScript.Ide.Types.IdeEnvironment>_R
                             <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                             <Data.Either.Either
                                e (b -> a)>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <e>_N
                                                          <Control.Monad.Trans.Reader.ReaderT
                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                             (Control.Monad.Logger.LoggingT
                                                                GHC.Types.IO)>_R
                                                          <b -> a>_N))) -}
c0df5d65366cf87f161bb08037128b66
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cliftA2 ::
    (a -> b -> c)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         c
  {- Arity: 3, Strictness: <L,C(U)><L,C(C(C1(U(U,1*U))))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ e
                   @ a
                   @ b
                   @ c
                   (f1 :: a -> b -> c)
                   (x :: Control.Monad.Trans.Except.ExceptT
                           e
                           (Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Ide.Types.IdeEnvironment
                              (Control.Monad.Logger.LoggingT GHC.Types.IO))
                           a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Trans.Reader.ReaderT
                        Language.PureScript.Ide.Types.IdeEnvironment
                        (Control.Monad.Logger.LoggingT GHC.Types.IO))
                   @ e
                   Command.Ide.$s$fApplicativeExceptT_v
                   (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT
                      @ Language.PureScript.Ide.Types.IdeEnvironment)
                   @ b
                   @ c
                   (\ (x1 :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                    let {
                      logger :: Control.Monad.Logger.LoggingT
                                  GHC.Types.IO (Data.Either.Either e a)
                      = x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Control.Monad.Trans.Reader.ReaderT
                                Language.PureScript.Ide.Types.IdeEnvironment
                                (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                             <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N
                                         <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                         <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                         <Data.Either.Either e a>_N)
                          x1
                    } in
                    (\ (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                    -> Control.Monad.Logger.LogSource
                                    -> Control.Monad.Logger.LogLevel
                                    -> System.Log.FastLogger.LogStr.LogStr
                                    -> GHC.Types.IO ())
                       (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case (logger
                             `cast`
                           (Control.Monad.Logger.N:LoggingT[0]
                                <GHC.Types.IO>_R <Data.Either.Either e a>_N)
                             loggerFn)
                            `cast`
                          (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                            s of ds { (#,#) ipv ipv1 ->
                     (# ipv,
                        Data.Either.$fApplicativeEither_$cfmap
                          @ e
                          @ a
                          @ (b -> c)
                          f1
                          ipv1 #) })
                      `cast`
                    ((<Language.Haskell.TH.Syntax.Loc
                       -> Control.Monad.Logger.LogSource
                       -> Control.Monad.Logger.LogLevel
                       -> System.Log.FastLogger.LogStr.LogStr
                       -> GHC.Types.IO ()>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <Data.Either.Either
                                       e (b -> c)>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                  <GHC.Types.IO>_R
                                                                  <Data.Either.Either
                                                                     e (b -> c)>_N)))
                     `cast`
                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Language.PureScript.Ide.Types.IdeEnvironment>_R
                             <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                             <Data.Either.Either
                                e (b -> c)>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <e>_N
                                                          <Control.Monad.Trans.Reader.ReaderT
                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                             (Control.Monad.Logger.LoggingT
                                                                GHC.Types.IO)>_R
                                                          <b -> c>_N))) -}
dfd0ceeae0ab0dda3b214fc21262e862
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) ->
                 let {
                   x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                     {- Arity: 1 -}
                   = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     (# s, Data.Either.Right @ e @ a a1 #)
                 } in
                 let {
                   m1 :: (Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ())
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                     {- Arity: 2 -}
                   = \ (ds :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ()) ->
                     x1
                 } in
                 (\ (ds :: Language.PureScript.Ide.Types.IdeEnvironment) -> m1)
                   `cast`
                 ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.Either.Either
                                          e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                              <GHC.Types.IO>_R
                                                              <Data.Either.Either
                                                                 e
                                                                 a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                   <*>_N
                                                                                   <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                   <Control.Monad.Logger.LoggingT
                                                                                      GHC.Types.IO>_R
                                                                                   <Data.Either.Either
                                                                                      e a>_N)))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  Language.PureScript.Ide.Types.IdeEnvironment
                                  (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                               <a>_N)) -}
a5eaf89b7e2e7a07f6620aef2e99ad38
  $s$fApplicativeExceptT_$s$fApplicativeLoggingT ::
    GHC.Base.Applicative (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Command.Ide.$s$fApplicativeExceptT_$s$fFunctorLoggingT
                  (\ @ a (x :: a) ->
                   let {
                     x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, x #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x1)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT_$c<*>
                  (\ @ a
                     @ b
                     @ c
                     (eta1 :: a -> b -> c)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta3 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta4 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta4)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta3
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta4)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, eta1 ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <c>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <c>_N))
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (eta2
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      eta3)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
1e837b8a969d2d19f548dbfcbaf397de
  $s$fApplicativeExceptT_$s$fApplicativeLoggingT_$c<*> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (loggerF :: Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b))
                   (loggerA :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (loggerF
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a -> b>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 case (loggerA
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
da51f486263c2dc2aa851fda81414a35
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     Command.Ide.$s$fApplicativeExceptT_v)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     Command.Ide.$s$fApplicativeExceptT_v) -}
3ae3aafb709cd5e3b08727b36e3d5eb7
  $s$fApplicativeExceptT_$s$fFunctorLoggingT ::
    GHC.Base.Functor (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Command.Ide.$s$fApplicativeExceptT_$s$fFunctorLoggingT_$cfmap
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta2 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta2)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (# ipv, x #) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
efbb42fcb9ab5a7c13ff9f31a2f3c95d
  $s$fApplicativeExceptT_$s$fFunctorLoggingT_$cfmap ::
    (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (logger :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (logger
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 (# ipv, f ipv1 #) })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
5fdd42e4fa754f5e3dc76474349d4726
  $s$fApplicativeExceptT_$s$fMonadLoggingT ::
    GHC.Base.Monad (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT
                  (\ @ a
                     @ b
                     (ds :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (f :: a -> Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   ((f ipv1)
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      r)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <a -> Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  Command.Ide.$s$fApplicativeExceptT_$s$fMonadLoggingT_$c>>
                  (\ @ a (eta1 :: a) ->
                   let {
                     x :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta1 #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO a)) -}
fe32e8dc53988d326e4d1efa360193d7
  $s$fApplicativeExceptT_$s$fMonadLoggingT_$c>> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (k :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                   (r :: Language.Haskell.TH.Syntax.Loc
                         -> Control.Monad.Logger.LogSource
                         -> Control.Monad.Logger.LogLevel
                         -> System.Log.FastLogger.LogStr.LogStr
                         -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (k `cast`
                  (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                    r)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
1e6e8f3a5ca48d4ca2e3460d2a704a33
  $s$fApplicativeExceptT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r (Control.Monad.Logger.LoggingT GHC.Types.IO))
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT)
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Command.Ide.$s$fApplicativeExceptT_$s$fMonadLoggingT)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT
                     @ a
                     @ b)
                  (\ @ a (eta1 :: a) ->
                   let {
                     x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta1 #)
                   } in
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 2 -}
                     = \ (ds :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()) ->
                       x1
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R (<Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ()>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                            <GHC.Types.IO>_R
                                                            <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                               <*>_N
                                                                               <r>_R
                                                                               <Control.Monad.Logger.LoggingT
                                                                                  GHC.Types.IO>_R
                                                                               <a>_N)))
                  (Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Command.Ide.$s$fApplicativeExceptT_$s$fMonadLoggingT) -}
e69841adeed934b1d2a9c1e2bae34398
  $s$fApplicativeExceptT_v ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Unfolding: (Control.Monad.Trans.Reader.$fFunctorReaderT
                   @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                   @ Language.PureScript.Ide.Types.IdeEnvironment
                   Command.Ide.$s$fApplicativeExceptT_$s$fFunctorLoggingT) -}
4ab78819c73ebeb396e59b06f74bc938
  $s$fMonadErroreExceptT ::
    Control.Monad.Error.Class.MonadError
      e
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ e
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT @ e)
                  (\ @ a (x :: e) ->
                   let {
                     x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       (# s, Data.Either.Left @ e @ a x #)
                   } in
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                       {- Arity: 2 -}
                     = \ (ds :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()) ->
                       x1
                   } in
                   (\ (ds :: Language.PureScript.Ide.Types.IdeEnvironment) -> m1)
                     `cast`
                   ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                     ->_R (<Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ()>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.Either.Either
                                            e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                <GHC.Types.IO>_R
                                                                <Data.Either.Either
                                                                   e
                                                                   a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                     <*>_N
                                                                                     <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                     <Control.Monad.Logger.LoggingT
                                                                                        GHC.Types.IO>_R
                                                                                     <Data.Either.Either
                                                                                        e a>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <e>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    Language.PureScript.Ide.Types.IdeEnvironment
                                    (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                                 <a>_N))
                  (\ @ a ->
                   Control.Monad.Trans.Except.catchE
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     @ a
                     @ e
                     (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT
                        @ Language.PureScript.Ide.Types.IdeEnvironment)) -}
59a27da0f8d8ecb591f1748eb7b9aac3
  $s$fMonadErroreExceptT_$s$fMonadExceptT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fApplicativeExceptT @ e)
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$c>>= @ e)
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$c>> @ e)
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT1 @ e)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N
                                 <Control.Monad.Trans.Reader.ReaderT
                                    Language.PureScript.Ide.Types.IdeEnvironment
                                    (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                                 <a>_N))
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$cfail @ e) -}
aee220d6f6d37e6cddc357ccc073b7a5
  $s$fMonadErroreExceptT_$s$fMonadExceptT1 ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO)
         (Data.Either.Either e a)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e @ a (eta1 :: a) ->
                 let {
                   x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                     {- Arity: 1 -}
                   = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     (# s, Data.Either.Right @ e @ a eta1 #)
                 } in
                 let {
                   m1 :: (Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ())
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e a #)
                     {- Arity: 2 -}
                   = \ (ds :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ()) ->
                     x1
                 } in
                 (\ (ds :: Language.PureScript.Ide.Types.IdeEnvironment) -> m1)
                   `cast`
                 ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.Either.Either
                                          e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                              <GHC.Types.IO>_R
                                                              <Data.Either.Either
                                                                 e
                                                                 a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                   <*>_N
                                                                                   <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                   <Control.Monad.Logger.LoggingT
                                                                                      GHC.Types.IO>_R
                                                                                   <Data.Either.Either
                                                                                      e a>_N))) -}
c86b022f622301a6af3fa61405b7b3c8
  $s$fMonadErroreExceptT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
      a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e
                           (Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Ide.Types.IdeEnvironment
                              (Control.Monad.Logger.LoggingT GHC.Types.IO))
                           b)
                   (r1 :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                 let {
                   ds :: Control.Monad.Logger.LoggingT
                           GHC.Types.IO (Data.Either.Either e a)
                   = m1
                       `cast`
                     (Control.Monad.Trans.Except.N:ExceptT[0]
                          <e>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Ide.Types.IdeEnvironment
                             (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                          <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                      <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                      <Data.Either.Either e a>_N)
                       r1
                 } in
                 (\ (r :: Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ())
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e a>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                    Data.Either.Right x
                    -> ((k `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <e>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Ide.Types.IdeEnvironment
                                 (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                              <b>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                          <*>_N
                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                          <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                          <Data.Either.Either e b>_N)
                           r1)
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e b>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)
                         ipv } })
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    e b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R
                                                        <Data.Either.Either e b>_N)))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e
                    (Control.Monad.Trans.Reader.ReaderT
                       Language.PureScript.Ide.Types.IdeEnvironment
                       (Control.Monad.Logger.LoggingT GHC.Types.IO))
                    a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e
                         (Control.Monad.Trans.Reader.ReaderT
                            Language.PureScript.Ide.Types.IdeEnvironment
                            (Control.Monad.Logger.LoggingT GHC.Types.IO))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <Language.PureScript.Ide.Types.IdeEnvironment>_R
                               <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                               <Data.Either.Either
                                  e b>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO)>_R
                                                     <b>_N)) -}
3428ef7256bf6d3784ed07ec3fa41386
  $s$fMonadErroreExceptT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Ide.Types.IdeEnvironment
         (Control.Monad.Logger.LoggingT GHC.Types.IO))
      a
    -> (a
        -> Control.Monad.Trans.Except.ExceptT
             e
             (Control.Monad.Trans.Reader.ReaderT
                Language.PureScript.Ide.Types.IdeEnvironment
                (Control.Monad.Logger.LoggingT GHC.Types.IO))
             b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(C1(U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Except.ExceptT
                              e
                              (Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Ide.Types.IdeEnvironment
                                 (Control.Monad.Logger.LoggingT GHC.Types.IO))
                              b)
                   (r1 :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                 let {
                   ds :: Control.Monad.Logger.LoggingT
                           GHC.Types.IO (Data.Either.Either e a)
                   = m1
                       `cast`
                     (Control.Monad.Trans.Except.N:ExceptT[0]
                          <e>_N
                          <Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Ide.Types.IdeEnvironment
                             (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                          <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                      <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                      <Data.Either.Either e a>_N)
                       r1
                 } in
                 (\ (r :: Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ())
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e a>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                    Data.Either.Right x
                    -> (((k x)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <e>_N
                              <Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Ide.Types.IdeEnvironment
                                 (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                              <b>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                          <*>_N
                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                          <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                          <Data.Either.Either e b>_N)
                           r1)
                          `cast`
                        (Control.Monad.Logger.N:LoggingT[0]
                             <GHC.Types.IO>_R <Data.Either.Either e b>_N)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)
                         ipv } })
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    e b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R
                                                        <Data.Either.Either e b>_N)))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e
                    (Control.Monad.Trans.Reader.ReaderT
                       Language.PureScript.Ide.Types.IdeEnvironment
                       (Control.Monad.Logger.LoggingT GHC.Types.IO))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Trans.Reader.ReaderT
                               Language.PureScript.Ide.Types.IdeEnvironment
                               (Control.Monad.Logger.LoggingT GHC.Types.IO))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <Language.PureScript.Ide.Types.IdeEnvironment>_R
                               <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                               <Data.Either.Either
                                  e b>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO)>_R
                                                     <b>_N)) -}
77d02c2d76248adbf7c4d4cb7fbc6959
  $s$fMonadErroreExceptT_$s$fMonadExceptT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO))
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ e @ a (x :: GHC.Base.String) ->
                 let {
                   m1 :: Control.Monad.Logger.LoggingT
                           GHC.Types.IO (Data.Either.Either e a)
                     {- Strictness: x -}
                   = GHC.Err.errorWithoutStackTrace
                       @ 'GHC.Types.LiftedRep
                       @ (Control.Monad.Logger.LoggingT
                            GHC.Types.IO (Data.Either.Either e a))
                       x
                 } in
                 (\ (ds :: Language.PureScript.Ide.Types.IdeEnvironment) -> m1)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <Language.PureScript.Ide.Types.IdeEnvironment>_R
                           <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                           <Data.Either.Either e a>_N)))
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  Language.PureScript.Ide.Types.IdeEnvironment
                                  (Control.Monad.Logger.LoggingT GHC.Types.IO)>_R
                               <a>_N)) -}
2d186fe50f186f0c57c004eb4b12b67b
  $s$fMonadIOExceptT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT @ e)
                  (\ @ a
                     (x :: GHC.Types.IO a)
                     (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case x `cast` (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   (# ipv, Data.Either.Right @ e @ a ipv1 #) })
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Ide.Types.IdeEnvironment>_R
                         ->_R (<Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                    <GHC.Types.IO>_R
                                                                    <Data.Either.Either
                                                                       e
                                                                       a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                          <*>_N
                                                                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                          <Control.Monad.Logger.LoggingT
                                                                                             GHC.Types.IO>_R
                                                                                          <Data.Either.Either
                                                                                             e
                                                                                             a>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                              <e>_N
                                                                                                              <Control.Monad.Trans.Reader.ReaderT
                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                    GHC.Types.IO)>_R
                                                                                                              <a>_N))) -}
f96937c0c07826e0eae4e7483f9e08c1
  $s$fMonadIOReaderT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Reader.ReaderT
         r (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r (Control.Monad.Logger.LoggingT GHC.Types.IO))
                  (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT @ r)
                  (\ @ a (x :: GHC.Types.IO a) ->
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Types.IO a
                       {- Arity: 1 -}
                     = \ (ds :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()) ->
                       x
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (Control.Monad.Logger.N:LoggingT[0]
                                   <GHC.Types.IO>_R
                                   <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                      <*>_N
                                                      <r>_R
                                                      <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                                      <a>_N))) -}
bab6bd019675d1513fa1bd6b27e02ed1
  $s$fMonadLoggerExceptT ::
    Control.Monad.Logger.MonadLogger
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT @ e)
                  (Control.Monad.Logger.$fMonadLoggerExceptT_$cmonadLoggerLog
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     (Command.Ide.$s$fMonadLoggerExceptT_$s$fMonadLoggerReaderT
                        @ Language.PureScript.Ide.Types.IdeEnvironment)) -}
069656b48a4239e40bb469babc3577f2
  $s$fMonadLoggerExceptT_$s$fMonadLoggerReaderT ::
    Control.Monad.Logger.MonadLogger
      (Control.Monad.Trans.Reader.ReaderT
         r (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r (Control.Monad.Logger.LoggingT GHC.Types.IO))
                  (Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT @ r)
                  (\ @ msg
                     (eta1 :: System.Log.FastLogger.LogStr.ToLogStr msg)
                     (eta2 :: Language.Haskell.TH.Syntax.Loc)
                     (eta3 :: Control.Monad.Logger.LogSource)
                     (eta4 :: Control.Monad.Logger.LogLevel)
                     (eta5 :: msg) ->
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Types.IO ()
                       {- Arity: 1 -}
                     = \ (f :: Language.Haskell.TH.Syntax.Loc
                               -> Control.Monad.Logger.LogSource
                               -> Control.Monad.Logger.LogLevel
                               -> System.Log.FastLogger.LogStr.LogStr
                               -> GHC.Types.IO ()) ->
                       f eta2
                         eta3
                         eta4
                         (eta1 `cast` (System.Log.FastLogger.LogStr.N:ToLogStr[0] <msg>_N)
                            eta5)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (Control.Monad.Logger.N:LoggingT[0]
                                   <GHC.Types.IO>_R
                                   <()>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                       <*>_N
                                                       <r>_R
                                                       <Control.Monad.Logger.LoggingT
                                                          GHC.Types.IO>_R
                                                       <()>_N))) -}
b33b4718c1e23b316a78b2282192b573
  $s$fMonadLoggingT_$creturn ::
    a -> Control.Monad.Logger.LoggingT GHC.Types.IO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta1 :: a) ->
                 let {
                   x :: GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                     {- Arity: 1 -}
                   = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta1 #)
                 } in
                 (\ (ds :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ()) ->
                  x)
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                    <GHC.Types.IO>_R <a>_N))) -}
dcd4a8b8d9feecfeeba6b6db6975f1c5
  $s$fMonadReaderrExceptT ::
    Control.Monad.Reader.Class.MonadReader
      Language.PureScript.Ide.Types.IdeEnvironment
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ Language.PureScript.Ide.Types.IdeEnvironment
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT @ e)
                  (\ (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s,
                      Data.Either.Right
                        @ e
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        r1 #))
                    `cast`
                  ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                    ->_R (<Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ()>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Either.Either
                                           e
                                           Language.PureScript.Ide.Types.IdeEnvironment>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                                                        <GHC.Types.IO>_R
                                                                                                        <Data.Either.Either
                                                                                                           e
                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                         <*>_N
                                                                                                                                                                         <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                                                                                                         <Control.Monad.Logger.LoggingT
                                                                                                                                                                            GHC.Types.IO>_R
                                                                                                                                                                         <Data.Either.Either
                                                                                                                                                                            e
                                                                                                                                                                            Language.PureScript.Ide.Types.IdeEnvironment>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                                                                                                        <e>_N
                                                                                                                                                                                                                                        <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                                                                           (Control.Monad.Logger.LoggingT
                                                                                                                                                                                                                                              GHC.Types.IO)>_R
                                                                                                                                                                                                                                        <Language.PureScript.Ide.Types.IdeEnvironment>_N)))
                  (\ @ a
                     (eta1 :: Language.PureScript.Ide.Types.IdeEnvironment
                              -> Language.PureScript.Ide.Types.IdeEnvironment) ->
                   Control.Monad.Trans.Except.mapExceptT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     @ a
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     @ a
                     (Control.Monad.Trans.Reader.withReaderT
                        @ *
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                        @ (Data.Either.Either e a)
                        eta1))
                  (\ @ a
                     (eta1 :: Language.PureScript.Ide.Types.IdeEnvironment -> a)
                     (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s, Data.Either.Right @ e @ a (eta1 r1) #))
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Ide.Types.IdeEnvironment -> a>_R
                   ->_R (<Language.PureScript.Ide.Types.IdeEnvironment>_R
                         ->_R (<Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                    <GHC.Types.IO>_R
                                                                    <Data.Either.Either
                                                                       e
                                                                       a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                          <*>_N
                                                                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                          <Control.Monad.Logger.LoggingT
                                                                                             GHC.Types.IO>_R
                                                                                          <Data.Either.Either
                                                                                             e
                                                                                             a>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                              <e>_N
                                                                                                              <Control.Monad.Trans.Reader.ReaderT
                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                    GHC.Types.IO)>_R
                                                                                                              <a>_N))) -}
62e1376ed5942a8f6c1570395d03c2e7
  $tc'ClientOptions :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10289933440849376370##
                   8181834950374065886##
                   Command.Ide.$trModule
                   Command.Ide.$tc'ClientOptions2
                   0#
                   Command.Ide.$tc'ClientOptions1) -}
bfe17edd551f0aa6e62d703f9b3a5fcb
  $tc'ClientOptions1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f05b1081eec4f94e9e70b47dda05832e
  $tc'ClientOptions2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$tc'ClientOptions3) -}
cb4b2870480b72598af486088468aa9a
  $tc'ClientOptions3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ClientOptions"#) -}
f5f80ade6c83c8dcbccd8fceb259ce96
  $tc'ServerOptions :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3486415276202960210##
                   16661927092749592328##
                   Command.Ide.$trModule
                   Command.Ide.$tc'ServerOptions2
                   0#
                   Command.Ide.$tc'ServerOptions1) -}
36950acd15a405a5b69dfcd4423bdb23
  $tc'ServerOptions1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0f456aa8fe31a84c3c2fa04dba6998cf
  $tc'ServerOptions2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$tc'ServerOptions3) -}
af3c511d1c4274483b47e1a1e6c7c3ff
  $tc'ServerOptions3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ServerOptions"#) -}
b28219817bb32f48c5170b011788d98f
  $tcClientOptions :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   538492949918142040##
                   14055806651258131986##
                   Command.Ide.$trModule
                   Command.Ide.$tcClientOptions1
                   0#
                   GHC.Types.krep$*) -}
52453ad539c5fd261582ac4c855e815f
  $tcClientOptions1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$tcClientOptions2) -}
d1585a133aea4de96ccf46a4273a04cd
  $tcClientOptions2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ClientOptions"#) -}
e91ddd3a2d5184eb498e48a9511983db
  $tcServerOptions :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15912427201778869945##
                   6190535010196741969##
                   Command.Ide.$trModule
                   Command.Ide.$tcServerOptions1
                   0#
                   GHC.Types.krep$*) -}
d14497e8ca125b9c82962ece72f4892c
  $tcServerOptions1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$tcServerOptions2) -}
1583fe3c46d892eb932650ce64d1ff8e
  $tcServerOptions2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ServerOptions"#) -}
24bcf1c14cb159e44e2a8cb4b302a8a0
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Command.Ide.$trModule3
                   Command.Ide.$trModule1) -}
8173d0abc3a96c82133a928ba45762a9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$trModule2) -}
18b02419ec8e906beed3bbe05ae80684
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Command.Ide"#) -}
f1e915480c4cb93412d662565240d13d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Command.Ide.$trModule4) -}
d280cf9d2ecaac6170e010e445bf78f2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
4790ef27334b5b8f1a189bcb2952283e
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.Maybe GHC.IO.FilePath
    -> [GHC.IO.FilePath]
    -> GHC.IO.FilePath
    -> Network.Socket.Types.PortNumber
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> Language.PureScript.Ide.Types.IdeLogLevel
    -> GHC.Types.Bool
    -> GHC.Show.ShowS
  {- Arity: 9,
     Strictness: <S,U><L,1*U><L,U><L,U><L,1*U(U)><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
dfc27b2bafdcaae2147f996a5314968f
  $wouter ::
    GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Text.Internal.Text #)
  {- Arity: 5, Strictness: <L,U><S,U><S,1*U><S,U><S,U>,
     Inline: [0] -}
bed4043c6f728f2d90fc6cf029bfa6bf
  data ClientOptions = ClientOptions {clientPort :: Network.PortID}
3fa568a2a7b48c2a77277d0015870b64
  data ServerOptions
    = ServerOptions {_serverDirectory :: GHC.Base.Maybe
                                           GHC.IO.FilePath,
                     _serverGlobs :: [GHC.IO.FilePath],
                     _serverOutputPath :: GHC.IO.FilePath,
                     _serverPort :: Network.Socket.Types.PortNumber,
                     _serverNoWatch :: GHC.Types.Bool,
                     _serverPolling :: GHC.Types.Bool,
                     _serverLoglevel :: Language.PureScript.Ide.Types.IdeLogLevel,
                     _serverEditorMode :: GHC.Types.Bool}
3fa568a2a7b48c2a77277d0015870b64
  _serverDirectory ::
    Command.Ide.ServerOptions -> GHC.Base.Maybe GHC.IO.FilePath
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLL),1*U(1*U,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds1 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverEditorMode :: Command.Ide.ServerOptions -> GHC.Types.Bool
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),1*U(A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds8 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverGlobs :: Command.Ide.ServerOptions -> [GHC.IO.FilePath]
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),1*U(A,1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds2 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverLoglevel ::
    Command.Ide.ServerOptions
    -> Language.PureScript.Ide.Types.IdeLogLevel
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds7 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverNoWatch :: Command.Ide.ServerOptions -> GHC.Types.Bool
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),1*U(A,A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds5 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverOutputPath :: Command.Ide.ServerOptions -> GHC.IO.FilePath
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),1*U(A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds3 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverPolling :: Command.Ide.ServerOptions -> GHC.Types.Bool
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),1*U(A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds6 }) -}
3fa568a2a7b48c2a77277d0015870b64
  _serverPort ::
    Command.Ide.ServerOptions -> Network.Socket.Types.PortNumber
  RecSel Left Command.Ide.ServerOptions
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),1*U(A,A,A,1*U(U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ServerOptions) ->
                 case ds of wild { Command.Ide.ServerOptions ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds4 }) -}
bed4043c6f728f2d90fc6cf029bfa6bf
  clientPort :: Command.Ide.ClientOptions -> Network.PortID
  RecSel Left Command.Ide.ClientOptions
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Command.Ide.ClientOptions) ->
                 case ds of wild { Command.Ide.ClientOptions ds1 -> ds1 }) -}
525f81c91254f822b3ca254d2de6cd3e
  command :: Options.Applicative.Types.Parser (GHC.Types.IO ())
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.IO ())
                   @ (GHC.Types.IO ())
                   (Options.Applicative.Extra.helper @ (GHC.Types.IO ()))
                   Command.Ide.command1) -}
e07f08023c1ceac9af182fe2285f192b
  command1 :: Options.Applicative.Types.Parser (GHC.Types.IO ())
  {- Unfolding: (case Command.Ide.command_$s$wgo
                        Command.Ide.command26
                        (Options.Applicative.Builder.Internal.$fMonoidDefaultProp_$cmempty
                           @ (GHC.Types.IO ()))
                        (GHC.Base.id @ Options.Applicative.Types.OptProperties)
                        Command.Ide.command2 of ww { (#,,#) ww1 ww2 ww3 ->
                 case ww2 of ww4 { Options.Applicative.Builder.Internal.DefaultProp ww5 ww6 ->
                 case Options.Applicative.Builder.$wsubparser
                        @ (GHC.Types.IO ())
                        ww1
                        ww5
                        ww6
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 Options.Applicative.Types.AltP
                   @ (GHC.Types.IO ())
                   ww8
                   ww9 } } }) -}
e0d70f2b6d97d0aebca0f2577d834885
  command10 ::
    Options.Applicative.Types.Parser GHC.Integer.Type.Integer
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Options.Applicative.Types.NilP
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command11) -}
8a7fb97f3e363c1c02f192c94c032f71
  command100 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Command.Ide.command101) -}
4457a5f27bc6f53ad3925a4d6f27c23e
  command101 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("output-directory"#) -}
966d437eaa04c42f8b84028beec8ee73
  command102 ::
    Options.Applicative.Types.Parser
      (GHC.IO.FilePath
       -> Network.Socket.Types.PortNumber
       -> GHC.Types.Bool
       -> GHC.Types.Bool
       -> Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool
       -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.IO.FilePath
                      -> Network.Socket.Types.PortNumber
                      -> GHC.Types.Bool
                      -> GHC.Types.Bool
                      -> Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool
                      -> Command.Ide.ServerOptions)
                   @ [GHC.IO.FilePath]
                   Command.Ide.command110
                   Command.Ide.command103) -}
f58192c964e48a6d3f6b787c1f54e7e7
  command103 :: Options.Applicative.Types.Parser [GHC.IO.FilePath]
  {- Unfolding: ((Options.Applicative.Types.manyM
                    @ GHC.IO.FilePath
                    Command.Ide.command104)
                   `cast`
                 (Options.Applicative.Types.N:ParserM[0] <[GHC.IO.FilePath]>_R)
                   @ [GHC.IO.FilePath]
                   (Options.Applicative.Types.$fAlternativeParser_$cpure
                      @ [GHC.IO.FilePath])) -}
55efe9de54391c74b1a2b8dc6a45a7ce
  command104 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.IO.FilePath
                   Command.Ide.command105
                   (Options.Applicative.Types.$fAlternativeParser_$cempty
                      @ GHC.IO.FilePath)) -}
06d0446af629e00dd83c76d396756e08
  command105 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.IO.FilePath
                   Command.Ide.command106) -}
b259af46c1421ae1134db60a1334e18f
  command106 :: Options.Applicative.Types.Option GHC.IO.FilePath
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.IO.FilePath
                   Command.Ide.command109
                   Command.Ide.command107) -}
3aef839dc262b4c720c3f85412233f8b
  command107 :: Options.Applicative.Types.OptProperties
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.OptProperties
                   Options.Applicative.Types.Visible
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   Command.Ide.command_var
                   (GHC.Base.Nothing @ GHC.Base.String)
                   (GHC.Base.Nothing
                      @ (Text.PrettyPrint.ANSI.Leijen.Internal.Doc
                         -> Text.PrettyPrint.ANSI.Leijen.Internal.Doc))) -}
286c2b6198f953c78368851996210137
  command108 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Source GLOBS..."#) -}
b7502237e3d0ee0b2d20f76cf7568bea
  command109 :: Options.Applicative.Types.OptReader GHC.IO.FilePath
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Options.Applicative.Types.ArgReader
                   @ GHC.IO.FilePath
                   Command.Ide.command98) -}
6e68e48bfe2fb66e51975d081b84c355
  command11 :: GHC.Base.Maybe GHC.Integer.Type.Integer
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command12) -}
97d01c80d33cf1571a68060e2b5200a9
  command110 ::
    Options.Applicative.Types.Parser
      ([GHC.IO.FilePath]
       -> GHC.IO.FilePath
       -> Network.Socket.Types.PortNumber
       -> GHC.Types.Bool
       -> GHC.Types.Bool
       -> Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool
       -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ (GHC.Base.Maybe GHC.IO.FilePath)
                   @ ([GHC.IO.FilePath]
                      -> GHC.IO.FilePath
                      -> Network.Socket.Types.PortNumber
                      -> GHC.Types.Bool
                      -> GHC.Types.Bool
                      -> Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool
                      -> Command.Ide.ServerOptions)
                   Command.Ide.ServerOptions
                   Command.Ide.command111) -}
79d4da03fe02ac2c3608926f1d533ae4
  command111 ::
    Options.Applicative.Types.Parser (GHC.Base.Maybe GHC.IO.FilePath)
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ (GHC.Base.Maybe GHC.IO.FilePath)
                   Command.Ide.command114
                   Command.Ide.command112) -}
ed1e860127a1febe4d627b5300b35440
  command112 ::
    Options.Applicative.Types.Parser (GHC.Base.Maybe GHC.IO.FilePath)
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Options.Applicative.Types.NilP
                   @ (GHC.Base.Maybe GHC.IO.FilePath)
                   Command.Ide.command113) -}
5f3cc2c6e6978ec577944444a2f331ae
  command113 :: GHC.Base.Maybe (GHC.Base.Maybe GHC.IO.FilePath)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ (GHC.Base.Maybe GHC.IO.FilePath)
                   (GHC.Base.Nothing @ GHC.IO.FilePath)) -}
bd246eeb9b95b3b305baf0ebaf28b949
  command114 ::
    Options.Applicative.Types.Parser (GHC.Base.Maybe GHC.IO.FilePath)
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ GHC.IO.FilePath
                   @ (GHC.Base.Maybe GHC.IO.FilePath)
                   (GHC.Base.Just @ GHC.IO.FilePath)
                   Command.Ide.command115) -}
522f32d3ed2b1c04cd4a70dbd04591c1
  command115 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.IO.FilePath
                   Command.Ide.command116
                   (Options.Applicative.Types.$fAlternativeParser_$cempty
                      @ GHC.IO.FilePath)) -}
cca5eb807dd5243a5a2646cb9a134047
  command116 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.IO.FilePath
                   Command.Ide.command117) -}
7063c07f39261265006a5d4c5fb11a20
  command117 :: Options.Applicative.Types.Option GHC.IO.FilePath
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.IO.FilePath
                   Command.Ide.command118
                   Command.Ide.command15) -}
b1788f5e2fe754ade8d6b7a6ce0770e2
  command118 :: Options.Applicative.Types.OptReader GHC.IO.FilePath
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptReader
                   @ GHC.IO.FilePath
                   Command.Ide.command119
                   Command.Ide.command98
                   Options.Applicative.Types.ExpectsArgError) -}
daac147a0e477643a0140a3c0b58f889
  command119 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n8
                   Command.Ide.command120) -}
40ead5b060a014cd1b8cee088b366d5f
  command12 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4242) -}
3975a6b9e3bc95059d87f314573f97ed
  command120 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n7
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
02fe2ef052574e70b0f2ecb77c2f7c76
  command121 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Command.Ide.command122) -}
af5b9efc0233ea105b9ae58c961281cb
  command122 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("directory"#) -}
6a308c094f9f2663262ab263c2b60e41
  command123 ::
    Command.Ide.ServerOptions
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2,
     Strictness: <S(LLLLLLSL),1*U(U,U,U,U(U),U,U,U,U)><S,U> -}
9be556f1a4aa6e8c804039a9520f898f
  command124 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("server"#) -}
364d7879d3f77a9d88ed0409fe603877
  command13 ::
    Options.Applicative.Types.Parser GHC.Integer.Type.Integer
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command14) -}
1867aa619cce8b386b5eb71c42a424d7
  command14 ::
    Options.Applicative.Types.Option GHC.Integer.Type.Integer
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command16
                   Command.Ide.command15) -}
3137f6cf8fcfd8153bffd7d103411d89
  command15 :: Options.Applicative.Types.OptProperties
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.OptProperties
                   Options.Applicative.Types.Visible
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   Options.Applicative.Builder.abortOption_var
                   (GHC.Base.Nothing @ GHC.Base.String)
                   (GHC.Base.Nothing
                      @ (Text.PrettyPrint.ANSI.Leijen.Internal.Doc
                         -> Text.PrettyPrint.ANSI.Leijen.Internal.Doc))) -}
e1163d650a69ba390ecbf5184e1313e0
  command16 ::
    Options.Applicative.Types.OptReader GHC.Integer.Type.Integer
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptReader
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command19
                   Command.Ide.command17
                   Options.Applicative.Types.ExpectsArgError) -}
7217864eda479ffcd1698e9fa1e02884
  command17 ::
    Options.Applicative.Types.CReader GHC.Integer.Type.Integer
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.CReader
                   @ GHC.Integer.Type.Integer
                   Options.Applicative.Types.$fMonoidCompleter3
                     `cast`
                   ((<GHC.Base.String>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <[GHC.Base.String]>_R)) ; Sym (Options.Applicative.Types.N:Completer[0]))
                   Command.Ide.command18
                     `cast`
                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <GHC.Base.String>_R
                             <Control.Monad.Trans.Except.Except
                                Options.Applicative.Types.ParseError>_R
                             <GHC.Integer.Type.Integer>_N) ; Sym (Options.Applicative.Types.N:ReadM[0]) <GHC.Integer.Type.Integer>_N)) -}
13416d4cfeeeb0a32d571d7d6e03f38a
  command18 ::
    GHC.Base.String
    -> Control.Monad.Trans.Except.Except
         Options.Applicative.Types.ParseError GHC.Integer.Type.Integer
  {- Arity: 1,
     Unfolding: (Options.Applicative.Builder.auto1
                   @ GHC.Integer.Type.Integer
                   GHC.Read.$fReadInteger) -}
2307c2575f946bc0369ce1d9f96084df
  command19 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n1
                   Command.Ide.command20) -}
d08561d3628fb563c4b5f52ad41fa976
  command2 ::
    [Options.Applicative.Builder.Internal.Mod
       Options.Applicative.Builder.Internal.CommandFields
       (GHC.Types.IO ())]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Options.Applicative.Builder.Internal.Mod
                        Options.Applicative.Builder.Internal.CommandFields
                        (GHC.Types.IO ()))
                   Command.Ide.command3
                   (GHC.Types.[]
                      @ (Options.Applicative.Builder.Internal.Mod
                           Options.Applicative.Builder.Internal.CommandFields
                           (GHC.Types.IO ())))) -}
e30c628059095295d137e52ad900fa68
  command20 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
312eb7b6547640fa020fb9e4f426a844
  command21 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command22) -}
743a70300fdf0ae15adeb1278546089b
  command22 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("port"#) -}
7ef91ff741e6e3a8cf8b34d2f261bfe5
  command23 :: GHC.Integer.Type.Integer -> Command.Ide.ClientOptions
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m,
     Unfolding: (\ (x :: GHC.Integer.Type.Integer) ->
                 Command.Ide.ClientOptions
                   (Network.PortNumber
                      (case GHC.Integer.Type.integerToInt x of wild { DEFAULT ->
                       case {__pkg_ccall network-2.6.3.6 GHC.Prim.Word#
                                                         -> GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Word# #)}
                              (GHC.Prim.narrow16Word# (GHC.Prim.int2Word# wild))
                              GHC.Prim.realWorld# of wild1 { (#,#) ds ds1 ->
                       (GHC.Word.W16# (GHC.Prim.narrow16Word# ds1))
                         `cast`
                       (Sym (Network.Socket.Types.N:PortNumber[0])) } }))) -}
172896a3ff4660f29a8b79bab2e6f9c9
  command24 ::
    Command.Ide.ClientOptions
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U(U)><S,U> -}
df0b30275404f0cc58f1f84eb7372dce
  command25 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("client"#) -}
c334bb7e836b33c2bcd98f4bdeb6e695
  command26 ::
    Options.Applicative.Builder.Internal.CommandFields
      (GHC.Types.IO ())
    -> Options.Applicative.Builder.Internal.CommandFields
         (GHC.Types.IO ())
  {- Arity: 1, Strictness: <S,1*U(U,U)>m,
     Unfolding: (\ (p :: Options.Applicative.Builder.Internal.CommandFields
                           (GHC.Types.IO ())) ->
                 case p of wild { Options.Applicative.Builder.Internal.CommandFields ds ds1 ->
                 Options.Applicative.Builder.Internal.CommandFields
                   @ (GHC.Types.IO ())
                   (GHC.Types.:
                      @ (GHC.Base.String,
                         Options.Applicative.Types.ParserInfo (GHC.Types.IO ()))
                      Command.Ide.command_lvl1
                      ds)
                   ds1 }) -}
14303686eddb09bd599e3c0b77526136
  command27 ::
    Options.Applicative.Help.Chunk.Chunk
      Text.PrettyPrint.ANSI.Leijen.Internal.Doc
  {- Unfolding: (Options.Applicative.Help.Chunk.paragraph_go
                   (GHC.CString.unpackCString# Command.Ide.command28)) -}
68d4b0d2ca720b9e36c0bf08429a2ff4
  command28 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Start a server process"#) -}
5077c9412071f8c5cc3da70c601fe349
  command29 :: Options.Applicative.Types.Parser (GHC.Types.IO ())
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.IO ())
                   @ (GHC.Types.IO () -> GHC.Types.IO ())
                   Command.Ide.command30
                   (Options.Applicative.Extra.helper @ (GHC.Types.IO ()))) -}
92a8e7f634ba9a693081f5d53b2a0858
  command3 ::
    Options.Applicative.Builder.Internal.Mod
      Options.Applicative.Builder.Internal.CommandFields
      (GHC.Types.IO ())
  {- Strictness: m,
     Unfolding: (Options.Applicative.Builder.Internal.Mod
                   @ Options.Applicative.Builder.Internal.CommandFields
                   @ (GHC.Types.IO ())
                   Command.Ide.command4
                   (Options.Applicative.Builder.Internal.$fMonoidDefaultProp_$cmempty
                      @ (GHC.Types.IO ()))
                   (GHC.Base.id @ Options.Applicative.Types.OptProperties)) -}
dbd53579eb3b4a32359780bf30aedbeb
  command30 ::
    Options.Applicative.Types.Parser
      ((GHC.Types.IO () -> GHC.Types.IO ()) -> GHC.Types.IO ())
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ (GHC.Types.IO ())
                   @ ((GHC.Types.IO () -> GHC.Types.IO ()) -> GHC.Types.IO ())
                   (GHC.Base.<**>1 @ (GHC.Types.IO ()) @ (GHC.Types.IO ()))
                   (Options.Applicative.Types.$fApplicativeParser_$cfmap
                      @ Command.Ide.ServerOptions
                      @ (GHC.Types.IO ())
                      Command.Ide.command123
                        `cast`
                      (<Command.Ide.ServerOptions>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                      Command.Ide.command31)) -}
714e72a79ebb59ea781a2a2573cabd1e
  command31 ::
    Options.Applicative.Types.Parser Command.Ide.ServerOptions
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ Command.Ide.ServerOptions
                   @ GHC.Types.Bool
                   Command.Ide.command41
                   Command.Ide.command32) -}
4a062848af2d3e762f802a92bb211089
  command32 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command33
                   Options.Applicative.Builder.switch1) -}
1eb804d39940cb15ac4a3231f8005139
  command33 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command34
                   (Options.Applicative.Types.$fAlternativeParser_$cempty
                      @ GHC.Types.Bool)) -}
263c17b1275e3d6729caf0347fd822b9
  command34 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.Types.Bool
                   Command.Ide.command35) -}
83930c03af95ef5ff112b4e49d050d23
  command35 :: Options.Applicative.Types.Option GHC.Types.Bool
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.Types.Bool
                   Command.Ide.command37
                   Command.Ide.command36) -}
e28f13335740260c9822dd794144f508
  command36 :: Options.Applicative.Types.OptProperties
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Options.Applicative.Types.OptProperties
                   Options.Applicative.Types.Visible
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Base.Nothing @ GHC.Base.String)
                   (GHC.Base.Nothing
                      @ (Text.PrettyPrint.ANSI.Leijen.Internal.Doc
                         -> Text.PrettyPrint.ANSI.Leijen.Internal.Doc))) -}
fd60a52e61aa356f42322f8b61982c7e
  command37 :: Options.Applicative.Types.OptReader GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.FlagReader
                   @ GHC.Types.Bool
                   Command.Ide.command38
                   GHC.Types.True) -}
ea7d329bef07f35a88afd2c648cf5a11
  command38 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n2
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
537d12c66f240034588ad13a572e1288
  command39 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command40) -}
c60f1465039eb203a2440f4c1cc2bddb
  command4 ::
    Options.Applicative.Builder.Internal.CommandFields
      (GHC.Types.IO ())
    -> Options.Applicative.Builder.Internal.CommandFields
         (GHC.Types.IO ())
  {- Arity: 1, Strictness: <S,1*U(U,U)>m,
     Unfolding: (\ (p :: Options.Applicative.Builder.Internal.CommandFields
                           (GHC.Types.IO ())) ->
                 case p of wild { Options.Applicative.Builder.Internal.CommandFields ds ds1 ->
                 Options.Applicative.Builder.Internal.CommandFields
                   @ (GHC.Types.IO ())
                   (GHC.Types.:
                      @ (GHC.Base.String,
                         Options.Applicative.Types.ParserInfo (GHC.Types.IO ()))
                      Command.Ide.command_lvl
                      ds)
                   ds1 }) -}
a9ed372cf6b05108c02a1da129d73578
  command40 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("editor-mode"#) -}
07183cbe6f5e55000314e0778cabdaf1
  command41 ::
    Options.Applicative.Types.Parser
      (GHC.Types.Bool -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.Bool -> Command.Ide.ServerOptions)
                   @ Language.PureScript.Ide.Types.IdeLogLevel
                   Command.Ide.command65
                   Command.Ide.command42) -}
7ea6985863649960bc8ff9386b56c0a2
  command42 ::
    Options.Applicative.Types.Parser
      Language.PureScript.Ide.Types.IdeLogLevel
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ Data.Text.Internal.Text
                   @ Language.PureScript.Ide.Types.IdeLogLevel
                   Command.Ide.command56
                   Command.Ide.command43) -}
2b9c1b62d243af3cb38cbdf69698c36a
  command43 ::
    Options.Applicative.Types.Parser Data.Text.Internal.Text
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ Data.Text.Internal.Text
                   Command.Ide.command46
                   Command.Ide.command44) -}
2223a39c44994ff8fa67547f407c45b4
  command44 ::
    Options.Applicative.Types.Parser Data.Text.Internal.Text
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.NilP
                   @ Data.Text.Internal.Text
                   Command.Ide.command45) -}
c1644b2f7bda88dc985916c13258e877
  command45 :: GHC.Base.Maybe Data.Text.Internal.Text
  {- Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ Data.Text.Internal.Text
                   Data.Text.Internal.empty_) -}
61c408a65e984c4434fce8c1b05024ed
  command46 ::
    Options.Applicative.Types.Parser Data.Text.Internal.Text
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ Data.Text.Internal.Text
                   Command.Ide.command47) -}
762e8efd2306537f3b27ed3f45c5d0f7
  command47 ::
    Options.Applicative.Types.Option Data.Text.Internal.Text
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ Data.Text.Internal.Text
                   Command.Ide.command50
                   Command.Ide.command48) -}
cc1e2d6150b85f7dad4764d171fada2f
  command48 :: Options.Applicative.Types.OptProperties
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.OptProperties
                   Options.Applicative.Types.Visible
                   Command.Ide.command_lvl2
                   Options.Applicative.Builder.abortOption_var
                   (GHC.Base.Nothing @ GHC.Base.String)
                   (GHC.Base.Nothing
                      @ (Text.PrettyPrint.ANSI.Leijen.Internal.Doc
                         -> Text.PrettyPrint.ANSI.Leijen.Internal.Doc))) -}
889109fbdfc04b9c31367f0b2d17187b
  command49 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("One of \"debug\", \"perf\", \"all\" or \"none\""#) -}
7c9dadc7bf45c9f28847bbd3e607692c
  command5 ::
    Options.Applicative.Help.Chunk.Chunk
      Text.PrettyPrint.ANSI.Leijen.Internal.Doc
  {- Unfolding: (Options.Applicative.Help.Chunk.paragraph_go
                   (GHC.CString.unpackCString# Command.Ide.command6)) -}
7b04bc42ed25bf3ad9e499de43f55823
  command50 ::
    Options.Applicative.Types.OptReader Data.Text.Internal.Text
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptReader
                   @ Data.Text.Internal.Text
                   Command.Ide.command53
                   Command.Ide.command51
                   Options.Applicative.Types.ExpectsArgError) -}
50ab0c98a114825517e9c72bd8490e2c
  command51 ::
    Options.Applicative.Types.CReader Data.Text.Internal.Text
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.CReader
                   @ Data.Text.Internal.Text
                   Options.Applicative.Types.$fMonoidCompleter3
                     `cast`
                   ((<GHC.Base.String>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <[GHC.Base.String]>_R)) ; Sym (Options.Applicative.Types.N:Completer[0]))
                   Command.Ide.command52
                     `cast`
                   ((<GHC.Base.String>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Options.Applicative.Types.ParseError
                                      Data.Text.Internal.Text>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                             <Options.Applicative.Types.ParseError>_N
                                                                             <Data.Functor.Identity.Identity>_R
                                                                             <Data.Text.Internal.Text>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                       <*>_N
                                                                                                                       <GHC.Base.String>_R
                                                                                                                       <Control.Monad.Trans.Except.Except
                                                                                                                          Options.Applicative.Types.ParseError>_R
                                                                                                                       <Data.Text.Internal.Text>_N) ; Sym (Options.Applicative.Types.N:ReadM[0]) <Data.Text.Internal.Text>_N))) -}
6c24bad40072be1b2391eabe1ee6e6e2
  command52 ::
    GHC.Base.String
    -> Data.Either.Either
         Options.Applicative.Types.ParseError Data.Text.Internal.Text
  {- Arity: 1, Strictness: <L,1*U>m2,
     Unfolding: (\ (eta1 :: GHC.Base.String) ->
                 Data.Either.Right
                   @ Options.Applicative.Types.ParseError
                   @ Data.Text.Internal.Text
                   (case GHC.Magic.runRW#
                           @ ('GHC.Types.TupleRep
                                '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                           @ (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Text.Internal.Text #)
                           (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                            case GHC.Prim.newByteArray#
                                   @ GHC.Prim.RealWorld
                                   10#
                                   s1 of ds1 { (#,#) ipv ipv1 ->
                            Command.Ide.$wouter
                              ipv1
                              4#
                              eta1
                              0#
                              ipv }) of ds1 { (#,#) ipv ipv1 ->
                    ipv1 })) -}
80e2aa47d1ed563a00f80abedf7f3396
  command53 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n3
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
983e165ca118ad7c67fd20085d87df76
  command54 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command55) -}
38c93a8de679f6a3cf8a739aa94133e9
  command55 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("log-level"#) -}
64802c198b2d9c50f60ee5c27c14ffd9
  command56 ::
    Data.Text.Internal.Text
    -> Language.PureScript.Ide.Types.IdeLogLevel
  {- Arity: 1, Strictness: <S(LLS),1*U(U,U,U)>,
     Unfolding: (\ (s :: Data.Text.Internal.Text) ->
                 case s of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                 case Command.Ide.command63 of wild1 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                 let {
                   $j :: Language.PureScript.Ide.Types.IdeLogLevel <join 0>
                   = case Command.Ide.command61 of wild2 { Data.Text.Internal.Text dt7 dt8 dt9 ->
                     let {
                       $j1 :: Language.PureScript.Ide.Types.IdeLogLevel <join 0>
                       = case Command.Ide.command59 of wild3 { Data.Text.Internal.Text dt10 dt11 dt12 ->
                         let {
                           $j2 :: Language.PureScript.Ide.Types.IdeLogLevel <join 0>
                           = case Command.Ide.command57 of wild4 { Data.Text.Internal.Text dt13 dt14 dt15 ->
                             case GHC.Prim.==# dt2 dt15 of lwild {
                               DEFAULT -> Language.PureScript.Ide.Types.LogDefault
                               1#
                               -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                                 -> GHC.Prim.Word#
                                                                 -> GHC.Prim.ByteArray#
                                                                 -> GHC.Prim.Word#
                                                                 -> GHC.Prim.Word#
                                                                 -> GHC.Prim.State#
                                                                      GHC.Prim.RealWorld
                                                                 -> (# GHC.Prim.State#
                                                                         GHC.Prim.RealWorld,
                                                                       GHC.Prim.Int# #)}
                                         dt
                                         (GHC.Prim.int2Word# dt1)
                                         dt13
                                         (GHC.Prim.int2Word# dt14)
                                         (GHC.Prim.int2Word# dt2)
                                         GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                                  case GHC.Prim.narrow32Int# ds3 of wild6 {
                                    DEFAULT -> Language.PureScript.Ide.Types.LogDefault
                                    0# -> Language.PureScript.Ide.Types.LogNone } } } }
                         } in
                         case GHC.Prim.==# dt2 dt12 of lwild {
                           DEFAULT -> $j2
                           1#
                           -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                             -> GHC.Prim.Word#
                                                             -> GHC.Prim.ByteArray#
                                                             -> GHC.Prim.Word#
                                                             -> GHC.Prim.Word#
                                                             -> GHC.Prim.State# GHC.Prim.RealWorld
                                                             -> (# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Int# #)}
                                     dt
                                     (GHC.Prim.int2Word# dt1)
                                     dt10
                                     (GHC.Prim.int2Word# dt11)
                                     (GHC.Prim.int2Word# dt2)
                                     GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                              case GHC.Prim.narrow32Int# ds3 of wild4 {
                                DEFAULT -> $j2 0# -> Language.PureScript.Ide.Types.LogAll } } } }
                     } in
                     case GHC.Prim.==# dt2 dt9 of lwild {
                       DEFAULT -> $j1
                       1#
                       -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                         -> GHC.Prim.Word#
                                                         -> GHC.Prim.ByteArray#
                                                         -> GHC.Prim.Word#
                                                         -> GHC.Prim.Word#
                                                         -> GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Int# #)}
                                 dt
                                 (GHC.Prim.int2Word# dt1)
                                 dt7
                                 (GHC.Prim.int2Word# dt8)
                                 (GHC.Prim.int2Word# dt2)
                                 GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                          case GHC.Prim.narrow32Int# ds3 of wild3 {
                            DEFAULT -> $j1 0# -> Language.PureScript.Ide.Types.LogPerf } } } }
                 } in
                 case GHC.Prim.==# dt2 dt5 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.ByteArray#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.State# GHC.Prim.RealWorld
                                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                           GHC.Prim.Int# #)}
                             dt
                             (GHC.Prim.int2Word# dt1)
                             dt3
                             (GHC.Prim.int2Word# dt4)
                             (GHC.Prim.int2Word# dt2)
                             GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                      case GHC.Prim.narrow32Int# ds3 of wild2 {
                        DEFAULT -> $j
                        0# -> Language.PureScript.Ide.Types.LogDebug } } } } }) -}
83d5f72ba4dd0cceb497dda8d15cc107
  command57 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Command.Ide.command58) -}
dc22eb5c0cd4a91316fa50b94084f83b
  command58 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("none"#) -}
918a0aca405115f9c4afb177d27f7475
  command59 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Command.Ide.command60) -}
a9ec1c1bb1d0423710adc98b7d0928c3
  command6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Connect to a running server"#) -}
f1140ab2d85ec7e87bcce340fb527d19
  command60 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("all"#) -}
cf3891e6f46303f52a027f89464c3d91
  command61 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Command.Ide.command62) -}
38472ed2d227c09f833b73eabf9c59b9
  command62 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("perf"#) -}
5c78e3241d5a5be4bb58e104539c0e5d
  command63 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Command.Ide.command64) -}
bf1898befd909e4849c62a87b8fcfbb2
  command64 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("debug"#) -}
e4b1bd09f4fd0ab717fbb89a319ec8f4
  command65 ::
    Options.Applicative.Types.Parser
      (Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool -> Command.Ide.ServerOptions)
                   @ GHC.Types.Bool
                   Command.Ide.command77
                   Command.Ide.command66) -}
d1affb36fdbf5e07bf24a336805071e4
  command66 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ GHC.Types.Bool
                   @ GHC.Types.Bool
                   Command.Ide.command75
                   Command.Ide.command67) -}
b3304822bd1036711e3654f77dd6b555
  command67 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command68
                   Options.Applicative.Builder.switch1) -}
dd9358e931b2548c2832e06ed471a144
  command68 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command69
                   (Options.Applicative.Types.$fAlternativeParser_$cempty
                      @ GHC.Types.Bool)) -}
1b47f4f7c6a7c55f8fe3fd595024fadf
  command69 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.Types.Bool
                   Command.Ide.command70) -}
91391d93220dd1cb35ab12b9f61846aa
  command7 :: Options.Applicative.Types.Parser (GHC.Types.IO ())
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.IO ())
                   @ (GHC.Types.IO () -> GHC.Types.IO ())
                   Command.Ide.command8
                   (Options.Applicative.Extra.helper @ (GHC.Types.IO ()))) -}
aa11e93d6e465b6891343ff5a86bf560
  command70 :: Options.Applicative.Types.Option GHC.Types.Bool
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.Types.Bool
                   Command.Ide.command71
                   Command.Ide.command36) -}
b0fa75adfafb4d3b54dc70d6a85aa304
  command71 :: Options.Applicative.Types.OptReader GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.FlagReader
                   @ GHC.Types.Bool
                   Command.Ide.command72
                   GHC.Types.True) -}
88dcedd8b072bb93555d4595897e604f
  command72 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n4
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
cfed5c7adf3e627e1c925b39ad004ebf
  command73 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command74) -}
c745f7bf802a852625b0dfd1bf2a499c
  command74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("polling"#) -}
c5a2308b80f49bd667c1d2dbe9dac900
  command75 :: GHC.Types.Bool -> GHC.Types.Bool
  {- Unfolding: (case GHC.Base.eqString
                        System.Info.os
                        (GHC.CString.unpackCString# Command.Ide.command76) of wild {
                   GHC.Types.False -> Protolude.identity @ GHC.Types.Bool
                   GHC.Types.True -> GHC.Classes.not }) -}
b9eadf2a360c73e3d5c28aa6b2f89078
  command76 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("mingw32"#) -}
f8ff7043c4a58f165d5179641a329d72
  command77 ::
    Options.Applicative.Types.Parser
      (GHC.Types.Bool
       -> Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool
       -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.Bool
                      -> Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool
                      -> Command.Ide.ServerOptions)
                   @ GHC.Types.Bool
                   Command.Ide.command86
                   Command.Ide.command78) -}
db8452f797bc3b92e7f760d36c3ef3ff
  command78 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command79
                   Options.Applicative.Builder.switch1) -}
fc984b6c2b79f7036cf3be62caf0ce21
  command79 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Types.Bool
                   Command.Ide.command80
                   (Options.Applicative.Types.$fAlternativeParser_$cempty
                      @ GHC.Types.Bool)) -}
f3b70a18c0d3be6c5a50af41b40381ff
  command8 ::
    Options.Applicative.Types.Parser
      ((GHC.Types.IO () -> GHC.Types.IO ()) -> GHC.Types.IO ())
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ (GHC.Types.IO ())
                   @ ((GHC.Types.IO () -> GHC.Types.IO ()) -> GHC.Types.IO ())
                   (GHC.Base.<**>1 @ (GHC.Types.IO ()) @ (GHC.Types.IO ()))
                   (Options.Applicative.Types.$fApplicativeParser_$cfmap
                      @ Command.Ide.ClientOptions
                      @ (GHC.Types.IO ())
                      Command.Ide.command24
                        `cast`
                      (<Command.Ide.ClientOptions>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                      (Options.Applicative.Types.$fApplicativeParser_$cfmap
                         @ GHC.Integer.Type.Integer
                         @ Command.Ide.ClientOptions
                         Command.Ide.command23
                         Command.Ide.command9))) -}
d558134fb64057d21dd0dd16eff2e189
  command80 :: Options.Applicative.Types.Parser GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.Types.Bool
                   Command.Ide.command81) -}
8ab4e01c003a69a71b4e11b3e979c397
  command81 :: Options.Applicative.Types.Option GHC.Types.Bool
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.Types.Bool
                   Command.Ide.command82
                   Command.Ide.command36) -}
a64c64a9f6bcf41e6b936827661f6a7e
  command82 :: Options.Applicative.Types.OptReader GHC.Types.Bool
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.FlagReader
                   @ GHC.Types.Bool
                   Command.Ide.command83
                   GHC.Types.True) -}
a80384cbc6abc0011df80d53eab7e8fc
  command83 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n5
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
2fb1664ad982c24e5ae825abce459b3a
  command84 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command85) -}
f2adaaba95ebd8c3964b5d911c097583
  command85 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("no-watch"#) -}
6fb4de726c53bd714a6daa5194fb29a9
  command86 ::
    Options.Applicative.Types.Parser
      (GHC.Types.Bool
       -> GHC.Types.Bool
       -> Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool
       -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (GHC.Types.Bool
                      -> GHC.Types.Bool
                      -> Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool
                      -> Command.Ide.ServerOptions)
                   @ Network.Socket.Types.PortNumber
                   Command.Ide.command89
                   Command.Ide.command87) -}
378a56cd759817c2943b285b01087351
  command87 ::
    Options.Applicative.Types.Parser Network.Socket.Types.PortNumber
  {- Unfolding: (Options.Applicative.Types.$fApplicativeParser_$cfmap
                   @ GHC.Integer.Type.Integer
                   @ Network.Socket.Types.PortNumber
                   Command.Ide.command88
                   Command.Ide.command9) -}
f1458212844693845e287fcd1b9f3ec2
  command88 ::
    GHC.Integer.Type.Integer -> Network.Socket.Types.PortNumber
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: (\ (eta1 :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.integerToInt eta1 of wild { DEFAULT ->
                 case {__pkg_ccall network-2.6.3.6 GHC.Prim.Word#
                                                   -> GHC.Prim.State# GHC.Prim.RealWorld
                                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                         GHC.Prim.Word# #)}
                        (GHC.Prim.narrow16Word# (GHC.Prim.int2Word# wild))
                        GHC.Prim.realWorld# of wild1 { (#,#) ds ds1 ->
                 (GHC.Word.W16# (GHC.Prim.narrow16Word# ds1))
                   `cast`
                 (Sym (Network.Socket.Types.N:PortNumber[0])) } }) -}
baffe08b68520c7d0647d234f464ace8
  command89 ::
    Options.Applicative.Types.Parser
      (Network.Socket.Types.PortNumber
       -> GHC.Types.Bool
       -> GHC.Types.Bool
       -> Language.PureScript.Ide.Types.IdeLogLevel
       -> GHC.Types.Bool
       -> Command.Ide.ServerOptions)
  {- Unfolding: (Options.Applicative.Types.MultP
                   @ (Network.Socket.Types.PortNumber
                      -> GHC.Types.Bool
                      -> GHC.Types.Bool
                      -> Language.PureScript.Ide.Types.IdeLogLevel
                      -> GHC.Types.Bool
                      -> Command.Ide.ServerOptions)
                   @ GHC.IO.FilePath
                   Command.Ide.command102
                   Command.Ide.command90) -}
cbddf8280a68bf34a2eaaa61097e0d91
  command9 ::
    Options.Applicative.Types.Parser GHC.Integer.Type.Integer
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.Integer.Type.Integer
                   Command.Ide.command13
                   Command.Ide.command10) -}
9b28016877daaabc01be9adfe2c64312
  command90 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m4,
     Unfolding: (Options.Applicative.Types.AltP
                   @ GHC.IO.FilePath
                   Command.Ide.command95
                   Command.Ide.command91) -}
5927689f305345c6c723d3c49916d0f6
  command91 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.NilP
                   @ GHC.IO.FilePath
                   Command.Ide.command92) -}
be90170b370f1910d1d97724ea30e617
  command92 :: GHC.Base.Maybe GHC.IO.FilePath
  {- Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ GHC.IO.FilePath
                   Command.Ide.command93) -}
8f637c7305fed4a090e7cf6157bc73ca
  command93 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command94) -}
143eba2538c7ffa819de93a063d6aab1
  command94 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("output/"#) -}
61f69510db64a9d70490e6cc090cf82a
  command95 :: Options.Applicative.Types.Parser GHC.IO.FilePath
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptP
                   @ GHC.IO.FilePath
                   Command.Ide.command96) -}
f773d22a57832bdfd73c0a306e9170cf
  command96 :: Options.Applicative.Types.Option GHC.IO.FilePath
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.Option
                   @ GHC.IO.FilePath
                   Command.Ide.command97
                   Command.Ide.command15) -}
078636b579ea5b8205efeb5f14b2b24a
  command97 :: Options.Applicative.Types.OptReader GHC.IO.FilePath
  {- Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptReader
                   @ GHC.IO.FilePath
                   Command.Ide.command99
                   Command.Ide.command98
                   Options.Applicative.Types.ExpectsArgError) -}
1822e2bdc05d7ed6c8a9c53412863c8c
  command98 :: Options.Applicative.Types.CReader GHC.IO.FilePath
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Options.Applicative.Types.CReader
                   @ GHC.IO.FilePath
                   Options.Applicative.Types.$fMonoidCompleter3
                     `cast`
                   ((<GHC.Base.String>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <[GHC.Base.String]>_R)) ; Sym (Options.Applicative.Types.N:Completer[0]))
                   (Data.Either.Right
                      @ Options.Applicative.Types.ParseError
                      @ GHC.IO.FilePath)
                     `cast`
                   ((<GHC.Base.String>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Options.Applicative.Types.ParseError
                                      GHC.IO.FilePath>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                     <Options.Applicative.Types.ParseError>_N
                                                                     <Data.Functor.Identity.Identity>_R
                                                                     <GHC.IO.FilePath>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                       <*>_N
                                                                                                       <GHC.Base.String>_R
                                                                                                       <Control.Monad.Trans.Except.Except
                                                                                                          Options.Applicative.Types.ParseError>_R
                                                                                                       <GHC.IO.FilePath>_N) ; Sym (Options.Applicative.Types.N:ReadM[0]) <GHC.IO.FilePath>_N))) -}
c30471cfa45605967ad92de3d56a6f51
  command99 :: [Options.Applicative.Types.OptName]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Options.Applicative.Types.OptName
                   Command.Ide.command_n6
                   (GHC.Types.[] @ Options.Applicative.Types.OptName)) -}
f7a1a4dfcb67cf44b883edc52dff1e0e
  command_$s$wgo ::
    (Options.Applicative.Builder.Internal.CommandFields
       (GHC.Types.IO ())
     -> Options.Applicative.Builder.Internal.CommandFields
          (GHC.Types.IO ()))
    -> Options.Applicative.Builder.Internal.DefaultProp
         (GHC.Types.IO ())
    -> (Options.Applicative.Types.OptProperties
        -> Options.Applicative.Types.OptProperties)
    -> [Options.Applicative.Builder.Internal.Mod
          Options.Applicative.Builder.Internal.CommandFields
          (GHC.Types.IO ())]
    -> (# Options.Applicative.Builder.Internal.CommandFields
            (GHC.Types.IO ())
          -> Options.Applicative.Builder.Internal.CommandFields
               (GHC.Types.IO ()),
          Options.Applicative.Builder.Internal.DefaultProp (GHC.Types.IO ()),
          Options.Applicative.Types.OptProperties
          -> Options.Applicative.Types.OptProperties #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(U)><L,1*U(1*U,1*U)><L,C(U)><S,1*U> -}
920b8c46e4a3fb9c86605004a1b4829e
  command_cmd :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Command.Ide.command25) -}
120b6d81ac0ef0999d68ef27d56b4e5f
  command_cmd1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Command.Ide.command124) -}
7133a7419e7f4e6eed78576ed2f083f9
  command_lvl ::
    (GHC.Base.String,
     Options.Applicative.Types.ParserInfo (GHC.Types.IO ()))
  {- Strictness: m,
     Unfolding: ((Command.Ide.command_cmd,
                  Command.Ide.command_pinfo)) -}
608be36fa093bad15eca980551b05ad9
  command_lvl1 ::
    (GHC.Base.String,
     Options.Applicative.Types.ParserInfo (GHC.Types.IO ()))
  {- Strictness: m,
     Unfolding: ((Command.Ide.command_cmd1,
                  Command.Ide.command_pinfo1)) -}
96f2f38c46b6cc9fb0bcd03e8620bb3c
  command_lvl2 ::
    Options.Applicative.Help.Chunk.Chunk
      Text.PrettyPrint.ANSI.Leijen.Internal.Doc
  {- Unfolding: (Options.Applicative.Help.Chunk.paragraph_go
                   (GHC.CString.unpackCString# Command.Ide.command49)) -}
64d0f1308c86a31df9ec4c036485403a
  command_n :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command21) -}
73bd96dcc6527823b170d4a64c5924c1
  command_n1 :: Options.Applicative.Types.OptName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptShort 'p'#) -}
22fbfbc09806eed814c6f63df75c5c9a
  command_n2 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command39) -}
6d01e9637ce6cf86ebeae70723395807
  command_n3 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command54) -}
818f2654ae3b098c59f41b51c0222b84
  command_n4 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command73) -}
8dd1be13b47fa01522fefdea02783409
  command_n5 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command84) -}
ecbecdce433c2d2dc307faf48dd70025
  command_n6 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command100) -}
54f8684ef095425466823c6b69fdfa61
  command_n7 :: Options.Applicative.Types.OptName
  {- Strictness: m2,
     Unfolding: (Options.Applicative.Types.OptLong
                   Command.Ide.command121) -}
3a7c9c0d9ae553ca98a89e4568de9469
  command_n8 :: Options.Applicative.Types.OptName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Options.Applicative.Types.OptShort 'd'#) -}
ebc4ac813e1342f9a361993514709e74
  command_pinfo ::
    Options.Applicative.Types.ParserInfo (GHC.Types.IO ())
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.ParserInfo
                   @ (GHC.Types.IO ())
                   Command.Ide.command7
                   GHC.Types.True
                   Command.Ide.command5
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   Options.Applicative.Builder.info1
                   Options.Applicative.Types.Intersperse) -}
2410083e7085519d3dcd5efcc92b48ae
  command_pinfo1 ::
    Options.Applicative.Types.ParserInfo (GHC.Types.IO ())
  {- Strictness: m,
     Unfolding: (Options.Applicative.Types.ParserInfo
                   @ (GHC.Types.IO ())
                   Command.Ide.command29
                   GHC.Types.True
                   Command.Ide.command27
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   (GHC.Base.Nothing @ Text.PrettyPrint.ANSI.Leijen.Internal.Doc)
                     `cast`
                   (Sym (Options.Applicative.Help.Chunk.N:Chunk[0]) <Text.PrettyPrint.ANSI.Leijen.Internal.Doc>_N)
                   Options.Applicative.Builder.info1
                   Options.Applicative.Types.Intersperse) -}
668b6d6576abd67f62698ec9f025fe7b
  command_var :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Command.Ide.command108) -}
instance GHC.Show.Show [Command.Ide.ServerOptions]
  = Command.Ide.$fShowServerOptions
"SPEC/Command.Ide $fApplicativeExceptT @ (ReaderT
                                           IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                              (v1 :: GHC.Base.Monad
                                                                                                                                                       (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                          Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                          (Control.Monad.Logger.LoggingT
                                                                                                                                                             GHC.Types.IO)))
                                                                                                                                              (v :: GHC.Base.Functor
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                       Language.PureScript.Ide.Types.IdeEnvironment
                                                       (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                                  @ e
                                                  v
                                                  v1
  = Command.Ide.$s$fApplicativeExceptT @ e
"SPEC/Command.Ide $fApplicativeExceptT_$c*> @ (ReaderT
                                                IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                                            GHC.Types.IO)))
                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                        (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                           (Control.Monad.Logger.LoggingT
                                                                                                                                                                              GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ (Control.Monad.Trans.Reader.ReaderT
                                                            Language.PureScript.Ide.Types.IdeEnvironment
                                                            (Control.Monad.Logger.LoggingT
                                                               GHC.Types.IO))
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/Command.Ide $fApplicativeExceptT_$c<* @ (ReaderT
                                                IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                                            GHC.Types.IO)))
                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                        (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                           (Control.Monad.Logger.LoggingT
                                                                                                                                                                              GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c<* @ (Control.Monad.Trans.Reader.ReaderT
                                                            Language.PureScript.Ide.Types.IdeEnvironment
                                                            (Control.Monad.Logger.LoggingT
                                                               GHC.Types.IO))
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c<*
      @ e
"SPEC/Command.Ide $fApplicativeExceptT_$c<*> @ (ReaderT
                                                 IdeEnvironment (LoggingT IO)) _" [orphan] [0] forall @ e
                                                                                                                                                              (w1 :: GHC.Base.Monad
                                                                                                                                                                       (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                          Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                          (Control.Monad.Logger.LoggingT
                                                                                                                                                                             GHC.Types.IO)))
                                                                                                                                                              (w :: GHC.Base.Functor
                                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*> @ (Control.Monad.Trans.Reader.ReaderT
                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                             (Control.Monad.Logger.LoggingT
                                                                GHC.Types.IO))
                                                        @ e
                                                        w
                                                        w1
  = Command.Ide.$s$fApplicativeExceptT_$c<*> @ e
"SPEC/Command.Ide $fApplicativeExceptT_$cliftA2 @ (ReaderT
                                                    IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                                                                                    GHC.Types.IO)))
                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                   Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                   (Control.Monad.Logger.LoggingT
                                                                                                                                                                                      GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cliftA2 @ (Control.Monad.Trans.Reader.ReaderT
                                                                Language.PureScript.Ide.Types.IdeEnvironment
                                                                (Control.Monad.Logger.LoggingT
                                                                   GHC.Types.IO))
                                                           @ e
                                                           $dFunctor
                                                           $dMonad
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cliftA2
      @ e
"SPEC/Command.Ide $fApplicativeExceptT_$cpure @ (ReaderT
                                                  IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                             (Control.Monad.Logger.LoggingT
                                                                                                                                                                                GHC.Types.IO)))
                                                                                                                                                            ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                            (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                               Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                               (Control.Monad.Logger.LoggingT
                                                                                                                                                                                  GHC.Types.IO)))
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ (Control.Monad.Trans.Reader.ReaderT
                                                              Language.PureScript.Ide.Types.IdeEnvironment
                                                              (Control.Monad.Logger.LoggingT
                                                                 GHC.Types.IO))
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/Command.Ide $fApplicativeLoggingT @ IO" [orphan] forall (v :: GHC.Base.Applicative
                                                                      GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT @ GHC.Types.IO v
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT
"SPEC/Command.Ide $fApplicativeLoggingT_$c<*> @ IO" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                        GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT_$c<*> @ GHC.Types.IO
                                                   $dApplicative
  = Command.Ide.$s$fApplicativeExceptT_$s$fApplicativeLoggingT_$c<*>
"SPEC/Command.Ide $fFunctorExceptT @ (ReaderT
                                       IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                      (v :: GHC.Base.Functor
                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                                                    GHC.Types.IO)))
  Control.Monad.Trans.Except.$fFunctorExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                   Language.PureScript.Ide.Types.IdeEnvironment
                                                   (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                              @ e
                                              v
  = Command.Ide.$s$fApplicativeExceptT_$s$fFunctorExceptT @ e
"SPEC/Command.Ide $fFunctorLoggingT @ IO" [orphan] forall (v :: GHC.Base.Functor
                                                                  GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT @ GHC.Types.IO v
  = Command.Ide.$s$fApplicativeExceptT_$s$fFunctorLoggingT
"SPEC/Command.Ide $fFunctorLoggingT_$cfmap @ IO" [orphan] forall ($dFunctor :: GHC.Base.Functor
                                                                                 GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT_$cfmap @ GHC.Types.IO
                                                $dFunctor
  = Command.Ide.$s$fApplicativeExceptT_$s$fFunctorLoggingT_$cfmap
"SPEC/Command.Ide $fMonadErroreExceptT @ (ReaderT
                                           IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                              (v :: GHC.Base.Monad
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Error.Class.$fMonadErroreExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                      Language.PureScript.Ide.Types.IdeEnvironment
                                                      (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                                 @ e
                                                 v
  = Command.Ide.$s$fMonadErroreExceptT @ e
"SPEC/Command.Ide $fMonadExceptT @ (ReaderT
                                     IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                  (v :: GHC.Base.Monad
                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                             (Control.Monad.Logger.LoggingT
                                                                                                                                                GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                 (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                            @ e
                                            v
  = Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT @ e
"SPEC/Command.Ide $fMonadExceptT1 @ (ReaderT
                                      IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                  (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                     Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                     (Control.Monad.Logger.LoggingT
                                                                                                                                                        GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadExceptT1 @ (Control.Monad.Trans.Reader.ReaderT
                                                  Language.PureScript.Ide.Types.IdeEnvironment
                                                  (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                             @ e
                                             $dMonad
  = Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT1 @ e
"SPEC/Command.Ide $fMonadExceptT_$c>> @ (ReaderT
                                          IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                             (Control.Monad.Logger.LoggingT
                                                                                                                                                                GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ (Control.Monad.Trans.Reader.ReaderT
                                                      Language.PureScript.Ide.Types.IdeEnvironment
                                                      (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                                 @ e
                                                 $dMonad
  = Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$c>> @ e
"SPEC/Command.Ide $fMonadExceptT_$c>>= @ (ReaderT
                                           IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                                                                            (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                               Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                               (Control.Monad.Logger.LoggingT
                                                                                                                                                                  GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ (Control.Monad.Trans.Reader.ReaderT
                                                       Language.PureScript.Ide.Types.IdeEnvironment
                                                       (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                                  @ e
                                                  $dMonad
  = Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$c>>= @ e
"SPEC/Command.Ide $fMonadExceptT_$cfail @ (ReaderT
                                            IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                                                                    GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadExceptT_$cfail @ (Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO))
                                                   @ e
                                                   $dMonad
  = Command.Ide.$s$fMonadErroreExceptT_$s$fMonadExceptT_$cfail @ e
"SPEC/Command.Ide $fMonadIOExceptT @ (ReaderT
                                       IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                      (v :: Control.Monad.IO.Class.MonadIO
                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                                                    GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadIOExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                   Language.PureScript.Ide.Types.IdeEnvironment
                                                   (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                              @ e
                                              v
  = Command.Ide.$s$fMonadIOExceptT @ e
"SPEC/Command.Ide $fMonadIOReaderT @ (LoggingT IO) _" [orphan] forall @ r
                                                                      (v :: Control.Monad.IO.Class.MonadIO
                                                                              (Control.Monad.Logger.LoggingT
                                                                                 GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadIOReaderT @ (Control.Monad.Logger.LoggingT
                                                   GHC.Types.IO)
                                              @ r
                                              v
  = Command.Ide.$s$fMonadIOReaderT @ r
"SPEC/Command.Ide $fMonadLoggerExceptT @ (ReaderT
                                           IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                              (v :: Control.Monad.Logger.MonadLogger
                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Logger.$fMonadLoggerExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                 (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                            @ e
                                            v
  = Command.Ide.$s$fMonadLoggerExceptT @ e
"SPEC/Command.Ide $fMonadLoggerReaderT @ (LoggingT IO) _" [orphan] forall @ r
                                                                          (v :: Control.Monad.Logger.MonadLogger
                                                                                  (Control.Monad.Logger.LoggingT
                                                                                     GHC.Types.IO))
  Control.Monad.Logger.$fMonadLoggerReaderT @ (Control.Monad.Logger.LoggingT
                                                 GHC.Types.IO)
                                            @ r
                                            v
  = Command.Ide.$s$fMonadLoggerExceptT_$s$fMonadLoggerReaderT @ r
"SPEC/Command.Ide $fMonadLoggingT @ IO" [orphan] forall (v :: GHC.Base.Monad
                                                                GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT @ GHC.Types.IO v
  = Command.Ide.$s$fApplicativeExceptT_$s$fMonadLoggingT
"SPEC/Command.Ide $fMonadLoggingT_$c>> @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                           GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$c>> @ GHC.Types.IO $dMonad
  = Command.Ide.$s$fApplicativeExceptT_$s$fMonadLoggingT_$c>>
"SPEC/Command.Ide $fMonadLoggingT_$creturn @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                               GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$creturn @ GHC.Types.IO
                                                $dMonad
  = Command.Ide.$s$fMonadLoggingT_$creturn
"SPEC/Command.Ide $fMonadReaderT @ (LoggingT IO) _" [orphan] forall @ r
                                                                    (v :: GHC.Base.Monad
                                                                            (Control.Monad.Logger.LoggingT
                                                                               GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Logger.LoggingT
                                                 GHC.Types.IO)
                                            @ r
                                            v
  = Command.Ide.$s$fApplicativeExceptT_$s$fMonadReaderT @ r
"SPEC/Command.Ide $fMonadReaderrExceptT @ IdeEnvironment @ (ReaderT
                                                             IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                                                  (v :: Control.Monad.Reader.Class.MonadReader
                                                                                                                                                                                          Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                             Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                             (Control.Monad.Logger.LoggingT
                                                                                                                                                                                                GHC.Types.IO)))
  Control.Monad.Reader.Class.$fMonadReaderrExceptT @ Language.PureScript.Ide.Types.IdeEnvironment
                                                   @ (Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO))
                                                   @ e
                                                   v
  = Command.Ide.$s$fMonadReaderrExceptT @ e
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

