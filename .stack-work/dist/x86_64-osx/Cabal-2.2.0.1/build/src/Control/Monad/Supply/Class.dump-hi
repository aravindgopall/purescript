
==================== FINAL INTERFACE ====================
2019-01-24 14:13:23.349493 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Supply.Class 8043
  interface hash: b161c2cb0fa6e9d82b4f1be2f31fb1c6
  ABI hash: 4b0577d8897e2d48cd4fc324f0e8c355
  export-list hash: 9b5454b78bf2751cecd07ba41d8b4d51
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 42bf7a4f72bcf0a244dc3cf815e08f65
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Control.Monad.Supply.Class.freshName
  Control.Monad.Supply.Class.MonadSupply{Control.Monad.Supply.Class.fresh Control.Monad.Supply.Class.peek}
module dependencies: Control.Monad.Supply
package dependencies: array-0.5.2.0 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 bytestring-0.10.8.2
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0 mtl-2.2.2 text-1.2.3.0 transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.0:Data.Text
import  -/  base-4.11.1.0:Data.Type.Equality 9bb29c7615a8eec000fd03d114737416
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer b86905dc6b5d4d3a09dfa93d3ac3bb98
import  -/  Control.Monad.Supply 95e15bedaf79f313b09bccb6a9122994
  exports: 15e005f374fb6992e116699e0e7b7c5f
  SupplyT 28581351d3973868f1c0ba294aca8250
  SupplyT bb1f4fa577226d92c4e387a7717c5df6
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Class 352c7bdb1604d64f8f438c96bf57066a
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Writer.Lazy 932eb57f5933138df24d28686f218b40
ee747a4e8318dd4e42a385d3e3870881
  $dmfresh ::
    Control.Monad.Supply.Class.MonadSupply m =>
    forall (t :: (* -> *) -> * -> *) (n :: * -> *).
    (Control.Monad.Trans.Class.MonadTrans t,
     Control.Monad.Supply.Class.MonadSupply n,
     (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) =>
    m GHC.Integer.Type.Integer
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(C(S)),1*C1(C1(U))><L,U(1*U,1*U,A)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (0, True, False)
                (\ @ m :: * -> *
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m)
                   @ t :: (* -> *) -> * -> *
                   @ n :: * -> *
                   ($dMonadTrans :: Control.Monad.Trans.Class.MonadTrans t)
                   ($dMonadSupply1 :: Control.Monad.Supply.Class.MonadSupply n)
                   ($d~ :: (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) ->
                 case GHC.Types.HEq_sc
                        @ (* -> *)
                        @ (* -> *)
                        @ m
                        @ (t n)
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <* -> *>_N <m>_N <t n>_N) of co { DEFAULT ->
                 ($dMonadTrans
                    `cast`
                  (Control.Monad.Trans.Class.N:MonadTrans[0] <t>_N)
                    @ n
                    @ GHC.Integer.Type.Integer
                    (Control.Monad.Supply.Class.$p1MonadSupply @ n $dMonadSupply1)
                    (Control.Monad.Supply.Class.fresh @ n $dMonadSupply1))
                   `cast`
                 (Sub (Sym co) <GHC.Integer.Type.Integer>_N) }) -}
c8396c4eb3daa634002569bb97bf9e4b
  $dmpeek ::
    Control.Monad.Supply.Class.MonadSupply m =>
    forall (t :: (* -> *) -> * -> *) (n :: * -> *).
    (Control.Monad.Trans.Class.MonadTrans t,
     Control.Monad.Supply.Class.MonadSupply n,
     (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) =>
    m GHC.Integer.Type.Integer
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(C(S)),1*C1(C1(U))><L,U(1*U,A,1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (0, True, False)
                (\ @ m :: * -> *
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m)
                   @ t :: (* -> *) -> * -> *
                   @ n :: * -> *
                   ($dMonadTrans :: Control.Monad.Trans.Class.MonadTrans t)
                   ($dMonadSupply1 :: Control.Monad.Supply.Class.MonadSupply n)
                   ($d~ :: (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) ->
                 case GHC.Types.HEq_sc
                        @ (* -> *)
                        @ (* -> *)
                        @ m
                        @ (t n)
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <* -> *>_N <m>_N <t n>_N) of co { DEFAULT ->
                 ($dMonadTrans
                    `cast`
                  (Control.Monad.Trans.Class.N:MonadTrans[0] <t>_N)
                    @ n
                    @ GHC.Integer.Type.Integer
                    (Control.Monad.Supply.Class.$p1MonadSupply @ n $dMonadSupply1)
                    (Control.Monad.Supply.Class.peek @ n $dMonadSupply1))
                   `cast`
                 (Sub (Sym co) <GHC.Integer.Type.Integer>_N) }) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyStateT ::
    Control.Monad.Supply.Class.MonadSupply m =>
    Control.Monad.Supply.Class.MonadSupply
      (Control.Monad.Trans.State.Lazy.StateT s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),U,U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      @ s
                      (v :: Control.Monad.Supply.Class.MonadSupply m).
                  @ (Control.Monad.Trans.State.Lazy.StateT s m)
                  (Control.Monad.Supply.Class.$fMonadSupplyStateT_$cp1MonadSupply
                     @ m
                     @ s
                     v)
                  (Control.Monad.Supply.Class.$fMonadSupplyStateT2 @ m @ s v)
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <m>_R <GHC.Integer.Type.Integer>_N))
                  (Control.Monad.Supply.Class.$fMonadSupplyStateT1 @ m @ s v)
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <m>_R <GHC.Integer.Type.Integer>_N)) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyStateT1 ::
    Control.Monad.Supply.Class.MonadSupply m =>
    s -> m (GHC.Integer.Type.Integer, s)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,1*U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ s
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m)
                   (eta :: s) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Integer.Type.Integer
                   @ (GHC.Integer.Type.Integer, s)
                   (Control.Monad.Supply.Class.peek @ m $dMonadSupply)
                   (\ (a1 :: GHC.Integer.Type.Integer) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ (GHC.Integer.Type.Integer, s)
                      (a1, eta))) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyStateT2 ::
    Control.Monad.Supply.Class.MonadSupply m =>
    s -> m (GHC.Integer.Type.Integer, s)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ s
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m)
                   (eta :: s) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Integer.Type.Integer
                   @ (GHC.Integer.Type.Integer, s)
                   (Control.Monad.Supply.Class.fresh @ m $dMonadSupply)
                   (\ (a1 :: GHC.Integer.Type.Integer) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ (GHC.Integer.Type.Integer, s)
                      (a1, eta))) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyStateT_$cp1MonadSupply ::
    Control.Monad.Supply.Class.MonadSupply m =>
    GHC.Base.Monad (Control.Monad.Trans.State.Lazy.StateT s m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   @ s
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m) ->
                 Control.Monad.Trans.State.Lazy.$fMonadStateT
                   @ m
                   @ s
                   (Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply)) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplySupplyT ::
    GHC.Base.Monad m =>
    Control.Monad.Supply.Class.MonadSupply
      (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fMonadSupplyT @ m v)
                  (Control.Monad.Supply.Class.$fMonadSupplySupplyT1 @ m v)
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <GHC.Integer.Type.Integer>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <GHC.Integer.Type.Integer>_N)
                  (Control.Monad.Trans.State.Lazy.get
                     @ m
                     @ GHC.Integer.Type.Integer
                     v)
                    `cast`
                  (Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <GHC.Integer.Type.Integer>_N) -}
e0ab88ba0b272a361b456f5751a47e79
  $fMonadSupplySupplyT1 ::
    GHC.Base.Monad m =>
    GHC.Integer.Type.Integer
    -> m (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- Arity: 2,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: GHC.Integer.Type.Integer) ->
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                   (GHC.Base.return
                      @ m
                      $dMonad
                      @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                      (eta, eta))
                   (\ (ds :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                    let {
                      n :: GHC.Integer.Type.Integer = case ds of wild { (,) a1 s' -> a1 }
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ ((), GHC.Integer.Type.Integer)
                      @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                      (GHC.Base.return
                         @ m
                         $dMonad
                         @ ((), GHC.Integer.Type.Integer)
                         (GHC.Tuple.(),
                          GHC.Integer.Type.plusInteger
                            n
                            Control.Monad.Supply.Class.$fMonadSupplySupplyT2))
                      (\ (ds1 :: ((), GHC.Integer.Type.Integer)) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                         (n, case ds1 of wild { (,) a1 s' -> s' })))) -}
1a2fc0edf0de0eb0b3c14a7b71bbbc35
  $fMonadSupplySupplyT2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyWriterT ::
    (GHC.Base.Monoid w, Control.Monad.Supply.Class.MonadSupply m) =>
    Control.Monad.Supply.Class.MonadSupply
      (Control.Monad.Trans.Writer.Lazy.WriterT w m)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,U,C(C1(U)),A)><L,U(U(U(U(C(C(U)),A),C(U),A,C(C1(C1(U))),A,A),C(C1(U)),A,C(U),C(U)),U,U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ w
                      @ m :: * -> *
                      (v :: GHC.Base.Monoid w)
                      (v1 :: Control.Monad.Supply.Class.MonadSupply m).
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT w m)
                  (Control.Monad.Supply.Class.$fMonadSupplyWriterT_$cp1MonadSupply
                     @ w
                     @ m
                     v
                     v1)
                  (Control.Monad.Supply.Class.$fMonadSupplyWriterT_$cfresh
                     @ w
                     @ m
                     v
                     v1)
                  (Control.Monad.Supply.Class.$fMonadSupplyWriterT_$cpeek
                     @ w
                     @ m
                     v
                     v1) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyWriterT_$cfresh ::
    (GHC.Base.Monoid w, Control.Monad.Supply.Class.MonadSupply m) =>
    Control.Monad.Trans.Writer.Lazy.WriterT
      w m GHC.Integer.Type.Integer
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U,A,A)><S(S(LC(C(S))LLL)LL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)>,
     Unfolding: (\ @ w
                   @ m :: * -> *
                   ($dMonoid :: GHC.Base.Monoid w)
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m) ->
                 let {
                   lvl2 :: w = GHC.Base.mempty @ w $dMonoid
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply
                 } in
                 (GHC.Base.>>=
                    @ m
                    $dMonad
                    @ GHC.Integer.Type.Integer
                    @ (GHC.Integer.Type.Integer, w)
                    (Control.Monad.Supply.Class.fresh @ m $dMonadSupply)
                    (\ (a1 :: GHC.Integer.Type.Integer) ->
                     GHC.Base.return
                       @ m
                       $dMonad
                       @ (GHC.Integer.Type.Integer, w)
                       (a1, lvl2)))
                   `cast`
                 (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N <m>_R <GHC.Integer.Type.Integer>_N))) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyWriterT_$cp1MonadSupply ::
    (GHC.Base.Monoid w, Control.Monad.Supply.Class.MonadSupply m) =>
    GHC.Base.Monad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,U,C(C1(U)),A)><L,1*U(1*U(U(U(C(C(U)),A),C(U),A,C(C1(C1(U))),A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ w
                   @ m :: * -> *
                   ($dMonoid :: GHC.Base.Monoid w)
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m) ->
                 Control.Monad.Trans.Writer.Lazy.$fMonadWriterT
                   @ w
                   @ m
                   $dMonoid
                   (Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply)) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  $fMonadSupplyWriterT_$cpeek ::
    (GHC.Base.Monoid w, Control.Monad.Supply.Class.MonadSupply m) =>
    Control.Monad.Trans.Writer.Lazy.WriterT
      w m GHC.Integer.Type.Integer
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U,A,A)><S(S(LC(C(S))LLL)LL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,1*U)>,
     Unfolding: (\ @ w
                   @ m :: * -> *
                   ($dMonoid :: GHC.Base.Monoid w)
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m) ->
                 let {
                   lvl2 :: w = GHC.Base.mempty @ w $dMonoid
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply
                 } in
                 (GHC.Base.>>=
                    @ m
                    $dMonad
                    @ GHC.Integer.Type.Integer
                    @ (GHC.Integer.Type.Integer, w)
                    (Control.Monad.Supply.Class.peek @ m $dMonadSupply)
                    (\ (a1 :: GHC.Integer.Type.Integer) ->
                     GHC.Base.return
                       @ m
                       $dMonad
                       @ (GHC.Integer.Type.Integer, w)
                       (a1, lvl2)))
                   `cast`
                 (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N <m>_R <GHC.Integer.Type.Integer>_N))) -}
e436b3ac9be5efc22d18aae6abaea610
  $tc'C:MonadSupply :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8703955955527298854##
                   10953475685461911915##
                   Control.Monad.Supply.Class.$trModule
                   Control.Monad.Supply.Class.$tc'C:MonadSupply2
                   1#
                   Control.Monad.Supply.Class.$tc'C:MonadSupply1) -}
11ada0751d9914a58b37d15f46972ace
  $tc'C:MonadSupply1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
147959e50bfae2b9a96fec5f251f4ea2
  $tc'C:MonadSupply2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Control.Monad.Supply.Class.$tc'C:MonadSupply3) -}
ca1921006cacd0e1afc6654704534ebb
  $tc'C:MonadSupply3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:MonadSupply"#) -}
3e449b6c4ffe95d9d3dcb17c8549a889
  $tcMonadSupply :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7955673157959535849##
                   6298577457153942333##
                   Control.Monad.Supply.Class.$trModule
                   Control.Monad.Supply.Class.$tcMonadSupply2
                   0#
                   Control.Monad.Supply.Class.$tcMonadSupply1) -}
fe1321f19aa11f63d981a595e9d17a34
  $tcMonadSupply1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6c75d0d3370e17e1dd8ce7fed4e4d2f5
  $tcMonadSupply2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Control.Monad.Supply.Class.$tcMonadSupply3) -}
fe4b2474dbb6a19e5683a2fa0d0315cd
  $tcMonadSupply3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MonadSupply"#) -}
9d97ec489b432e7ecf5f33e1ce08b18c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Control.Monad.Supply.Class.$trModule3
                   Control.Monad.Supply.Class.$trModule1) -}
7ccb65ecdb61c0d7201c9011e986d286
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Control.Monad.Supply.Class.$trModule2) -}
ff269875291f0a6c359ecdf44262113c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Control.Monad.Supply.Class"#) -}
f6daf51e8d5c0aa392f8993d4341ae5a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Control.Monad.Supply.Class.$trModule4) -}
33b920f305727c541820af877d13f9f6
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
6fd5e162006451a17cf4a7ae2eb71bd2
  class GHC.Base.Monad m => MonadSupply (m :: * -> *) where
    fresh :: m GHC.Integer.Type.Integer
    default fresh :: (Control.Monad.Trans.Class.MonadTrans t,
                      Control.Monad.Supply.Class.MonadSupply n,
                      (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) =>
                     m GHC.Integer.Type.Integer
    peek :: m GHC.Integer.Type.Integer
    default peek :: (Control.Monad.Trans.Class.MonadTrans t,
                     Control.Monad.Supply.Class.MonadSupply n,
                     (m :: (* -> *)) Data.Type.Equality.~ (t n :: (* -> *))) =>
                    m GHC.Integer.Type.Integer
3b42bd990d5e852928ea9f3f20a8c018
  freshName ::
    Control.Monad.Supply.Class.MonadSupply m =>
    m Data.Text.Internal.Text
  {- Arity: 1,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadSupply :: Control.Monad.Supply.Class.MonadSupply m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.Supply.Class.$p1MonadSupply @ m $dMonadSupply)))
                   @ GHC.Integer.Type.Integer
                   @ Data.Text.Internal.Text
                   Control.Monad.Supply.Class.freshName1
                   (Control.Monad.Supply.Class.fresh @ m $dMonadSupply)) -}
2b5ba6aed8eb58b6c87f4e1cfc080b3e
  freshName1 :: GHC.Integer.Type.Integer -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,U> -}
instance Control.Monad.Supply.Class.MonadSupply [Control.Monad.Trans.State.Lazy.StateT]
  = Control.Monad.Supply.Class.$fMonadSupplyStateT
instance Control.Monad.Supply.Class.MonadSupply [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.Class.$fMonadSupplySupplyT
instance Control.Monad.Supply.Class.MonadSupply [Control.Monad.Trans.Writer.Lazy.WriterT]
  = Control.Monad.Supply.Class.$fMonadSupplyWriterT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

