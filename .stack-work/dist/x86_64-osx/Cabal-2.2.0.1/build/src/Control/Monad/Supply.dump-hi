
==================== FINAL INTERFACE ====================
2019-01-24 14:13:23.092683 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Supply 8043
  interface hash: ed4fe49c52be647d75c031c599e57d9f
  ABI hash: 95e15bedaf79f313b09bccb6a9122994
  export-list hash: 15e005f374fb6992e116699e0e7b7c5f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e13600c1a4343ba22057b0dbda7f31dd
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Control.Monad.Supply.evalSupply
  Control.Monad.Supply.evalSupplyT
  Control.Monad.Supply.runSupply
  Control.Monad.Supply.runSupplyT
  Control.Monad.Supply.Supply
  Control.Monad.Supply.SupplyT{Control.Monad.Supply.SupplyT unSupplyT}
module dependencies:
package dependencies: base-4.11.1.0 base-compat-0.10.4
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:GHC.Exts base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader a496a2f5c2c54feee0ad154b4fe8533d
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.Writer b86905dc6b5d4d3a09dfa93d3ac3bb98
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Class 352c7bdb1604d64f8f438c96bf57066a
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
bb1f4fa577226d92c4e387a7717c5df6
  $fAlternativeSupplyT ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Alternative (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.MonadPlus m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fAlternativeSupplyT_$cp1Alternative @ m v)
                  (\ @ a (ds :: GHC.Integer.Type.Integer) ->
                   GHC.Base.mzero @ m v @ (a, GHC.Integer.Type.Integer))
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT3 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT2 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <[a]>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <[a]>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <[a]>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <[a]>_N) -}
67d53109d78b8897c66abd45e3fe9578
  $fAlternativeSupplyT1 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer -> m ([a], GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))),U(1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(A,C(C1(U)),A,C(U),A),A,C(C1(U)))><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT1
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Alternative
                         @ m
                         (GHC.Base.$p1MonadPlus @ m $dMonadPlus)))
                   $dMonadPlus
                   @ a
                   eta
                   eta1) -}
a3f498f109682b99905253eaf3d13489
  $fAlternativeSupplyT2 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer -> m ([a], GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(A,C(C1(U)),A,C(U),A),A,C(C1(U)))><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT3
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Alternative
                         @ m
                         (GHC.Base.$p1MonadPlus @ m $dMonadPlus)))
                   $dMonadPlus
                   @ a
                   eta
                   eta1) -}
d50be78a647e77b1161c02bd8662ea57
  $fAlternativeSupplyT3 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.mplus
                   @ m
                   $dMonadPlus
                   @ (a, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)
                   (eta1
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fAlternativeSupplyT_$cp1Alternative ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Applicative (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadPlus :: GHC.Base.MonadPlus m) ->
                 Control.Monad.Supply.$fApplicativeSupplyT
                   @ m
                   (GHC.Base.$p2MonadPlus @ m $dMonadPlus)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fApplicativeSupplyT ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fApplicativeSupplyT_$cp1Applicative @ m v)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   GHC.Base.return @ m v @ (a, GHC.Integer.Type.Integer) (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT4 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a -> b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT3 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <c>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <c>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT2 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
7d653450cc75bb4ece5609022d7e9aff
  $fApplicativeSupplyT1 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   $dMonad
                   @ a
                   @ b
                   @ a
                   (GHC.Base.const @ a @ b)
                   eta
                   eta1
                   eta2) -}
c529386a6aed8a08b987fd18b769e7c0
  $fApplicativeSupplyT2 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (b, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (a, GHC.Integer.Type.Integer)
                   @ (b, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)
                   (\ (ds :: (a, GHC.Integer.Type.Integer)) ->
                    eta1
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <b>_N)
                      (case ds of wild { (,) a1 s' -> s' }))) -}
af0e1fea6c8e6cae362a894381d621a8
  $fApplicativeSupplyT3 ::
    GHC.Base.Monad m =>
    forall a b c.
    (a -> b -> c)
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (c, GHC.Integer.Type.Integer)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)><L,C(U)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   @ c
                   (eta :: a -> b -> c)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta3 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   $dMonad
                   @ a
                   @ b
                   @ c
                   eta
                   eta1
                   eta2
                   eta3) -}
1b330fb981d665d119210663c8db9e05
  $fApplicativeSupplyT4 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      GHC.Integer.Type.Integer m (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer
    -> m (b, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m (a -> b))
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (a -> b, GHC.Integer.Type.Integer)
                   @ (b, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a -> b>_N)
                      eta2)
                   (\ (ds2 :: (a -> b, GHC.Integer.Type.Integer)) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (a, GHC.Integer.Type.Integer)
                      @ (b, GHC.Integer.Type.Integer)
                      (eta1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                         (case ds2 of wild { (,) f s' -> s' }))
                      (\ (ds3 :: (a, GHC.Integer.Type.Integer)) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (b, GHC.Integer.Type.Integer)
                         (case ds2 of wild { (,) f s' ->
                          f (case ds3 of wild1 { (,) x s'' -> x }) },
                          case ds3 of wild { (,) x s'' -> s'' })))) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fApplicativeSupplyT_$cp1Applicative ::
    GHC.Base.Monad m =>
    GHC.Base.Functor (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Control.Monad.Supply.$fFunctorSupplyT
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fFunctorSupplyT ::
    GHC.Base.Functor m =>
    GHC.Base.Functor (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fFunctorStateT1
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadErrorSupplyT ::
    Control.Monad.Error.Class.MonadError e m =>
    Control.Monad.Error.Class.MonadError
      e (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),C(U),C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ e
                      @ m :: * -> *
                      (v :: Control.Monad.Error.Class.MonadError e m).
                  @ e
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fMonadErrorSupplyT_$cp1MonadError @ e @ m v)
                  (\ @ a ->
                   Control.Monad.Error.Class.$fMonadErroreStateT0_$cthrowError
                     @ e
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <e>_R ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Error.Class.$fMonadErroreStateT2
                     @ e
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R (<e>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadErrorSupplyT_$cp1MonadError ::
    Control.Monad.Error.Class.MonadError e m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Error.Class.$p1MonadError @ e @ m $dMonadError)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadPlusSupplyT ::
    GHC.Base.MonadPlus m =>
    GHC.Base.MonadPlus (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),U,C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.MonadPlus m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fAlternativeSupplyT @ m v)
                  (Control.Monad.Supply.$fMonadPlusSupplyT_$cp2MonadPlus @ m v)
                  (\ @ a (ds :: GHC.Integer.Type.Integer) ->
                   GHC.Base.mzero @ m v @ (a, GHC.Integer.Type.Integer))
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.State.Lazy.$fMonadPlusStateT_$cmplus
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadPlusSupplyT_$cp2MonadPlus ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadPlus :: GHC.Base.MonadPlus m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (GHC.Base.$p2MonadPlus @ m $dMonadPlus)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadReaderSupplyT ::
    Control.Monad.Reader.Class.MonadReader r m =>
    Control.Monad.Reader.Class.MonadReader
      r (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),U,C(C(U)),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ r
                      @ m :: * -> *
                      (v :: Control.Monad.Reader.Class.MonadReader r m).
                  @ r
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fMonadReaderSupplyT_$cp1MonadReader
                     @ r
                     @ m
                     v)
                  (Control.Monad.Reader.Class.$fMonadReaderrStateT2
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v)
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <r>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <r>_N)
                  (\ @ a ->
                   Control.Monad.Reader.Class.$fMonadReaderrStateT0_$clocal
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <r -> r>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Reader.Class.$fMonadReaderrStateT0_$creader
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <r -> a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadReaderSupplyT_$cp1MonadReader ::
    Control.Monad.Reader.Class.MonadReader r m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ r
                   @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader r m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Reader.Class.$p1MonadReader
                      @ r
                      @ m
                      $dMonadReader)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadSupplyT ::
    GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fApplicativeSupplyT @ m v)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>=
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   GHC.Base.return @ m v @ (a, GHC.Integer.Type.Integer) (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadTransSupplyT ::
    Control.Monad.Trans.Class.MonadTrans Control.Monad.Supply.SupplyT
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,U><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (Control.Monad.Trans.State.Lazy.$fMonadTransStateT_$clift
                   @ GHC.Integer.Type.Integer)
                  `cast`
                ((forall (m :: <* -> *>_N) (a :: <*>_N).
                  <GHC.Base.Monad m>_R
                  ->_R <m a>_R
                  ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) ; Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                                                                                       <Control.Monad.Supply.SupplyT>_N)) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadWriterSupplyT ::
    Control.Monad.Writer.Class.MonadWriter w m =>
    Control.Monad.Writer.Class.MonadWriter
      w (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),C(U),C(U),C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ w
                      @ m :: * -> *
                      (v :: Control.Monad.Writer.Class.MonadWriter w m).
                  @ w
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Writer.Class.$p1MonadWriter @ w @ m v)
                  (Control.Monad.Supply.$fMonadWriterSupplyT_$cp2MonadWriter
                     @ w
                     @ m
                     v)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT0_$cwriter
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, w)>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT0_$ctell
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v)
                    `cast`
                  (<w>_R ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <()>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <(a, w)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <(a,
                                                                                               w)>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <(a, w -> w)>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  $fMonadWriterSupplyT_$cp2MonadWriter ::
    Control.Monad.Writer.Class.MonadWriter w m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ w
                   @ m :: * -> *
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter w m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Writer.Class.$p2MonadWriter
                      @ w
                      @ m
                      $dMonadWriter)) -}
f0eaea469d7f47f610ac0d9fd411bca8
  $tc'SupplyT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4970802172975880433##
                   13881700710078077900##
                   Control.Monad.Supply.$trModule
                   Control.Monad.Supply.$tc'SupplyT2
                   2#
                   Control.Monad.Supply.$tc'SupplyT1) -}
09385b00aa9cefdea52bbb78f868501a
  $tc'SupplyT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e512e5cf32a461880b06ba318bd31354
  $tc'SupplyT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$tc'SupplyT3) -}
5de2c61e55d093e96815b5ff7b896316
  $tc'SupplyT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SupplyT"#) -}
a1d0cc6295ebd732a7ecfb3b979a107d
  $tcSupplyT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3542028492034991262##
                   6413509699941944954##
                   Control.Monad.Supply.$trModule
                   Control.Monad.Supply.$tcSupplyT2
                   0#
                   Control.Monad.Supply.$tcSupplyT1) -}
d8f09fd96af5228fa3632e09cf6bedb5
  $tcSupplyT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c60c5f4698a3c4059123c7bd6c672e52
  $tcSupplyT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$tcSupplyT3) -}
fa1f87c0a86e5cec5d9992e59c6e4024
  $tcSupplyT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SupplyT"#) -}
5bf75e3e76a2ed1bd827b82102e458ff
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Control.Monad.Supply.$trModule3
                   Control.Monad.Supply.$trModule1) -}
ca602e7ebdc759b465e801d3c0007ff5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$trModule2) -}
cd445352fdcfce62016a8a64c93fa840
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Control.Monad.Supply"#) -}
8e13e9fc4bbfd3af5e6239819be1f544
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$trModule4) -}
5f9aef821f38406ad930b30ffcfcb43c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
c1c6bdee62d2d9b55ec7b0e45335a3d8
  type Supply =
    Control.Monad.Supply.SupplyT Data.Functor.Identity.Identity
    :: * -> *
bb1f4fa577226d92c4e387a7717c5df6
  type role SupplyT representational nominal
  newtype SupplyT (m :: * -> *) a
    = SupplyT {unSupplyT :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a}
8094e209e147c84844b52f5cf1f3d47d
  evalSupply ::
    GHC.Integer.Type.Integer -> Control.Monad.Supply.Supply a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><C(S(SL)),1*C1(U(1*U,A))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (n :: GHC.Integer.Type.Integer)
                   (x :: Control.Monad.Supply.SupplyT
                           Data.Functor.Identity.Identity a) ->
                 case (x `cast`
                       (Control.Monad.Supply.N:SupplyT[0] <Data.Functor.Identity.Identity>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                         <GHC.Integer.Type.Integer>_N
                                                                                                         <Data.Functor.Identity.Identity>_R
                                                                                                         <a>_N)
                         n)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(a, GHC.Integer.Type.Integer)>_R) of wild { (,) x1 ds1 ->
                 x1 }) -}
324b9183ea553a363af9ce46190d7c70
  evalSupplyT ::
    GHC.Base.Functor m =>
    GHC.Integer.Type.Integer -> Control.Monad.Supply.SupplyT m a -> m a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (n :: GHC.Integer.Type.Integer) ->
                 let {
                   f :: m (a, GHC.Integer.Type.Integer) -> m a
                   = GHC.Base.fmap
                       @ m
                       $dFunctor
                       @ (a, GHC.Integer.Type.Integer)
                       @ a
                       (Data.Tuple.fst @ a @ GHC.Integer.Type.Integer)
                 } in
                 \ (x :: Control.Monad.Supply.SupplyT m a) ->
                 f (x `cast`
                    (Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                         <GHC.Integer.Type.Integer>_N
                                                                         <m>_R
                                                                         <a>_N)
                      n)) -}
11b952736d54be10fea97c2b1834ce1d
  runSupply ::
    GHC.Integer.Type.Integer
    -> Control.Monad.Supply.Supply a -> (a, GHC.Integer.Type.Integer)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                (Control.Monad.Supply.runSupplyT @ Data.Functor.Identity.Identity)
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Integer.Type.Integer>_R
                 ->_R <Control.Monad.Supply.SupplyT
                         Data.Functor.Identity.Identity a>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a, GHC.Integer.Type.Integer)>_R) -}
393662bc2c2c5ee2d86bf784af1ab05b
  runSupplyT ::
    GHC.Integer.Type.Integer
    -> Control.Monad.Supply.SupplyT m a
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ m :: * -> *
                   @ a
                   (n :: GHC.Integer.Type.Integer)
                   (eta :: Control.Monad.Supply.SupplyT m a) ->
                 eta
                   `cast`
                 (Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                      <GHC.Integer.Type.Integer>_N
                                                                      <m>_R
                                                                      <a>_N)
                   n) -}
bb1f4fa577226d92c4e387a7717c5df6
  unSupplyT ::
    Control.Monad.Supply.SupplyT m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
  RecSel Left Control.Monad.Supply.SupplyT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Control.Monad.Supply.unSupplyT1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Control.Monad.Supply.SupplyT m a>_R
                 ->_R Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N) -}
bb1f4fa577226d92c4e387a7717c5df6
  unSupplyT1 ::
    Control.Monad.Supply.SupplyT m a
    -> Control.Monad.Supply.SupplyT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Control.Monad.Supply.SupplyT m a) ->
                 ds) -}
instance GHC.Base.Alternative [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fAlternativeSupplyT
instance GHC.Base.Applicative [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fApplicativeSupplyT
instance GHC.Base.Functor [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fFunctorSupplyT
instance Control.Monad.Error.Class.MonadError [.,
                                               Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadErrorSupplyT
instance GHC.Base.MonadPlus [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadPlusSupplyT
instance Control.Monad.Reader.Class.MonadReader [.,
                                                 Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadReaderSupplyT
instance GHC.Base.Monad [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadSupplyT
instance Control.Monad.Trans.Class.MonadTrans [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadTransSupplyT
instance Control.Monad.Writer.Class.MonadWriter [.,
                                                 Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadWriterSupplyT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

