
==================== FINAL INTERFACE ====================
2018-11-30 19:26:06.008685 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Control.Monad.Supply 8043
  interface hash: eca34ff649cafb90130acde40d881be3
  ABI hash: a9e15eeca39e18ec2ace0537b1dcfc3b
  export-list hash: 33181f9f2f157b80f20fe5bc34a62230
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e13600c1a4343ba22057b0dbda7f31dd
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Control.Monad.Supply.evalSupply
  Control.Monad.Supply.evalSupplyT
  Control.Monad.Supply.runSupply
  Control.Monad.Supply.runSupplyT
  Control.Monad.Supply.Supply
  Control.Monad.Supply.SupplyT{Control.Monad.Supply.SupplyT unSupplyT}
module dependencies:
package dependencies: base-4.11.1.0 base-compat-0.10.4
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:GHC.Exts base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader a496a2f5c2c54feee0ad154b4fe8533d
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.Writer b86905dc6b5d4d3a09dfa93d3ac3bb98
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Class 352c7bdb1604d64f8f438c96bf57066a
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fAlternativeSupplyT ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Alternative (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.MonadPlus m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fAlternativeSupplyT_$cp1Alternative @ m v)
                  (\ @ a (ds :: GHC.Integer.Type.Integer) ->
                   GHC.Base.mzero @ m v @ (a, GHC.Integer.Type.Integer))
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT3 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT2 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <[a]>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <[a]>_N)
                  (Control.Monad.Supply.$fAlternativeSupplyT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <[a]>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <[a]>_N) -}
dca9dd19389ae7926bcb3951773dd5f9
  $fAlternativeSupplyT1 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer -> m ([a], GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))),U(1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(A,C(C1(U)),A,C(U),A),A,C(C1(U)))><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT1
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Alternative
                         @ m
                         (GHC.Base.$p1MonadPlus @ m $dMonadPlus)))
                   $dMonadPlus
                   @ a
                   eta
                   eta1) -}
6ef1d82e5eeadd07adb85351d6b5a349
  $fAlternativeSupplyT2 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer -> m ([a], GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(A,C(C1(U)),A,C(U),A),A,C(C1(U)))><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT3
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Alternative
                         @ m
                         (GHC.Base.$p1MonadPlus @ m $dMonadPlus)))
                   $dMonadPlus
                   @ a
                   eta
                   eta1) -}
6b57f2e902dde2b7ec19bc5dc4326c89
  $fAlternativeSupplyT3 ::
    GHC.Base.MonadPlus m =>
    forall a.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   @ a
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.mplus
                   @ m
                   $dMonadPlus
                   @ (a, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)
                   (eta1
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fAlternativeSupplyT_$cp1Alternative ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Applicative (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadPlus :: GHC.Base.MonadPlus m) ->
                 Control.Monad.Supply.$fApplicativeSupplyT
                   @ m
                   (GHC.Base.$p2MonadPlus @ m $dMonadPlus)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fApplicativeSupplyT ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fApplicativeSupplyT_$cp1Applicative @ m v)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   GHC.Base.return @ m v @ (a, GHC.Integer.Type.Integer) (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT4 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a -> b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT3 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <c>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <c>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT2 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (Control.Monad.Supply.$fApplicativeSupplyT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
638bb7004cf337a84444b4d938a4ef65
  $fApplicativeSupplyT1 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   $dMonad
                   @ a
                   @ b
                   @ a
                   (GHC.Base.const @ a @ b)
                   eta
                   eta1
                   eta2) -}
fb65be91aa7068b08803257f2b5d0814
  $fApplicativeSupplyT2 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (b, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (a, GHC.Integer.Type.Integer)
                   @ (b, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                      eta2)
                   (\ (ds :: (a, GHC.Integer.Type.Integer)) ->
                    eta1
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <b>_N)
                      (case ds of wild { (,) a1 s' -> s' }))) -}
49df2d010ae797ff3eedf1cd2e21bcc1
  $fApplicativeSupplyT3 ::
    GHC.Base.Monad m =>
    forall a b c.
    (a -> b -> c)
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m b
    -> GHC.Integer.Type.Integer
    -> m (c, GHC.Integer.Type.Integer)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A)><L,C(U)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   @ c
                   (eta :: a -> b -> c)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m b)
                   (eta3 :: GHC.Integer.Type.Integer) ->
                 Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                   @ m
                   @ GHC.Integer.Type.Integer
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   $dMonad
                   @ a
                   @ b
                   @ c
                   eta
                   eta1
                   eta2
                   eta3) -}
e2aac1055ebdfbc068a97a3ab5666e30
  $fApplicativeSupplyT4 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      GHC.Integer.Type.Integer m (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
    -> GHC.Integer.Type.Integer
    -> m (b, GHC.Integer.Type.Integer)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             GHC.Integer.Type.Integer m (a -> b))
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a)
                   (eta2 :: GHC.Integer.Type.Integer) ->
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (a -> b, GHC.Integer.Type.Integer)
                   @ (b, GHC.Integer.Type.Integer)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <GHC.Integer.Type.Integer>_N <m>_R <a -> b>_N)
                      eta2)
                   (\ (ds2 :: (a -> b, GHC.Integer.Type.Integer)) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (a, GHC.Integer.Type.Integer)
                      @ (b, GHC.Integer.Type.Integer)
                      (eta1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N <m>_R <a>_N)
                         (case ds2 of wild { (,) f s' -> s' }))
                      (\ (ds3 :: (a, GHC.Integer.Type.Integer)) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (b, GHC.Integer.Type.Integer)
                         (case ds2 of wild { (,) f s' ->
                          f (case ds3 of wild1 { (,) x s'' -> x }) },
                          case ds3 of wild { (,) x s'' -> s'' })))) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fApplicativeSupplyT_$cp1Applicative ::
    GHC.Base.Monad m =>
    GHC.Base.Functor (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Control.Monad.Supply.$fFunctorSupplyT
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fFunctorSupplyT ::
    GHC.Base.Functor m =>
    GHC.Base.Functor (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fFunctorStateT1
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadErrorSupplyT ::
    Control.Monad.Error.Class.MonadError e m =>
    Control.Monad.Error.Class.MonadError
      e (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),C(U),C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ e
                      @ m :: * -> *
                      (v :: Control.Monad.Error.Class.MonadError e m).
                  @ e
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fMonadErrorSupplyT_$cp1MonadError @ e @ m v)
                  (\ @ a ->
                   Control.Monad.Error.Class.$fMonadErroreStateT0_$cthrowError
                     @ e
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <e>_R ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Error.Class.$fMonadErroreStateT2
                     @ e
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R (<e>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadErrorSupplyT_$cp1MonadError ::
    Control.Monad.Error.Class.MonadError e m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Error.Class.$p1MonadError @ e @ m $dMonadError)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadPlusSupplyT ::
    GHC.Base.MonadPlus m =>
    GHC.Base.MonadPlus (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),U,C(C1(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.MonadPlus m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fAlternativeSupplyT @ m v)
                  (Control.Monad.Supply.$fMonadPlusSupplyT_$cp2MonadPlus @ m v)
                  (\ @ a (ds :: GHC.Integer.Type.Integer) ->
                   GHC.Base.mzero @ m v @ (a, GHC.Integer.Type.Integer))
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.State.Lazy.$fMonadPlusStateT_$cmplus
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadPlusSupplyT_$cp2MonadPlus ::
    GHC.Base.MonadPlus m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadPlus :: GHC.Base.MonadPlus m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (GHC.Base.$p2MonadPlus @ m $dMonadPlus)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadReaderSupplyT ::
    Control.Monad.Reader.Class.MonadReader r m =>
    Control.Monad.Reader.Class.MonadReader
      r (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),U,C(C(U)),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ r
                      @ m :: * -> *
                      (v :: Control.Monad.Reader.Class.MonadReader r m).
                  @ r
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fMonadReaderSupplyT_$cp1MonadReader
                     @ r
                     @ m
                     v)
                  (Control.Monad.Reader.Class.$fMonadReaderrStateT2
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v)
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <GHC.Integer.Type.Integer>_N
                            <m>_R
                            <r>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <r>_N)
                  (\ @ a ->
                   Control.Monad.Reader.Class.$fMonadReaderrStateT0_$clocal
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <r -> r>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Reader.Class.$fMonadReaderrStateT0_$creader
                     @ r
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <r -> a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadReaderSupplyT_$cp1MonadReader ::
    Control.Monad.Reader.Class.MonadReader r m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ r
                   @ m :: * -> *
                   ($dMonadReader :: Control.Monad.Reader.Class.MonadReader r m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Reader.Class.$p1MonadReader
                      @ r
                      @ m
                      $dMonadReader)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadSupplyT ::
    GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Supply.$fApplicativeSupplyT @ m v)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>=
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <b>_N)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   GHC.Base.return @ m v @ (a, GHC.Integer.Type.Integer) (eta, eta1))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadTransSupplyT ::
    Control.Monad.Trans.Class.MonadTrans Control.Monad.Supply.SupplyT
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,U><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (Control.Monad.Trans.State.Lazy.$fMonadTransStateT_$clift
                   @ GHC.Integer.Type.Integer)
                  `cast`
                ((forall (m :: <* -> *>_N) (a :: <*>_N).
                  <GHC.Base.Monad m>_R
                  ->_R <m a>_R
                  ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) ; Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                                                                                       <Control.Monad.Supply.SupplyT>_N)) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadWriterSupplyT ::
    Control.Monad.Writer.Class.MonadWriter w m =>
    Control.Monad.Writer.Class.MonadWriter
      w (Control.Monad.Supply.SupplyT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U,U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),C(U),C(U),C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ w
                      @ m :: * -> *
                      (v :: Control.Monad.Writer.Class.MonadWriter w m).
                  @ w
                  @ (Control.Monad.Supply.SupplyT m)
                  (Control.Monad.Writer.Class.$p1MonadWriter @ w @ m v)
                  (Control.Monad.Supply.$fMonadWriterSupplyT_$cp2MonadWriter
                     @ w
                     @ m
                     v)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT0_$cwriter
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, w)>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N)
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT0_$ctell
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v)
                    `cast`
                  (<w>_R ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <()>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <(a, w)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <(a,
                                                                                               w)>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ w
                     @ m
                     @ GHC.Integer.Type.Integer
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <(a, w -> w)>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <m>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  $fMonadWriterSupplyT_$cp2MonadWriter ::
    Control.Monad.Writer.Class.MonadWriter w m =>
    GHC.Base.Monad (Control.Monad.Supply.SupplyT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),C(U)),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ w
                   @ m :: * -> *
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter w m) ->
                 Control.Monad.Supply.$fMonadSupplyT
                   @ m
                   (Control.Monad.Writer.Class.$p2MonadWriter
                      @ w
                      @ m
                      $dMonadWriter)) -}
f4322eeca7624230703acaa49fba7ba1
  $tc'SupplyT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12257745926776105930##
                   18054537658603304836##
                   Control.Monad.Supply.$trModule
                   Control.Monad.Supply.$tc'SupplyT2
                   2#
                   Control.Monad.Supply.$tc'SupplyT1) -}
c5ce035e8a257a01ab34a872f689fcaa
  $tc'SupplyT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5fea4df33c13971e6a470874da67aad7
  $tc'SupplyT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$tc'SupplyT3) -}
a9192784f1fa836ac564d272bd1830b1
  $tc'SupplyT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SupplyT"#) -}
96993d9840bfd7cdd82d87a65069e0d0
  $tcSupplyT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4702626884399704145##
                   1800277657012411439##
                   Control.Monad.Supply.$trModule
                   Control.Monad.Supply.$tcSupplyT2
                   0#
                   Control.Monad.Supply.$tcSupplyT1) -}
57e5ad8c82b31ddb74a46d92fff77653
  $tcSupplyT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
079b95501f3303cd00c631ffff550921
  $tcSupplyT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$tcSupplyT3) -}
2edb8b91f2d64931c42c2cb295fc47c1
  $tcSupplyT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SupplyT"#) -}
387e119586815df272b90082a8d2048f
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Control.Monad.Supply.$trModule3
                   Control.Monad.Supply.$trModule1) -}
d7170565973b8c9ff276654648494dad
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$trModule2) -}
a3577ef0d85f707ab7b06a8e1904d079
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Control.Monad.Supply"#) -}
c3d6d2ec4389474a1c4f9e2448ef3054
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Control.Monad.Supply.$trModule4) -}
a611c0bc30a4b7325a5165bf8c4fec3a
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
0451182438eb9ab48358d09c80c32c7f
  type Supply =
    Control.Monad.Supply.SupplyT Data.Functor.Identity.Identity
    :: * -> *
a33fc23ef2131a2ed4dfdd2f28dff7f5
  type role SupplyT representational nominal
  newtype SupplyT (m :: * -> *) a
    = SupplyT {unSupplyT :: Control.Monad.Trans.State.Lazy.StateT
                              GHC.Integer.Type.Integer m a}
e20027608e2cc2276fea57134343da1e
  evalSupply ::
    GHC.Integer.Type.Integer -> Control.Monad.Supply.Supply a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><C(S(SL)),1*C1(U(1*U,A))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (n :: GHC.Integer.Type.Integer)
                   (x :: Control.Monad.Supply.SupplyT
                           Data.Functor.Identity.Identity a) ->
                 case (x `cast`
                       (Control.Monad.Supply.N:SupplyT[0] <Data.Functor.Identity.Identity>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                         <GHC.Integer.Type.Integer>_N
                                                                                                         <Data.Functor.Identity.Identity>_R
                                                                                                         <a>_N)
                         n)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(a, GHC.Integer.Type.Integer)>_R) of wild { (,) x1 ds1 ->
                 x1 }) -}
0eec7b049b5a1acfcf48e5b194c10980
  evalSupplyT ::
    GHC.Base.Functor m =>
    GHC.Integer.Type.Integer -> Control.Monad.Supply.SupplyT m a -> m a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (n :: GHC.Integer.Type.Integer) ->
                 let {
                   f :: m (a, GHC.Integer.Type.Integer) -> m a
                   = GHC.Base.fmap
                       @ m
                       $dFunctor
                       @ (a, GHC.Integer.Type.Integer)
                       @ a
                       (Data.Tuple.fst @ a @ GHC.Integer.Type.Integer)
                 } in
                 \ (x :: Control.Monad.Supply.SupplyT m a) ->
                 f (x `cast`
                    (Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                         <GHC.Integer.Type.Integer>_N
                                                                         <m>_R
                                                                         <a>_N)
                      n)) -}
276b6abea28f6d011672ab5f48473244
  runSupply ::
    GHC.Integer.Type.Integer
    -> Control.Monad.Supply.Supply a -> (a, GHC.Integer.Type.Integer)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                (Control.Monad.Supply.runSupplyT @ Data.Functor.Identity.Identity)
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Integer.Type.Integer>_R
                 ->_R <Control.Monad.Supply.SupplyT
                         Data.Functor.Identity.Identity a>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a, GHC.Integer.Type.Integer)>_R) -}
67b721393ec29d70416fc36de801fba2
  runSupplyT ::
    GHC.Integer.Type.Integer
    -> Control.Monad.Supply.SupplyT m a
    -> m (a, GHC.Integer.Type.Integer)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ m :: * -> *
                   @ a
                   (n :: GHC.Integer.Type.Integer)
                   (eta :: Control.Monad.Supply.SupplyT m a) ->
                 eta
                   `cast`
                 (Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                      <GHC.Integer.Type.Integer>_N
                                                                      <m>_R
                                                                      <a>_N)
                   n) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  unSupplyT ::
    Control.Monad.Supply.SupplyT m a
    -> Control.Monad.Trans.State.Lazy.StateT
         GHC.Integer.Type.Integer m a
  RecSel Left Control.Monad.Supply.SupplyT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Control.Monad.Supply.unSupplyT1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Control.Monad.Supply.SupplyT m a>_R
                 ->_R Control.Monad.Supply.N:SupplyT[0] <m>_N <a>_N) -}
a33fc23ef2131a2ed4dfdd2f28dff7f5
  unSupplyT1 ::
    Control.Monad.Supply.SupplyT m a
    -> Control.Monad.Supply.SupplyT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Control.Monad.Supply.SupplyT m a) ->
                 ds) -}
instance GHC.Base.Alternative [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fAlternativeSupplyT
instance GHC.Base.Applicative [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fApplicativeSupplyT
instance GHC.Base.Functor [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fFunctorSupplyT
instance Control.Monad.Error.Class.MonadError [.,
                                               Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadErrorSupplyT
instance GHC.Base.MonadPlus [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadPlusSupplyT
instance Control.Monad.Reader.Class.MonadReader [.,
                                                 Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadReaderSupplyT
instance GHC.Base.Monad [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadSupplyT
instance Control.Monad.Trans.Class.MonadTrans [Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadTransSupplyT
instance Control.Monad.Writer.Class.MonadWriter [.,
                                                 Control.Monad.Supply.SupplyT]
  = Control.Monad.Supply.$fMonadWriterSupplyT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

