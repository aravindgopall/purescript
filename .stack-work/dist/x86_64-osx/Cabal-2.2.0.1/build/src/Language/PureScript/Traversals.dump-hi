
==================== FINAL INTERFACE ====================
2019-01-24 14:13:32.631485 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Traversals 8043
  interface hash: 65aa30fe9798f2d58e3d6c49fd69b72a
  ABI hash: e97764d7972cc6ba421a6be0a3ce6bda
  export-list hash: cbb821b2ee7c6d00cdf62285e1dbe432
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2ae478d21823b7c739b1b08c46262eb0
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Traversals.defS
  Language.PureScript.Traversals.eitherM
  Language.PureScript.Traversals.fstM
  Language.PureScript.Traversals.maybeM
  Language.PureScript.Traversals.pairM
  Language.PureScript.Traversals.sndM
  Language.PureScript.Traversals.thirdM
module dependencies:
package dependencies: base-4.11.1.0 base-compat-0.10.4*
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:GHC.Exts base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
d525a86087dbdd6b9bb0a66cc0872305
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Traversals.$trModule3
                   Language.PureScript.Traversals.$trModule1) -}
46f86d0c353e2fae9134f3675c5788b4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Traversals.$trModule2) -}
ceae7859cbe98e70146d1132e2387c97
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.PureScript.Traversals"#) -}
b33c69830991b41536e91075d984f318
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Traversals.$trModule4) -}
6ccff275354a6b236ff10260a48b1219
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
d863fb3389d8c05a6117bb7cdd4689c0
  $wpairM ::
    GHC.Base.Applicative f =>
    (a -> f c) -> (b -> f d) -> a -> b -> f (c, d)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ c
                   @ b
                   @ d
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f c)
                   (w2 :: b -> f d)
                   (ww :: a)
                   (ww1 :: b) ->
                 GHC.Base.<*>
                   @ f
                   w
                   @ d
                   @ (c, d)
                   (GHC.Base.fmap
                      @ f
                      (GHC.Base.$p1Applicative @ f w)
                      @ c
                      @ (d -> (c, d))
                      (GHC.Tuple.(,) @ c @ d)
                      (w1 ww))
                   (w2 ww1)) -}
d63aa97f74d8b43282d6090aabe13394
  defS :: GHC.Base.Monad m => st -> val -> m (st, val)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ st
                   @ val
                   ($dMonad :: GHC.Base.Monad m)
                   (s :: st)
                   (val1 :: val) ->
                 GHC.Base.return @ m $dMonad @ (st, val) (s, val1)) -}
2af36357e3acd760921cb6efef427400
  eitherM ::
    GHC.Base.Applicative f =>
    (a -> f c)
    -> (b -> f d)
    -> Data.Either.Either a b
    -> f (Data.Either.Either c d)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ c
                   @ b
                   @ d
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f c)
                   (eta1 :: b -> f d)
                   (eta2 :: Data.Either.Either a b) ->
                 case eta2 of wild {
                   Data.Either.Left a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ c
                        @ (Data.Either.Either c d)
                        (Data.Either.Left @ c @ d)
                        (eta a1)
                   Data.Either.Right b1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ d
                        @ (Data.Either.Either c d)
                        (Data.Either.Right @ c @ d)
                        (eta1 b1) }) -}
939a2920ee4a9f251b6e0454b68c338c
  fstM :: GHC.Base.Functor f => (a -> f c) -> (a, b) -> f (c, b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ c
                   @ b
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: a -> f c)
                   (ds :: (a, b)) ->
                 case ds of wild { (,) a1 b1 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ c
                   @ (c, b)
                   (\ (y :: c) -> (y, b1))
                   (f1 a1) }) -}
f454ac0e35a3433216159fb683e8d6ec
  maybeM ::
    GHC.Base.Applicative f =>
    (a -> f b) -> GHC.Base.Maybe a -> f (GHC.Base.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: GHC.Base.Maybe a) ->
                 case eta1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.pure
                        @ f
                        $dApplicative
                        @ (GHC.Base.Maybe b)
                        (GHC.Base.Nothing @ b)
                   GHC.Base.Just a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ b
                        @ (GHC.Base.Maybe b)
                        (GHC.Base.Just @ b)
                        (eta a1) }) -}
f8a24624fde2d3fa102dce305c36545d
  pairM ::
    GHC.Base.Applicative f =>
    (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ c
                   @ b
                   @ d
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f c)
                   (w2 :: b -> f d)
                   (w3 :: (a, b)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 Language.PureScript.Traversals.$wpairM
                   @ f
                   @ a
                   @ c
                   @ b
                   @ d
                   w
                   w1
                   w2
                   ww1
                   ww2 }) -}
c93ef73e127a3a54c4cd1e5e2194b237
  sndM :: GHC.Base.Functor f => (b -> f c) -> (a, b) -> f (a, c)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ b
                   @ c
                   @ a
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: b -> f c)
                   (ds :: (a, b)) ->
                 case ds of wild { (,) a1 b1 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ c
                   @ (a, c)
                   (GHC.Tuple.(,) @ a @ c a1)
                   (f1 b1) }) -}
ff8e8fc8ea147bba13179156ecb5143a
  thirdM ::
    GHC.Base.Functor f => (c -> f d) -> (a, b, c) -> f (a, b, d)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ c
                   @ d
                   @ a
                   @ b
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: c -> f d)
                   (ds :: (a, b, c)) ->
                 case ds of wild { (,,) a1 b1 c1 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ d
                   @ (a, b, d)
                   (GHC.Tuple.(,,) @ a @ b @ d a1 b1)
                   (f1 c1) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

