
==================== FINAL INTERFACE ====================
2018-11-30 20:47:24.012457 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeChecker.Monad 8043
  interface hash: 2072fdb6ac4761e2bb89f7bfe45cf761
  ABI hash: 36a86b5cfef989dae17621bbace19db6
  export-list hash: 9d9d275b045efb93172c1bb44957da47
  orphan hash: d38d14f050d03ce8b6704c1517a0570b
  flag hash: 409eb3effb99b666bef22fcf42369757
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.Monad.bindLocalTypeVariables
  Language.PureScript.TypeChecker.Monad.bindLocalVariables
  Language.PureScript.TypeChecker.Monad.bindNames
  Language.PureScript.TypeChecker.Monad.bindTypes
  Language.PureScript.TypeChecker.Monad.captureSubstitution
  Language.PureScript.TypeChecker.Monad.capturingSubstitution
  Language.PureScript.TypeChecker.Monad.checkVisibility
  Language.PureScript.TypeChecker.Monad.emptyCheckState
  Language.PureScript.TypeChecker.Monad.emptySubstitution
  Language.PureScript.TypeChecker.Monad.getEnv
  Language.PureScript.TypeChecker.Monad.getHints
  Language.PureScript.TypeChecker.Monad.getLocalContext
  Language.PureScript.TypeChecker.Monad.getTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.getVisibility
  Language.PureScript.TypeChecker.Monad.guardWith
  Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionariesForClass
  Language.PureScript.TypeChecker.Monad.lookupTypeVariable
  Language.PureScript.TypeChecker.Monad.lookupVariable
  Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible
  Language.PureScript.TypeChecker.Monad.modifyEnv
  Language.PureScript.TypeChecker.Monad.preservingNames
  Language.PureScript.TypeChecker.Monad.putEnv
  Language.PureScript.TypeChecker.Monad.rethrowWithPositionTC
  Language.PureScript.TypeChecker.Monad.runCheck
  Language.PureScript.TypeChecker.Monad.runCheck'
  Language.PureScript.TypeChecker.Monad.warnAndRethrowWithPositionTC
  Language.PureScript.TypeChecker.Monad.withBindingGroupVisible
  Language.PureScript.TypeChecker.Monad.withErrorMessageHint
  Language.PureScript.TypeChecker.Monad.withFreshSubstitution
  Language.PureScript.TypeChecker.Monad.withScopedTypeVars
  Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.withoutWarnings
  Language.PureScript.TypeChecker.Monad.CheckState{Language.PureScript.TypeChecker.Monad.CheckState checkCurrentModule checkEnv checkHints checkNextKind checkNextSkolem checkNextSkolemScope checkNextType checkSubstitution}
  Language.PureScript.TypeChecker.Monad.Substitution{Language.PureScript.TypeChecker.Monad.Substitution substKind substType}
  Language.PureScript.TypeChecker.Monad.Unknown
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 boxes-0.1.5 bytestring-0.10.8.2 colour-2.3.4
                      containers-0.5.11.0 deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 mtl-2.2.2 parsec-3.1.13.0
                      pattern-arrows-0.0.2 pretty-1.1.3.6 primitive-0.6.3.0
                      protolude-0.2.2 random-1.1 scientific-0.3.6.2 sourcemap-0.1.6
                      split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Declarations
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Operators
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.SourcePos
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Environment
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Kinds
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Label
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Names
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Type.Equality 9bb29c7615a8eec000fd03d114737416
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  Language.PureScript.AST.Declarations 568e046fbf27b243bfc96f09017d4782
  Context c827e63ac539a5076a60fc8c74223610
  CycleInDeclaration 67af7f72c42808d9f19fc5097d3ab5da
  ErrorMessageHint b31d94d0c7b90700d40f9ba6ec420e41
  NameIsUndefined 9d817d271b064b6e392acd388ca5c97f
  ShadowedTypeVar d4a3c585e98afd60b41ec6774c6409e8
  UndefinedTypeVariable 618567e3392059402b3fa9282160ade5
import  -/  Language.PureScript.AST.SourcePos b3f67f807f2dce79528bbb15bd9c7104
  SourceSpan 73c071552214b3f18e94970349d3affc
import  -/  Language.PureScript.Environment 31667499b7017b19998bb405474fbe93
  exports: 56b1ef0ac6132b4c113ce26a807dcfb6
  Defined d489ca36b83d6a80bdf403858bcc7d71
  Environment c291d940fae22a3f1400d8c90f26bdd4
  LocalTypeVariable 7c862a19590b3d920bf3c8dd3a236c66
  NameKind 90ac7b5e1c331fe4ca4a3a5c9b2afcbd
  NameVisibility 610613df6c74f57795f9d575591a7472
  Private 99871aa8de3459034b1625c22dfbd4f2
  ScopedTypeVar c3daed8f7583b0d789d2273e9a4a226a
  TypeKind 0a0df18a3a5bbdd9f1dda59baf0fb992
  Undefined 5cfb1d3c43eabcda9f9dbb8b4c7a389c
  initEnvironment 7e43632077c77373180c2c3d6aac18ae
  names c291d940fae22a3f1400d8c90f26bdd4
  typeClassDictionaries c291d940fae22a3f1400d8c90f26bdd4
  types c291d940fae22a3f1400d8c90f26bdd4
import  -/  Language.PureScript.Errors 15d6eb6b2d4d480750061a0585d4e64c
  exports: 142ea650dec62642d1cff09ef1eee74e
  MultipleErrors ad1de73a1d5a6b0ccd9657dedebc94f3
  addHint c2d92e868230119a30631ae026505b5b
  errorMessage 56e7aa221570d7d0bd9b4d606b8de7f2
  positionedError d8ca57e35818a7e93c5200eeb190e167
  rethrow f843b34a93fe990a8e71af5f4eb4be9f
  warnWithPosition f626dbbef53d3f006a3630d5b23307ee
import  -/  Language.PureScript.Kinds bf1fc2fd18b06658330fcf93fe50e737
  exports: 2c2448e43e622d2466a59b9cd8f4db91
  Kind 3e1e213eb647453235d33b0d1b36ec59
import  -/  Language.PureScript.Names b3bf151840f3e8f2eb61eff186432886
  exports: f7f3503d20957194bda83c16bb5f1288
  ClassName e69348bcf8c43a2174540a1d5983bfaa
  Ident 0ccd7f2221de64569e50634367691253
  Ident ab98a56ffa88760dad1380079e8ee35a
  ModuleName 5a70062bbdf29e6dc659ad8bf5326b50
  ProperName 9eb330c84db102abf2d0f2652fe4a144
  ProperName 29f101e190cc99df85623423972e606f
  Qualified d600a7f01c8203cf5504999de99c923c
  Qualified 5a70062bbdf29e6dc659ad8bf5326b50
  TypeName da42c92f73f4f363c63ecaf77b6335b9
  disqualify 3e7b8117c7613f1d74fadc5d62b59f54
import  -/  Language.PureScript.TypeClassDictionaries 85b2520728908ad345f56b1c2cbe3fca
  exports: cc9c93841004965313696be0c74a01eb
  NamedDict 1c7eb5af0357b976dbe077e65975eac8
  TypeClassDictionaryInScope c1f0a82f8146987fb0ec5a84ba847e8e
  tcdClassName 6fae3e2d3c76b2d8044da9ff9cec0bdb
  tcdValue 6fae3e2d3c76b2d8044da9ff9cec0bdb
import  -/  Language.PureScript.Types 74562e642f5297557b3a23aac7819ad1
  exports: ae97bc75fcebc59f59c970736847a827
  Type 93223f8afa90d0facc05a03f863dc72d
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
e21fd3ef7339ad7b7051951defc2e545
  $s$fEqMaybe ::
    GHC.Classes.Eq
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                  (\ (ds :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (ds1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> GHC.Classes.$fEq[]_$c==
                               @ (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.Namespace)
                               (Language.PureScript.Names.$fEqProperName
                                  @ 'Language.PureScript.Names.Namespace)
                               a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  Language.PureScript.TypeChecker.Monad.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
129a81622b2373e33223771244b693f2
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ (Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.Namespace)
                                  (Language.PureScript.Names.$fEqProperName
                                     @ 'Language.PureScript.Names.Namespace)
                                  a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                  b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
baafcee01b3487872acd0ccf8e584818
  $s$fEqQualified ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName))
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fEqProperName
                        @ 'Language.PureScript.Names.ClassName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/= -}
49ad3ecd3c5f3018b56609a6980584a6
  $s$fEqQualified1 ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName))
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fEqProperName
                        @ 'Language.PureScript.Names.TypeName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=1 -}
cc9bba85d025ff86aa593700bc60552c
  $s$fEqQualified2 ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       Language.PureScript.Names.Ident)
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fEqIdent)
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=2 -}
d34adb5e384418a2495faa42185ccbc4
  $s$fEqQualified_$s$fEqQualified_$c/= ::
    Language.PureScript.Names.Qualified
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName)
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U,U,U))><S(SL),1*U(1*U,1*U(U,U,U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                   (y :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName)) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ (Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.ClassName)
                        (Language.PureScript.Names.$fEqProperName
                           @ 'Language.PureScript.Names.ClassName)
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b71359eb8dcf5961be65c9a5fcc7857e
  $s$fEqQualified_$s$fEqQualified_$c/=1 ::
    Language.PureScript.Names.Qualified
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName)
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U,U,U))><S(SL),1*U(1*U,1*U(U,U,U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName))
                   (y :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName)) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ (Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.TypeName)
                        (Language.PureScript.Names.$fEqProperName
                           @ 'Language.PureScript.Names.TypeName)
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4a19386a929d0c5fa4cddf24f1ddd8d4
  $s$fEqQualified_$s$fEqQualified_$c/=2 ::
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                   (y :: Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ Language.PureScript.Names.Ident
                        Language.PureScript.Names.$fEqIdent
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8734eb50ce9e5441f0c77895b51a59a5
  $s$fOrdMaybe ::
    GHC.Classes.Ord
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                  Language.PureScript.TypeChecker.Monad.$s$fEqMaybe
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.EQ
                          GHC.Base.Just ipv -> GHC.Types.LT }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.GT
                          GHC.Base.Just b1
                          -> GHC.Classes.$fOrd[]_$ccompare
                               @ (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.Namespace)
                               (Language.PureScript.Names.$fOrdProperName
                                  @ 'Language.PureScript.Names.Namespace)
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> Language.PureScript.Names.$fOrdModuleName6
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case b of wild {
                     GHC.Base.Nothing
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a2
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case b of wild {
                     GHC.Base.Nothing
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> Language.PureScript.Names.$fOrdModuleName6
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } })
                  (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case y of wild {
                     GHC.Base.Nothing -> x
                     GHC.Base.Just a1
                     -> case x of wild1 {
                          GHC.Base.Nothing -> wild
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> wild GHC.Types.LT -> wild1 } } })
                  (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case y of wild {
                     GHC.Base.Nothing
                     -> case x of wild1 { DEFAULT ->
                        GHC.Base.Nothing @ Language.PureScript.Names.ModuleName }
                     GHC.Base.Just a1
                     -> case x of wild1 {
                          GHC.Base.Nothing
                          -> GHC.Base.Nothing @ Language.PureScript.Names.ModuleName
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> wild1 GHC.Types.LT -> wild } } }) -}
b75ead126f64b4f0087fe23e08d7b7c3
  $s$fOrdMaybe_$c< ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> Language.PureScript.Names.$fOrdModuleName6
                             a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                             b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } }) -}
3498c68287afeb7535be7a8eda8a925a
  $s$fOrdMaybe_$ccompare ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.EQ
                        GHC.Base.Just ipv -> GHC.Types.LT }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.GT
                        GHC.Base.Just b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.Namespace)
                             (Language.PureScript.Names.$fOrdProperName
                                @ 'Language.PureScript.Names.Namespace)
                             a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                             b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } }) -}
24071e6cbd83ded91bacd51a4205f975
  $s$fOrdMaybe_$cmax ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case y of wild {
                   GHC.Base.Nothing -> x
                   GHC.Base.Just a1
                   -> case x of wild1 {
                        GHC.Base.Nothing -> wild
                        GHC.Base.Just b1
                        -> case GHC.Classes.$fOrd[]_$ccompare
                                  @ (Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.Namespace)
                                  (Language.PureScript.Names.$fOrdProperName
                                     @ 'Language.PureScript.Names.Namespace)
                                  a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                  b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                             DEFAULT -> wild GHC.Types.LT -> wild1 } } }) -}
41db271ea08e1c6af4992f1fab18166a
  $s$fOrdQualified ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName))
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName))
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName)
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
2c7e3db34edc3f249f3bb42f9775a2f0
  $s$fOrdQualified1 ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified1
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName))
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName))
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName)
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
6efa0dad2423acd9745bf67e6bda330e
  $s$fOrdQualified2 ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       Language.PureScript.Names.Ident)
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified2
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent)
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident)
                     (y :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident)
                     (y :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
58a5c6f27b1abe4de335c4f29e3c6e4e
  $sfromList ::
    [(Language.PureScript.Names.Qualified
        Language.PureScript.Names.Ident,
      a)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
  {- Arity: 1, Strictness: <S,1*U> -}
32bf3d2450bfa7181380821402dc5639
  $sfromList1 ::
    [(Language.PureScript.Names.Qualified
        (Language.PureScript.Names.ProperName
           'Language.PureScript.Names.TypeName),
      a)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
  {- Arity: 1, Strictness: <S,1*U> -}
365ae684870e11a0afb4a339a724930a
  $sinsertWithKey_$sgo13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident))))
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)))
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Classes.Ord
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) =>
       Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 4,
     Strictness: <S,1*U><L,U><S,1*U><L,U(A,C(C1(U)),A,A,A,A,A,A)> -}
6ab52f4d583f2da7e7d81c1f03cd745a
  $slookup7 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ds1 :: Data.Map.Internal.Map
                             (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a) ->
                 case ds of ds2 { DEFAULT ->
                 case ds1 of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ds2 of wild1 {
                        GHC.Base.Nothing
                        -> case ipv1 of wild2 {
                             GHC.Base.Nothing -> GHC.Base.Just @ a ipv2
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go1
                                  @ a
                                  ipv3 }
                        GHC.Base.Just a2
                        -> case ipv1 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                  @ a
                                  ipv4
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                       @ a
                                       ipv3
                                       a2
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                       @ a
                                       ipv4
                                       a2 } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a } }) -}
d65803df639188d4b4dbb050560dd1c5
  $slookup_$s$wpoly_go1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Language.PureScript.Names.Ident -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
1c8d5b7818476f195ca1265c7941f602
  $slookup_$s$wpoly_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Language.PureScript.Names.Ident
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
8d53f2d6ca83ad5c52d1d6de6962f231
  $slookup_$s$wpoly_go2 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind,
       Language.PureScript.Environment.TypeKind)
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe
         (Language.PureScript.Kinds.Kind,
          Language.PureScript.Environment.TypeKind)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
1f2c7f69ae755bd6ceca5c5a7aba3108
  $slookup_$s$wpoly_go3 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind,
       Language.PureScript.Environment.TypeKind)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName :: *)) =>
       Language.PureScript.Names.ModuleName
       -> GHC.Base.Maybe
            (Language.PureScript.Kinds.Kind,
             Language.PureScript.Environment.TypeKind)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U> -}
0522abd5b0eea4a9149affb1ae13861e
  $slookup_$s$wpoly_go5 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
9e32fe7c479930252f425bc48f415802
  $slookup_$s$wpoly_go6 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U,U)> -}
b69e835435b9b0449c27d8203c446f16
  $slookup_$s$wpoly_go7 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName :: *)) =>
       GHC.Base.Maybe a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U> -}
2e79a961c1930a6a8e06e5f083d88aad
  $slookup_$spoly_go1 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> GHC.Base.Maybe a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
dd83fb1b7cd9fec99ec4fe783d79c27f
  $slookup_$spoly_go13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Language.PureScript.Names.ModuleName -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
6887dff8d3c1db43a82a15a01d4ac879
  $smember_$s$wpoly_go1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind,
       Language.PureScript.Environment.TypeKind)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName :: *)) =>
       Language.PureScript.Names.ModuleName -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U> -}
82660704df025c9f65f5385733e6c195
  $smember_$s$wpoly_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind,
       Language.PureScript.Environment.TypeKind)
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
3573dde41b0a4e2225ad6d616c0ffcff
  $sunion ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
ec013e9def75a9bdb18b78f4de5a0c95
  $sunion1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
0b77e2a74e6d9b08e64cdd1f18804ef8
  $sunionWith ::
    (a -> a -> a)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
2d1b4d1424bf263d0e2712950203a558
  $sunionWith1 ::
    (a -> a -> a)
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
1e86b0d76b322983d33e60c30a7a4fa9
  $tc'CheckState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2047015802681339360##
                   16272900191377807259##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState2
                   0#
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState1) -}
a1f065fe6d26a7f992f76cf5d8e9d354
  $tc'CheckState1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
34cdf153f1140e0c6cba6be9244f5c67
  $tc'CheckState2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState3) -}
e9a4f89a1bf95d4fb42749b8ae5dec22
  $tc'CheckState3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CheckState"#) -}
e0aa185b76b2a1fbd057cb32cd91f6f7
  $tc'Substitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8941860341908492490##
                   2457328591282581562##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution2
                   0#
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution1) -}
aed0700bec945e2ceb8aa0fdfc432f53
  $tc'Substitution1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7442dbc24b98be30e516c4517caf5061
  $tc'Substitution2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution3) -}
2d31a91267ad31a96e0a34af7cfb2e53
  $tc'Substitution3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Substitution"#) -}
7afc78ac0a0f4f87434ce9995693ab04
  $tcCheckState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10454089454384318736##
                   3319910652030743575##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tcCheckState1
                   0#
                   GHC.Types.krep$*) -}
b9df7e96ee01a39a41e371f372dcdd46
  $tcCheckState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tcCheckState2) -}
e926ed45097e5021bb8ce87bee912a11
  $tcCheckState2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CheckState"#) -}
a54a8c38a32876440ed90dcdb4b79db9
  $tcSubstitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7717565159791385168##
                   992375852297764107##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tcSubstitution1
                   0#
                   GHC.Types.krep$*) -}
8869c8f8e04d25eb64a3a24d22263d2d
  $tcSubstitution1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tcSubstitution2) -}
e780384ba0afa61290586ef0568456d9
  $tcSubstitution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Substitution"#) -}
545447701bc9de8a059458fd94a1b6de
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.Monad.$trModule3
                   Language.PureScript.TypeChecker.Monad.$trModule1) -}
4c2215968edd0fd247baea95dec18b26
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$trModule2) -}
fc8ca067ea29cd172c8acaa63ded54db
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.Monad"#) -}
5555a1e1aa21714981b69783a4115536
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$trModule4) -}
d9ed3353344a0f6972bb8be912b56bee
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
6d12e5e5fd6508248820c4a8c0768fdb
  $wcheckVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Ident -> m ()
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ e
                   @ m :: * -> *
                   (w :: (e :: *)
                         Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   (w1 :: Control.Monad.State.Class.MonadState
                            Language.PureScript.TypeChecker.Monad.CheckState m)
                   (w2 :: Control.Monad.Error.Class.MonadError e m)
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.Ident) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        w `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       w1
                 } in
                 let {
                   lvl29 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   lvl30 :: m ()
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       w2 `cast` (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ ()
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.CycleInDeclaration ww1))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.NameVisibility
                   @ ()
                   (Language.PureScript.TypeChecker.Monad.getVisibility
                      @ Language.PureScript.Errors.MultipleErrors
                      @ m
                      (GHC.Types.Eq#
                         @ *
                         @ *
                         @ Language.PureScript.Errors.MultipleErrors
                         @ Language.PureScript.Errors.MultipleErrors
                         @~ <Language.PureScript.Errors.MultipleErrors>_N)
                        `cast`
                      (Sym (Data.Type.Equality.N:~[0]
                                <*>_N) <Language.PureScript.Errors.MultipleErrors>_N <Language.PureScript.Errors.MultipleErrors>_N)
                      w1
                      w2 `cast` (Control.Monad.Error.Class.MonadError co <m>_N)_R
                      (Language.PureScript.Names.Qualified
                         @ Language.PureScript.Names.Ident
                         ww
                         ww1))
                   (\ (vis :: Language.PureScript.Environment.NameVisibility) ->
                    case vis of wild {
                      Language.PureScript.Environment.Undefined -> lvl30
                      Language.PureScript.Environment.Defined -> lvl29 }) }) -}
31ec5302ec727883821b2d700ba10b8d
  $wpoly_go13 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Ident
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.Ident)
                   (w :: Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           a) ->
                 case w of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ipv1 of ww3 { Language.PureScript.Names.Qualified ww4 ww5 ->
                      case ww of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> case Language.PureScript.Names.$fOrdIdent_$ccompare
                                       ww1
                                       ww5 of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                       @ a
                                       ipv3
                                       ww1
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                       @ a
                                       ipv4
                                       ww1 }
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                  @ a
                                  ipv3
                                  ww1 }
                        GHC.Base.Just a2
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                  @ a
                                  ipv4
                                  ww1
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                       @ a
                                       ipv3
                                       ww1
                                       a2
                                  GHC.Types.EQ
                                  -> case Language.PureScript.Names.$fOrdIdent_$ccompare
                                            ww1
                                            ww5 of wild4 {
                                       GHC.Types.LT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                            @ a
                                            ipv3
                                            ww1
                                            a2
                                       GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                       GHC.Types.GT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                            @ a
                                            ipv4
                                            ww1
                                            a2 }
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                       @ a
                                       ipv4
                                       ww1
                                       a2 } } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a }) -}
56656b7ad7da723e785b1f61c507df5a
  $wpoly_go2 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U(U,U,U)><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.ClassName)
                   (w :: Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                           a) ->
                 case w of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ipv1 of ww3 { Language.PureScript.Names.Qualified ww4 ww5 ->
                      case ww of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> case ww1
                                       `cast`
                                     (Language.PureScript.Names.N:ProperName[0]
                                          <'Language.PureScript.Names.ClassName>_P) of ww2 { Data.Text.Internal.Text ww6 ww7 ww8 ->
                                case ww5
                                       `cast`
                                     (Language.PureScript.Names.N:ProperName[0]
                                          <'Language.PureScript.Names.ClassName>_P) of ww9 { Data.Text.Internal.Text ww10 ww11 ww12 ->
                                case Data.Text.$w$ccompare ww6 ww7 ww8 ww10 ww11 ww12 of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
                                       @ a
                                       ipv3
                                       ww6
                                       ww7
                                       ww8
                                       @~ (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.ClassName>_P))
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
                                       @ a
                                       ipv4
                                       ww6
                                       ww7
                                       ww8
                                       @~ (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.ClassName>_P)) } } }
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go6
                                  @ a
                                  ipv3
                                  ww1 }
                        GHC.Base.Just a2
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                  @ a
                                  ipv4
                                  ww1
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                       @ a
                                       ipv3
                                       ww1
                                       a2
                                  GHC.Types.EQ
                                  -> case ww1
                                            `cast`
                                          (Language.PureScript.Names.N:ProperName[0]
                                               <'Language.PureScript.Names.ClassName>_P) of ww2 { Data.Text.Internal.Text ww6 ww7 ww8 ->
                                     case ww5
                                            `cast`
                                          (Language.PureScript.Names.N:ProperName[0]
                                               <'Language.PureScript.Names.ClassName>_P) of ww9 { Data.Text.Internal.Text ww10 ww11 ww12 ->
                                     case Data.Text.$w$ccompare
                                            ww6
                                            ww7
                                            ww8
                                            ww10
                                            ww11
                                            ww12 of wild4 {
                                       GHC.Types.LT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                            @ a
                                            ipv3
                                            ww2
                                              `cast`
                                            (Sym (Language.PureScript.Names.N:ProperName[0]
                                                      <'Language.PureScript.Names.ClassName>_P))
                                            a2
                                       GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                       GHC.Types.GT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                            @ a
                                            ipv4
                                            ww2
                                              `cast`
                                            (Sym (Language.PureScript.Names.N:ProperName[0]
                                                      <'Language.PureScript.Names.ClassName>_P))
                                            a2 } } }
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                       @ a
                                       ipv4
                                       ww1
                                       a2 } } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a }) -}
5c23016b2e80baec4bdda0c92644cfa1
  data CheckState
    = CheckState {checkEnv :: Language.PureScript.Environment.Environment,
                  checkNextType :: GHC.Types.Int,
                  checkNextKind :: GHC.Types.Int,
                  checkNextSkolem :: GHC.Types.Int,
                  checkNextSkolemScope :: GHC.Types.Int,
                  checkCurrentModule :: GHC.Base.Maybe
                                          Language.PureScript.Names.ModuleName,
                  checkSubstitution :: Language.PureScript.TypeChecker.Monad.Substitution,
                  checkHints :: [Language.PureScript.AST.Declarations.ErrorMessageHint]}
f41a5a409aa69b88b3ab5e8061db655f
  data Substitution
    = Substitution {substType :: Data.Map.Internal.Map
                                   GHC.Types.Int Language.PureScript.Types.Type,
                    substKind :: Data.Map.Internal.Map
                                   GHC.Types.Int Language.PureScript.Kinds.Kind}
bd6fa4de6b1e42ac9b0ded766764fcd1
  type Unknown = GHC.Types.Int
2454135d9e4f2ffeeed6c33daff8225e
  bindLocalTypeVariables ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Names.ModuleName
    -> [(Language.PureScript.Names.ProperName
           'Language.PureScript.Names.TypeName,
         Language.PureScript.Kinds.Kind)]
    -> m a
    -> m a
  {- Arity: 3,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U><L,1*U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (moduleName :: Language.PureScript.Names.ModuleName)
                   (bindings :: [(Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.TypeName,
                                  Language.PureScript.Kinds.Kind)]) ->
                 Language.PureScript.TypeChecker.Monad.bindTypes
                   @ m
                   @ a
                   $dMonadState
                   (let {
                      lvl29 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName
                      = GHC.Base.Just @ Language.PureScript.Names.ModuleName moduleName
                    } in
                    Language.PureScript.TypeChecker.Monad.$sfromList1
                      @ (Language.PureScript.Kinds.Kind,
                         Language.PureScript.Environment.TypeKind)
                      (GHC.Base.map
                         @ (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName,
                            Language.PureScript.Kinds.Kind)
                         @ (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName),
                            (Language.PureScript.Kinds.Kind,
                             Language.PureScript.Environment.TypeKind))
                         (\ (ds :: (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.TypeName,
                                    Language.PureScript.Kinds.Kind)) ->
                          case ds of wild { (,) pn kind ->
                          (Language.PureScript.Names.Qualified
                             @ (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.TypeName)
                             lvl29
                             pn,
                           (kind, Language.PureScript.Environment.LocalTypeVariable)) })
                         bindings))) -}
24393a29c2ae2897cd9b6ec8df44ac4d
  bindLocalVariables ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    [(Language.PureScript.Names.Ident, Language.PureScript.Types.Type,
      Language.PureScript.Environment.NameVisibility)]
    -> m a -> m a
  {- Arity: 2,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (bindings :: [(Language.PureScript.Names.Ident,
                                  Language.PureScript.Types.Type,
                                  Language.PureScript.Environment.NameVisibility)]) ->
                 Language.PureScript.TypeChecker.Monad.bindNames
                   @ m
                   @ a
                   $dMonadState
                   (Language.PureScript.TypeChecker.Monad.$sfromList
                      @ (Language.PureScript.Types.Type,
                         Language.PureScript.Environment.NameKind,
                         Language.PureScript.Environment.NameVisibility)
                      (GHC.Base.build
                         @ (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident,
                            (Language.PureScript.Types.Type,
                             Language.PureScript.Environment.NameKind,
                             Language.PureScript.Environment.NameVisibility))
                         (\ @ b1
                            (c :: (Language.PureScript.Names.Qualified
                                     Language.PureScript.Names.Ident,
                                   (Language.PureScript.Types.Type,
                                    Language.PureScript.Environment.NameKind,
                                    Language.PureScript.Environment.NameVisibility))
                                  -> b1 -> b1)[OneShot]
                            (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ (Language.PureScript.Names.Ident, Language.PureScript.Types.Type,
                               Language.PureScript.Environment.NameVisibility)
                            @ b1
                            (GHC.Base.mapFB
                               @ (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident,
                                  (Language.PureScript.Types.Type,
                                   Language.PureScript.Environment.NameKind,
                                   Language.PureScript.Environment.NameVisibility))
                               @ b1
                               @ (Language.PureScript.Names.Ident, Language.PureScript.Types.Type,
                                  Language.PureScript.Environment.NameVisibility)
                               c
                               Language.PureScript.TypeChecker.Monad.bindLocalVariables1)
                            n
                            bindings)))) -}
74734e8e7a98a51364f3359daab7fc16
  bindLocalVariables1 ::
    (Language.PureScript.Names.Ident, Language.PureScript.Types.Type,
     Language.PureScript.Environment.NameVisibility)
    -> (Language.PureScript.Names.Qualified
          Language.PureScript.Names.Ident,
        (Language.PureScript.Types.Type,
         Language.PureScript.Environment.NameKind,
         Language.PureScript.Environment.NameVisibility))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.PureScript.Names.Ident,
                           Language.PureScript.Types.Type,
                           Language.PureScript.Environment.NameVisibility)) ->
                 case ds of wild { (,,) name ty visibility ->
                 (Language.PureScript.Names.Qualified
                    @ Language.PureScript.Names.Ident
                    (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                    name,
                  (ty, Language.PureScript.Environment.Private, visibility)) }) -}
611092944007c226321901b0330bf26f
  bindNames ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      (Language.PureScript.Types.Type,
       Language.PureScript.Environment.NameKind,
       Language.PureScript.Environment.NameVisibility)
    -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Data.Map.Internal.Map
                             (Language.PureScript.Names.Qualified
                                Language.PureScript.Names.Ident)
                             (Language.PureScript.Types.Type,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility))
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              (Language.PureScript.TypeChecker.Monad.$sunion1
                                 @ (Language.PureScript.Types.Type,
                                    Language.PureScript.Environment.NameKind,
                                    Language.PureScript.Environment.NameVisibility)
                                 eta
                                 ds8)
                              ds9
                              ds10
                              ds11
                              ds12
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           Language.PureScript.Names.Ident)
                                        (Language.PureScript.Types.Type,
                                         Language.PureScript.Environment.NameKind,
                                         Language.PureScript.Environment.NameVisibility)
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds8 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    lvl31
                                    ds9
                                    ds10
                                    ds11
                                    ds12
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
71c50ede88d0fe5cc1f4708c73303584
  bindTypes ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind,
       Language.PureScript.Environment.TypeKind)
    -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Data.Map.Internal.Map
                             (Language.PureScript.Names.Qualified
                                (Language.PureScript.Names.ProperName
                                   'Language.PureScript.Names.TypeName))
                             (Language.PureScript.Kinds.Kind,
                              Language.PureScript.Environment.TypeKind))
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              ds8
                              (Language.PureScript.TypeChecker.Monad.$sunion
                                 @ (Language.PureScript.Kinds.Kind,
                                    Language.PureScript.Environment.TypeKind)
                                 eta
                                 ds9)
                              ds10
                              ds11
                              ds12
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           (Language.PureScript.Names.ProperName
                                              'Language.PureScript.Names.TypeName))
                                        (Language.PureScript.Kinds.Kind,
                                         Language.PureScript.Environment.TypeKind)
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds9 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    ds8
                                    lvl31
                                    ds10
                                    ds11
                                    ds12
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
b16d04cc2b65297001b2199383416e20
  captureSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m (a, Language.PureScript.TypeChecker.Monad.Substitution)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(A,C(C1(U)),A,C(U),A),U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 Language.PureScript.TypeChecker.Monad.capturingSubstitution
                   @ m
                   @ a
                   @ (a, Language.PureScript.TypeChecker.Monad.Substitution)
                   $dMonadState
                   (GHC.Tuple.(,)
                      @ a
                      @ Language.PureScript.TypeChecker.Monad.Substitution)) -}
bf445387d23817a01093aed8411e11ca
  capturingSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    (a -> Language.PureScript.TypeChecker.Monad.Substitution -> b)
    -> m a -> m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),A,C(U),A),1*U,A,A)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ b
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: a
                           -> Language.PureScript.TypeChecker.Monad.Substitution -> b)
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m Language.PureScript.TypeChecker.Monad.Substitution
                   = GHC.Base.>>=
                       @ m
                       $dMonad
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ Language.PureScript.TypeChecker.Monad.Substitution
                       (Control.Monad.State.Class.get
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState)
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        GHC.Base.return
                          @ m
                          $dMonad
                          @ Language.PureScript.TypeChecker.Monad.Substitution
                          (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           ds6 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ a
                   @ b
                   eta1
                   (\ (a1 :: a) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.Substitution
                      @ b
                      lvl29
                      (\ (subst :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                       GHC.Base.return @ m $dMonad @ b (eta a1 subst)))) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkCurrentModule ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),1*U(A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds6 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkEnv ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Environment.Environment
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLL),1*U(1*U(U,U,U,U,U,U,U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds1 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkHints ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> [Language.PureScript.AST.Declarations.ErrorMessageHint]
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),1*U(A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds8 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkNextKind ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),1*U(A,A,1*U(U),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds3 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkNextSkolem ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),1*U(A,A,A,1*U(U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds4 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkNextSkolemScope ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),1*U(A,A,A,A,1*U(U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds5 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkNextType ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),1*U(A,1*U(U),A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds2 }) -}
5c23016b2e80baec4bdda0c92644cfa1
  checkSubstitution ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.TypeChecker.Monad.Substitution
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U(U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds7 }) -}
3c6191a6ebded964db700faa074a7552
  checkVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ e
                   @ m :: * -> *
                   (w :: (e :: *)
                         Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   (w1 :: Control.Monad.State.Class.MonadState
                            Language.PureScript.TypeChecker.Monad.CheckState m)
                   (w2 :: Control.Monad.Error.Class.MonadError e m)
                   (w3 :: Language.PureScript.Names.Qualified
                            Language.PureScript.Names.Ident) ->
                 case w3 of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                 Language.PureScript.TypeChecker.Monad.$wcheckVisibility
                   @ e
                   @ m
                   w
                   w1
                   w2
                   ww1
                   ww2 }) -}
b22dfcf495287a9495d33db1875afeb2
  emptyCheckState ::
    Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (env :: Language.PureScript.Environment.Environment) ->
                 Language.PureScript.TypeChecker.Monad.CheckState
                   env
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                   Language.PureScript.TypeChecker.Monad.emptySubstitution
                   (GHC.Types.[]
                      @ Language.PureScript.AST.Declarations.ErrorMessageHint)) -}
e7f1e356adfca76f93dc6b74b68c173a
  emptyCheckState1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
41d082f8a398bc6abbe358ad0e617efb
  emptySubstitution ::
    Language.PureScript.TypeChecker.Monad.Substitution
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Language.PureScript.TypeChecker.Monad.Substitution
                   (Data.Map.Internal.Tip
                      @ GHC.Types.Int
                      @ Language.PureScript.Types.Type)
                   (Data.Map.Internal.Tip
                      @ GHC.Types.Int
                      @ Language.PureScript.Kinds.Kind)) -}
dd8f1993ed3dd1855f6ea76a19782028
  getEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.Environment.Environment
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ Language.PureScript.Environment.Environment
                   Language.PureScript.TypeChecker.Monad.checkEnv
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
3553d6fedf4a25833cace1aa7ba0c6a9
  getHints ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m [Language.PureScript.AST.Declarations.ErrorMessageHint]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ [Language.PureScript.AST.Declarations.ErrorMessageHint]
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ [Language.PureScript.AST.Declarations.ErrorMessageHint]
                      (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       GHC.List.reverse1
                         @ Language.PureScript.AST.Declarations.ErrorMessageHint
                         ds7
                         (GHC.Types.[]
                            @ Language.PureScript.AST.Declarations.ErrorMessageHint) }))) -}
fa3c1ee0d304f6b19e55a6257785e6f4
  getLocalContext ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.AST.Declarations.Context
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,C(U),A),U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.AST.Declarations.Context
                   (Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState)
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ [(Language.PureScript.Names.Ident,
                          Language.PureScript.Types.Type)]
                      (case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       Language.PureScript.TypeChecker.Monad.getLocalContext_go13
                         (GHC.Types.[]
                            @ (Language.PureScript.Names.Ident,
                               Language.PureScript.Types.Type))
                         ds1 }))) -}
af233a169b556df68079467169a9f1d1
  getLocalContext_go13 ::
    [(Language.PureScript.Names.Ident, Language.PureScript.Types.Type)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (Language.PureScript.Types.Type,
          Language.PureScript.Environment.NameKind,
          Language.PureScript.Environment.NameVisibility)
    -> [(Language.PureScript.Names.Ident,
         Language.PureScript.Types.Type)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
bc1a001f0bb244cf56f13be7208df516
  getTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m (Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               Language.PureScript.TypeClassDictionaries.NamedDict)))
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ (Data.Map.Internal.Map
                        (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                           (Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 Language.PureScript.Names.Ident)
                              Language.PureScript.TypeClassDictionaries.NamedDict)))
                   Language.PureScript.TypeChecker.Monad.getTypeClassDictionaries1
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
859bee28d2e1fea7c1d7a4169d00ed09
  getTypeClassDictionaries1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLLSLL)LLLLLLL),1*U(1*U(A,A,A,A,1*U,A,A),A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case x of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                 ds12 } }) -}
5e7aad705ec4c1712d6cba27abb52b9f
  getVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m Language.PureScript.Environment.NameVisibility
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (qual :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident) ->
                 let {
                   lvl30 :: m Language.PureScript.Environment.NameVisibility
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Environment.NameVisibility
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.NameIsUndefined
                                (case qual of wild { Language.PureScript.Names.Qualified ds1 a1 ->
                                 a1 })))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Environment.NameVisibility
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case qual of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go13
                           @ (Language.PureScript.Types.Type,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility)
                           ww1
                           ww2
                           ds1 of wild1 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds
                      -> case ds of wild2 { (,,) ds11 ds12 vis ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Environment.NameVisibility
                           vis } } } }) }) -}
16a54f43ede4af63e8b1bd5e1cb8169d
  guardWith ::
    Control.Monad.Error.Class.MonadError e m =>
    e -> GHC.Types.Bool -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(1*U(A,A,A,1*C1(U),A),1*C1(U),A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ e
                   @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m)
                   (eta :: e)
                   (eta1 :: GHC.Types.Bool) ->
                 case eta1 of wild {
                   GHC.Types.False
                   -> Control.Monad.Error.Class.throwError
                        @ e
                        @ m
                        $dMonadError
                        @ ()
                        eta
                   GHC.Types.True
                   -> GHC.Base.return
                        @ m
                        (Control.Monad.Error.Class.$p1MonadError @ e @ m $dMonadError)
                        @ ()
                        GHC.Tuple.() }) -}
d3866d9195f056bc6b96e4bbf9da92a5
  lookupTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> m (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           Language.PureScript.TypeClassDictionaries.NamedDict))
                   (\ (x :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    case x of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                    case Language.PureScript.TypeChecker.Monad.$slookup7
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.ClassName))
                                (Data.Map.Internal.Map
                                   (Language.PureScript.Names.Qualified
                                      Language.PureScript.Names.Ident)
                                   Language.PureScript.TypeClassDictionaries.NamedDict))
                           eta
                           ds12 of wild2 {
                      GHC.Base.Nothing
                      -> Data.Map.Internal.Tip
                           @ (Language.PureScript.Names.Qualified
                                (Language.PureScript.Names.ProperName
                                   'Language.PureScript.Names.ClassName))
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   Language.PureScript.Names.Ident)
                                Language.PureScript.TypeClassDictionaries.NamedDict)
                      GHC.Base.Just v -> v } } })
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
f7de131697e04d9bd8dfa4ea5ce64eb6
  lookupTypeClassDictionariesForClass ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName)
    -> m (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            Language.PureScript.TypeClassDictionaries.NamedDict)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U,A,A)><L,U><L,U(U,U(U,U,U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (eta1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName)) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           Language.PureScript.TypeClassDictionaries.NamedDict))
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        Language.PureScript.TypeClassDictionaries.NamedDict)
                   (\ (x :: Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.ClassName))
                              (Data.Map.Internal.Map
                                 (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident)
                                 Language.PureScript.TypeClassDictionaries.NamedDict)) ->
                    case eta1 of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go2
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   Language.PureScript.Names.Ident)
                                Language.PureScript.TypeClassDictionaries.NamedDict)
                           ww1
                           ww2
                           x of wild {
                      GHC.Base.Nothing
                      -> Data.Map.Internal.Tip
                           @ (Language.PureScript.Names.Qualified
                                Language.PureScript.Names.Ident)
                           @ Language.PureScript.TypeClassDictionaries.NamedDict
                      GHC.Base.Just v -> v } })
                   (Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionaries
                      @ m
                      $dMonadState
                      eta)) -}
1c09258d333965e2bce1d96ed21e1a37
  lookupTypeVariable ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
    -> m Language.PureScript.Kinds.Kind
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (currentModule :: Language.PureScript.Names.ModuleName)
                   (ds :: Language.PureScript.Names.Qualified
                            (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)) ->
                 case ds of wild { Language.PureScript.Names.Qualified moduleName name ->
                 let {
                   lvl30 :: m Language.PureScript.Kinds.Kind
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Kinds.Kind
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.UndefinedTypeVariable name))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 let {
                   lvl31 :: Language.PureScript.Names.ModuleName
                   = case moduleName of wild1 {
                       GHC.Base.Nothing -> currentModule GHC.Base.Just v -> v }
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Kinds.Kind
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case env of wild1 { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go2
                           ds2
                           name
                           lvl31 of wild2 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds11
                      -> case ds11 of wild3 { (,) k ds12 ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Kinds.Kind
                           k } } }) } }) -}
a8809e49396cc1aa51c1e0e6f1f04b5a
  lookupVariable ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m Language.PureScript.Types.Type
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (qual :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident) ->
                 let {
                   lvl30 :: m Language.PureScript.Types.Type
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Types.Type
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.NameIsUndefined
                                (case qual of wild { Language.PureScript.Names.Qualified ds1 a1 ->
                                 a1 })))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Types.Type
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case qual of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go13
                           @ (Language.PureScript.Types.Type,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility)
                           ww1
                           ww2
                           ds1 of wild1 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds
                      -> case ds of wild2 { (,,) ty ds11 ds12 ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Types.Type
                           ty } } } }) }) -}
e75c19aaefd6489ed598af88fe7191c6
  makeBindingGroupVisible ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible1) -}
e21f99dddbff80fecb7960f7c1554efd
  makeBindingGroupVisible1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> ((), Language.PureScript.TypeChecker.Monad.CheckState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,U,U,U,U,U,U),U,U,U,U,U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 (GHC.Tuple.(),
                  case w of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  Language.PureScript.TypeChecker.Monad.CheckState
                    (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                     Language.PureScript.Environment.Environment
                       (Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible_go13
                          ds8)
                       ds9
                       ds10
                       ds11
                       ds12
                       ds13
                       ds14 })
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7 })) -}
f236587794e58d95e8a04e6da4305f23
  makeBindingGroupVisible_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      (Language.PureScript.Types.Type,
       Language.PureScript.Environment.NameKind,
       Language.PureScript.Environment.NameVisibility)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (Language.PureScript.Types.Type,
          Language.PureScript.Environment.NameKind,
          Language.PureScript.Environment.NameVisibility)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c8bf1bde5aba7ebd111ed1014eb5bced
  modifyEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    (Language.PureScript.Environment.Environment
     -> Language.PureScript.Environment.Environment)
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (f1 :: Language.PureScript.Environment.Environment
                          -> Language.PureScript.Environment.Environment) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    (GHC.Tuple.(),
                     case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                     Language.PureScript.TypeChecker.Monad.CheckState
                       (f1 ds)
                       ds1
                       ds2
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7 }))) -}
102ecd4e809997e3cbdd86ed4334f805
  preservingNames ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        (Language.PureScript.Types.Type,
                         Language.PureScript.Environment.NameKind,
                         Language.PureScript.Environment.NameVisibility))
                   @ a
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           (Language.PureScript.Types.Type,
                            Language.PureScript.Environment.NameKind,
                            Language.PureScript.Environment.NameVisibility))
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 Language.PureScript.Names.Ident)
                              (Language.PureScript.Types.Type,
                               Language.PureScript.Environment.NameKind,
                               Language.PureScript.Environment.NameVisibility))
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                          case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                          ds8 } })))
                   (\ (orig :: Data.Map.Internal.Map
                                 (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident)
                                 (Language.PureScript.Types.Type,
                                  Language.PureScript.Environment.NameKind,
                                  Language.PureScript.Environment.NameVisibility)) ->
                    let {
                      lvl29 :: m ()
                      = Control.Monad.State.Class.state
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState
                          @ ()
                          (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                           (GHC.Tuple.(),
                            case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                            Language.PureScript.TypeChecker.Monad.CheckState
                              (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               Language.PureScript.Environment.Environment
                                 orig
                                 ds9
                                 ds10
                                 ds11
                                 ds12
                                 ds13
                                 ds14 })
                              ds1
                              ds2
                              ds3
                              ds4
                              ds5
                              ds6
                              ds7 }))
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ a
                      @ a
                      eta
                      (\ (a1 :: a) ->
                       GHC.Base.>>
                         @ m
                         $dMonad
                         @ ()
                         @ a
                         lvl29
                         (GHC.Base.return @ m $dMonad @ a a1)))) -}
cc5d13bc92148c99450053958455a21e
  putEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Environment.Environment -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (env :: Language.PureScript.Environment.Environment) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    (GHC.Tuple.(),
                     case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                     Language.PureScript.TypeChecker.Monad.CheckState
                       env
                       ds1
                       ds2
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7 }))) -}
07591dd797c4683ca8d514a557775330
  rethrowWithPositionTC ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.SourcePos.SourceSpan -> m a -> m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,C(U),C(C1(U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   (pos :: Language.PureScript.AST.SourcePos.SourceSpan) ->
                 Language.PureScript.TypeChecker.Monad.withErrorMessageHint
                   @ m
                   @ a
                   $dMonadState
                   $dMonadError
                   (Language.PureScript.Errors.positionedError pos)) -}
7f3707dcbb6ec2037ef30e630a455984
  runCheck ::
    GHC.Base.Functor m =>
    Control.Monad.Trans.State.Lazy.StateT
      Language.PureScript.TypeChecker.Monad.CheckState m a
    -> m (a, Language.PureScript.Environment.Environment)
  {- Arity: 2,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             Language.PureScript.TypeChecker.Monad.CheckState m a) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (a, Language.PureScript.TypeChecker.Monad.CheckState)
                   @ (a, Language.PureScript.Environment.Environment)
                   (Language.PureScript.TypeChecker.Monad.runCheck2 @ a)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <Language.PureScript.TypeChecker.Monad.CheckState>_N <m>_R <a>_N)
                      Language.PureScript.TypeChecker.Monad.runCheck1)) -}
f8873ffc1b9f3cb742376b7e71bf802e
  runCheck' ::
    GHC.Base.Functor m =>
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Control.Monad.Trans.State.Lazy.StateT
         Language.PureScript.TypeChecker.Monad.CheckState m a
    -> m (a, Language.PureScript.Environment.Environment)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (st :: Language.PureScript.TypeChecker.Monad.CheckState)
                   (check :: Control.Monad.Trans.State.Lazy.StateT
                               Language.PureScript.TypeChecker.Monad.CheckState m a) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (a, Language.PureScript.TypeChecker.Monad.CheckState)
                   @ (a, Language.PureScript.Environment.Environment)
                   (Language.PureScript.TypeChecker.Monad.runCheck2 @ a)
                   (check
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <Language.PureScript.TypeChecker.Monad.CheckState>_N <m>_R <a>_N)
                      st)) -}
1c8c28e7fe4184617f444bc19dcee08c
  runCheck1 :: Language.PureScript.TypeChecker.Monad.CheckState
  {- Strictness: m,
     Unfolding: (Language.PureScript.TypeChecker.Monad.CheckState
                   Language.PureScript.Environment.initEnvironment
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                   Language.PureScript.TypeChecker.Monad.emptySubstitution
                   (GHC.Types.[]
                      @ Language.PureScript.AST.Declarations.ErrorMessageHint)) -}
c0b66e36bef46369771488ee84439dd1
  runCheck2 ::
    (a, Language.PureScript.TypeChecker.Monad.CheckState)
    -> (a, Language.PureScript.Environment.Environment)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U,1*U(1*U,A,A,A,A,A,A,A))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   (ds :: (a, Language.PureScript.TypeChecker.Monad.CheckState)) ->
                 (case ds of wild { (,) x y -> x },
                  case ds of wild { (,) x y ->
                  case y of wild1 { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  ds1 } })) -}
f41a5a409aa69b88b3ab5e8061db655f
  substKind ::
    Language.PureScript.TypeChecker.Monad.Substitution
    -> Data.Map.Internal.Map
         GHC.Types.Int Language.PureScript.Kinds.Kind
  RecSel Left Language.PureScript.TypeChecker.Monad.Substitution
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.Substitution ds1 ds2 ->
                 ds2 }) -}
f41a5a409aa69b88b3ab5e8061db655f
  substType ::
    Language.PureScript.TypeChecker.Monad.Substitution
    -> Data.Map.Internal.Map
         GHC.Types.Int Language.PureScript.Types.Type
  RecSel Left Language.PureScript.TypeChecker.Monad.Substitution
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.Substitution ds1 ds2 ->
                 ds1 }) -}
9813266f4e64180bfd2528a8cdfa1c86
  warnAndRethrowWithPositionTC ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.Writer.Class.MonadWriter
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.SourcePos.SourceSpan -> m a -> m a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,C(U),C(C1(U)))><L,U(A,U(A,C(C1(U)),A,C(U),A),A,A,A,C(U))><L,U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter
                                       Language.PureScript.Errors.MultipleErrors m)
                   (pos :: Language.PureScript.AST.SourcePos.SourceSpan)
                   (eta :: m a) ->
                 Language.PureScript.TypeChecker.Monad.withErrorMessageHint
                   @ m
                   @ a
                   $dMonadState
                   $dMonadError
                   (Language.PureScript.AST.Declarations.PositionedError
                      (GHC.Base.:|
                         @ Language.PureScript.AST.SourcePos.SourceSpan
                         pos
                         (GHC.Types.[] @ Language.PureScript.AST.SourcePos.SourceSpan)))
                   (Language.PureScript.Errors.warnWithPosition
                      @ m
                      @ a
                      $dMonadWriter
                      pos
                      eta)) -}
31d29b933d666af9ed21bb6939750997
  withBindingGroupVisible ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 Language.PureScript.TypeChecker.Monad.preservingNames
                   @ m
                   @ a
                   $dMonadState
                   (GHC.Base.>>
                      @ m
                      (Control.Monad.State.Class.$p1MonadState
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      @ ()
                      @ a
                      (Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible1)
                      eta)) -}
2c6ffe4a4583e9fbcf6d82baf0863283
  withErrorMessageHint ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.Declarations.ErrorMessageHint -> m a -> m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U(A,C(U),1*C1(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   (eta :: Language.PureScript.AST.Declarations.ErrorMessageHint)
                   (eta1 :: m a) ->
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessageHint
                              eta
                              ds7) }))
                 } in
                 let {
                   lvl30 :: m a
                   = Control.Monad.Error.Class.catchError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                       @ a
                       eta1
                       (\ (x :: Language.PureScript.Errors.MultipleErrors) ->
                        Control.Monad.Error.Class.throwError
                          @ Language.PureScript.Errors.MultipleErrors
                          @ m
                          $dMonadError
                          @ a
                          (Language.PureScript.Errors.addHint1 eta x)
                            `cast`
                          (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl31 :: m ()
                         = let {
                             lvl32 :: [Language.PureScript.AST.Declarations.ErrorMessageHint]
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               ds7 }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 ds
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 lvl32 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         lvl30
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl31
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
ea0f5e014aed8afacc077d40292d9945
  withFreshSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       Language.PureScript.TypeChecker.Monad.withFreshSubstitution1
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Language.PureScript.TypeChecker.Monad.Substitution
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               ds6 }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 ds
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 lvl31
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
5cb3226bf37fcda175b1da71df8b886a
  withFreshSubstitution1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> ((), Language.PureScript.TypeChecker.Monad.CheckState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 (GHC.Tuple.(),
                  case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  Language.PureScript.TypeChecker.Monad.CheckState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    Language.PureScript.TypeChecker.Monad.emptySubstitution
                    ds7 })) -}
423edfeb0b3a7abffe30a99e2bab423c
  withScopedTypeVars ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Writer.Class.MonadWriter
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.Names.ModuleName
    -> [(Data.Text.Internal.Text, Language.PureScript.Kinds.Kind)]
    -> m a
    -> m a
  {- Arity: 2,
     Strictness: <L,U(U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,A,A,C(U),A,A)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter
                                       Language.PureScript.Errors.MultipleErrors m) ->
                 let {
                   lvl29 :: m Language.PureScript.TypeChecker.Monad.CheckState
                   = Control.Monad.State.Class.get
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl30 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   lvl31 :: m ()
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad @ m $dMonad)
                       @ ()
                       GHC.Tuple.()
                 } in
                 \ (mn :: Language.PureScript.Names.ModuleName)
                   (ks :: [(Data.Text.Internal.Text, Language.PureScript.Kinds.Kind)])
                   (ma :: m a) ->
                 let {
                   lvl32 :: m a
                   = Language.PureScript.TypeChecker.Monad.bindTypes
                       @ m
                       @ a
                       $dMonadState
                       (let {
                          lvl33 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName
                          = GHC.Base.Just @ Language.PureScript.Names.ModuleName mn
                        } in
                        Language.PureScript.TypeChecker.Monad.$sfromList1
                          @ (Language.PureScript.Kinds.Kind,
                             Language.PureScript.Environment.TypeKind)
                          (GHC.Base.map
                             @ (Data.Text.Internal.Text, Language.PureScript.Kinds.Kind)
                             @ (Language.PureScript.Names.Qualified
                                  (Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.TypeName),
                                (Language.PureScript.Kinds.Kind,
                                 Language.PureScript.Environment.TypeKind))
                             (\ (ds :: (Data.Text.Internal.Text,
                                        Language.PureScript.Kinds.Kind)) ->
                              case ds of wild { (,) name k ->
                              (Language.PureScript.Names.Qualified
                                 @ (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.TypeName)
                                 lvl33
                                 name
                                   `cast`
                                 (Sym (Language.PureScript.Names.N:ProperName[0]
                                           <'Language.PureScript.Names.TypeName>_P)),
                               (k, Language.PureScript.Environment.ScopedTypeVar)) })
                             ks))
                       ma
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   lvl29
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      (letrec {
                         go :: [(Data.Text.Internal.Text, Language.PureScript.Kinds.Kind)]
                               -> m ()
                           {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [(Data.Text.Internal.Text,
                                      Language.PureScript.Kinds.Kind)]) ->
                           case ds of wild {
                             [] -> lvl30
                             : y ys
                             -> GHC.Base.>>
                                  @ m
                                  $dMonad
                                  @ ()
                                  @ ()
                                  (case y of wild1 { (,) name ds1 ->
                                   case orig of wild2 { Language.PureScript.TypeChecker.Monad.CheckState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                                   case ds2 of wild3 { Language.PureScript.Environment.Environment ds10 ds11 ds12 ds13 ds14 ds15 ds16 ->
                                   case Language.PureScript.TypeChecker.Monad.$smember_$s$wpoly_go13
                                          ds11
                                          name
                                            `cast`
                                          (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.TypeName>_P))
                                          mn of wild4 {
                                     GHC.Types.False -> lvl31
                                     GHC.Types.True
                                     -> Control.Monad.Writer.Class.tell
                                          @ Language.PureScript.Errors.MultipleErrors
                                          @ m
                                          $dMonadWriter
                                          (GHC.Types.:
                                             @ Language.PureScript.AST.Declarations.ErrorMessage
                                             (Language.PureScript.AST.Declarations.ErrorMessage
                                                (GHC.Types.[]
                                                   @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                                (Language.PureScript.AST.Declarations.ShadowedTypeVar
                                                   name))
                                             (GHC.Types.[]
                                                @ Language.PureScript.AST.Declarations.ErrorMessage))
                                            `cast`
                                          (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) } } } })
                                  (go ys) }
                       } in
                       go ks)
                      lvl32)) -}
06eff39ea4200a08dad2b632e54d2da8
  withTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    [Language.PureScript.TypeClassDictionaries.NamedDict] -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,1*U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: [Language.PureScript.TypeClassDictionaries.NamedDict])
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = let {
                       mentries :: Data.Map.Internal.Map
                                     (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                                     (Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           (Language.PureScript.Names.ProperName
                                              'Language.PureScript.Names.ClassName))
                                        (Data.Map.Internal.Map
                                           (Language.PureScript.Names.Qualified
                                              Language.PureScript.Names.Ident)
                                           Language.PureScript.TypeClassDictionaries.NamedDict))
                       = Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries_go13
                           (Data.Map.Internal.Tip
                              @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                              @ (Data.Map.Internal.Map
                                   (Language.PureScript.Names.Qualified
                                      (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.ClassName))
                                   (Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      Language.PureScript.TypeClassDictionaries.NamedDict)))
                           (Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries_go
                              eta)
                     } in
                     Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              ds8
                              ds9
                              ds10
                              ds11
                              (Language.PureScript.TypeChecker.Monad.$sunionWith1
                                 @ (Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      (Data.Map.Internal.Map
                                         (Language.PureScript.Names.Qualified
                                            Language.PureScript.Names.Ident)
                                         Language.PureScript.TypeClassDictionaries.NamedDict))
                                 Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries1
                                 ds12
                                 mentries)
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                                        (Data.Map.Internal.Map
                                           (Language.PureScript.Names.Qualified
                                              (Language.PureScript.Names.ProperName
                                                 'Language.PureScript.Names.ClassName))
                                           (Data.Map.Internal.Map
                                              (Language.PureScript.Names.Qualified
                                                 Language.PureScript.Names.Ident)
                                              Language.PureScript.TypeClassDictionaries.NamedDict))
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds12 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    ds8
                                    ds9
                                    ds10
                                    ds11
                                    lvl31
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
15fb677d4e269194de8a328b6fae419e
  withTypeClassDictionaries1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         Language.PureScript.TypeClassDictionaries.NamedDict)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            Language.PureScript.TypeClassDictionaries.NamedDict)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            Language.PureScript.TypeClassDictionaries.NamedDict)
  {- Arity: 2,
     Unfolding: (Language.PureScript.TypeChecker.Monad.$sunionWith
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        Language.PureScript.TypeClassDictionaries.NamedDict)
                   (Language.PureScript.TypeChecker.Monad.$sunion1
                      @ (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)))) -}
82a2e1d11f279ae0fd4f226d2286c972
  withTypeClassDictionaries_go ::
    [Language.PureScript.TypeClassDictionaries.NamedDict]
    -> [(GHC.Base.Maybe Language.PureScript.Names.ModuleName,
         Data.Map.Internal.Map
           (Language.PureScript.Names.Qualified
              (Language.PureScript.Names.ProperName
                 'Language.PureScript.Names.ClassName))
           (Data.Map.Internal.Map
              (Language.PureScript.Names.Qualified
                 Language.PureScript.Names.Ident)
              Language.PureScript.TypeClassDictionaries.NamedDict))]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8ce3aaf80a59d87124ef5a8a448d3581
  withTypeClassDictionaries_go13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            Language.PureScript.TypeClassDictionaries.NamedDict))
    -> [(GHC.Base.Maybe Language.PureScript.Names.ModuleName,
         Data.Map.Internal.Map
           (Language.PureScript.Names.Qualified
              (Language.PureScript.Names.ProperName
                 'Language.PureScript.Names.ClassName))
           (Data.Map.Internal.Map
              (Language.PureScript.Names.Qualified
                 Language.PureScript.Names.Ident)
              Language.PureScript.TypeClassDictionaries.NamedDict))]
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
ef2db63805601e7a5a6cb5a68d6445cc
  withoutWarnings ::
    Control.Monad.Writer.Class.MonadWriter w m => m a -> m (a, w)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLC(S)),U(1*U(A,1*U,A,A),U(A,C(C1(U)),A,C(U),A),A,A,1*C1(U),C(U))><L,U>,
     Unfolding: (\ @ w
                   @ m :: * -> *
                   @ a
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter w m)
                   (eta :: m a) ->
                 Control.Monad.Writer.Class.censor
                   @ w
                   @ m
                   @ (a, w)
                   $dMonadWriter
                   (let {
                      x :: GHC.Base.Monoid w
                      = Control.Monad.Writer.Class.$p1MonadWriter @ w @ m $dMonadWriter
                    } in
                    let { x1 :: w = GHC.Base.mempty @ w x } in \ (ds :: w) -> x1)
                   (Control.Monad.Writer.Class.listen
                      @ w
                      @ m
                      $dMonadWriter
                      @ a
                      eta)) -}
"SC:$wpoly_go130" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      a)
                             (sc1 :: Language.PureScript.Names.Ident)
  Language.PureScript.TypeChecker.Monad.$wpoly_go13 @ a
                                                    (GHC.Base.Nothing
                                                       @ Language.PureScript.Names.ModuleName)
                                                    sc1
                                                    sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
      @ a
      sc
      sc1
"SC:$wpoly_go130" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.ClassName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Nothing
                                                      @ Language.PureScript.Names.ModuleName)
                                                   sc1
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go6
      @ a
      sc
      sc1
"SC:$wpoly_go131" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      a)
                             (sc1 :: Language.PureScript.Names.Ident)
                             (sc2 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go13 @ a
                                                    (GHC.Base.Just
                                                       @ Language.PureScript.Names.ModuleName
                                                       sc2)
                                                    sc1
                                                    sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
      @ a
      sc
      sc1
      sc2
"SC:$wpoly_go131" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.ClassName)
                             (sc2 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Just
                                                      @ Language.PureScript.Names.ModuleName
                                                      sc2)
                                                   sc1
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
      @ a
      sc
      sc1
      sc2
"SC:$wpoly_go132" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: GHC.Prim.ByteArray#)
                             (sc2 :: GHC.Prim.Int#)
                             (sc3 :: GHC.Prim.Int#)
                             (sg :: (Data.Text.Internal.Text :: *)
                                    ~R# (Language.PureScript.Names.ProperName
                                           'Language.PureScript.Names.ClassName :: *))
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Nothing
                                                      @ Language.PureScript.Names.ModuleName)
                                                   (Data.Text.Internal.Text sc1 sc2 sc3) `cast` sg
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
      @ a
      sc
      sc1
      sc2
      sc3
      @~ sg
"SC:poly_go130" forall @ a
                       (sc :: Data.Map.Internal.Map
                                (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a)
  Language.PureScript.TypeChecker.Monad.$slookup7 @ a
                                                  (GHC.Base.Nothing
                                                     @ Language.PureScript.Names.ModuleName)
                                                  sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go1 @ a sc
"SC:poly_go131" forall @ a
                       (sc :: Data.Map.Internal.Map
                                (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a)
                       (sc1 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$slookup7 @ a
                                                  (GHC.Base.Just
                                                     @ Language.PureScript.Names.ModuleName
                                                     sc1)
                                                  sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
      @ a
      sc
      sc1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqMaybe @ ModuleName" [orphan] forall (v :: GHC.Classes.Eq
                                                                                            Language.PureScript.Names.ModuleName)
  GHC.Base.$fEqMaybe @ Language.PureScript.Names.ModuleName v
  = Language.PureScript.TypeChecker.Monad.$s$fEqMaybe
"SPEC/Language.PureScript.TypeChecker.Monad $fEqMaybe_$c/= @ ModuleName" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                    Language.PureScript.Names.ModuleName)
  GHC.Base.$fEqMaybe_$c/= @ Language.PureScript.Names.ModuleName $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ (ProperName
                                                              'ClassName)" [orphan] forall (v :: GHC.Classes.Eq
                                                                                                                                                                           (Language.PureScript.Names.ProperName
                                                                                                                                                                              'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fEqQualified @ (Language.PureScript.Names.ProperName
                                               'Language.PureScript.Names.ClassName)
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ (ProperName
                                                              'TypeName)" [orphan] forall (v :: GHC.Classes.Eq
                                                                                                                                                                          (Language.PureScript.Names.ProperName
                                                                                                                                                                             'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fEqQualified @ (Language.PureScript.Names.ProperName
                                               'Language.PureScript.Names.TypeName)
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ Ident" [orphan] forall (v :: GHC.Classes.Eq
                                                                                           Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fEqQualified @ Language.PureScript.Names.Ident
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified2
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ (ProperName
                                                                   'ClassName)" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                                                                                                        (Language.PureScript.Names.ProperName
                                                                                                                                                                                           'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fEqQualified_$c/= @ (Language.PureScript.Names.ProperName
                                                    'Language.PureScript.Names.ClassName)
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ (ProperName
                                                                   'TypeName)" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                                                                                                       (Language.PureScript.Names.ProperName
                                                                                                                                                                                          'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fEqQualified_$c/= @ (Language.PureScript.Names.ProperName
                                                    'Language.PureScript.Names.TypeName)
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ Ident" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                   Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fEqQualified_$c/= @ Language.PureScript.Names.Ident
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=2
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe @ ModuleName" [orphan] forall (v :: GHC.Classes.Ord
                                                                                             Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe @ Language.PureScript.Names.ModuleName v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$c< @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                     Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$c< @ Language.PureScript.Names.ModuleName
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$c<
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$ccompare @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                           Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$ccompare @ Language.PureScript.Names.ModuleName
                                $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$ccompare
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$cmax @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                       Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$cmax @ Language.PureScript.Names.ModuleName
                            $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$cmax
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ (ProperName
                                                               'ClassName)" [orphan] forall (v :: GHC.Classes.Ord
                                                                                                                                                                             (Language.PureScript.Names.ProperName
                                                                                                                                                                                'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fOrdQualified @ (Language.PureScript.Names.ProperName
                                                'Language.PureScript.Names.ClassName)
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ (ProperName
                                                               'TypeName)" [orphan] forall (v :: GHC.Classes.Ord
                                                                                                                                                                            (Language.PureScript.Names.ProperName
                                                                                                                                                                               'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fOrdQualified @ (Language.PureScript.Names.ProperName
                                                'Language.PureScript.Names.TypeName)
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified1
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ Ident" [orphan] forall (v :: GHC.Classes.Ord
                                                                                            Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fOrdQualified @ Language.PureScript.Names.Ident
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified2
"SPEC/Language.PureScript.TypeChecker.Monad fromList @ (Qualified
                                                         (ProperName 'TypeName)) _" [orphan] forall @ a
                                                                                                                                                                      ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                                  (Language.PureScript.Names.Qualified
                                                                                                                                                                                     (Language.PureScript.Names.ProperName
                                                                                                                                                                                        'Language.PureScript.Names.TypeName)))
  Data.Map.Internal.fromList @ (Language.PureScript.Names.Qualified
                                  (Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.TypeName))
                             @ a
                             $dOrd
  = Language.PureScript.TypeChecker.Monad.$sfromList1 @ a
"SPEC/Language.PureScript.TypeChecker.Monad fromList @ (Qualified
                                                         Ident) _" [orphan] forall @ a
                                                                                                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                 (Language.PureScript.Names.Qualified
                                                                                                                                                                    Language.PureScript.Names.Ident))
  Data.Map.Internal.fromList @ (Language.PureScript.Names.Qualified
                                  Language.PureScript.Names.Ident)
                             @ a
                             $dOrd
  = Language.PureScript.TypeChecker.Monad.$sfromList @ a
"SPEC/Language.PureScript.TypeChecker.Monad union @ (Qualified
                                                      (ProperName 'TypeName)) _" [orphan] forall @ a
                                                                                                                                                                ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                            (Language.PureScript.Names.Qualified
                                                                                                                                                                               (Language.PureScript.Names.ProperName
                                                                                                                                                                                  'Language.PureScript.Names.TypeName)))
  Data.Map.Internal.union @ (Language.PureScript.Names.Qualified
                               (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.TypeName))
                          @ a
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunion @ a
"SPEC/Language.PureScript.TypeChecker.Monad union @ (Qualified
                                                      Ident) _" [orphan] forall @ a
                                                                                                                                               ($dOrd :: GHC.Classes.Ord
                                                                                                                                                           (Language.PureScript.Names.Qualified
                                                                                                                                                              Language.PureScript.Names.Ident))
  Data.Map.Internal.union @ (Language.PureScript.Names.Qualified
                               Language.PureScript.Names.Ident)
                          @ a
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunion1 @ a
"SPEC/Language.PureScript.TypeChecker.Monad unionWith @ (Maybe
                                                          ModuleName) _" [orphan] forall @ a
                                                                                                                                                        ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                    (GHC.Base.Maybe
                                                                                                                                                                       Language.PureScript.Names.ModuleName))
  Data.Map.Internal.unionWith @ (GHC.Base.Maybe
                                   Language.PureScript.Names.ModuleName)
                              @ a
                              $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunionWith1 @ a
"SPEC/Language.PureScript.TypeChecker.Monad unionWith @ (Qualified
                                                          (ProperName 'ClassName)) _" [orphan] forall @ a
                                                                                                                                                                         ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                                     (Language.PureScript.Names.Qualified
                                                                                                                                                                                        (Language.PureScript.Names.ProperName
                                                                                                                                                                                           'Language.PureScript.Names.ClassName)))
  Data.Map.Internal.unionWith @ (Language.PureScript.Names.Qualified
                                   (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.ClassName))
                              @ a
                              $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunionWith @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

