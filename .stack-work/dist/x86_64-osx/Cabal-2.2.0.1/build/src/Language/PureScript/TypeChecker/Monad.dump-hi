
==================== FINAL INTERFACE ====================
2019-01-24 14:15:28.885025 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeChecker.Monad 8043
  interface hash: 107a9dac8455e61a9d72dca3da9393fc
  ABI hash: 5c6d6cca9d9f5acb98ab527615b54d6d
  export-list hash: 64079f93a7ca5d81f53055abc7f8ac53
  orphan hash: 0e69aa4a6fec8795d8226f20783b3f20
  flag hash: 409eb3effb99b666bef22fcf42369757
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.Monad.bindLocalTypeVariables
  Language.PureScript.TypeChecker.Monad.bindLocalVariables
  Language.PureScript.TypeChecker.Monad.bindNames
  Language.PureScript.TypeChecker.Monad.bindTypes
  Language.PureScript.TypeChecker.Monad.captureSubstitution
  Language.PureScript.TypeChecker.Monad.capturingSubstitution
  Language.PureScript.TypeChecker.Monad.checkVisibility
  Language.PureScript.TypeChecker.Monad.emptyCheckState
  Language.PureScript.TypeChecker.Monad.emptySubstitution
  Language.PureScript.TypeChecker.Monad.getEnv
  Language.PureScript.TypeChecker.Monad.getHints
  Language.PureScript.TypeChecker.Monad.getLocalContext
  Language.PureScript.TypeChecker.Monad.getTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.getVisibility
  Language.PureScript.TypeChecker.Monad.guardWith
  Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionariesForClass
  Language.PureScript.TypeChecker.Monad.lookupTypeVariable
  Language.PureScript.TypeChecker.Monad.lookupVariable
  Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible
  Language.PureScript.TypeChecker.Monad.modifyEnv
  Language.PureScript.TypeChecker.Monad.preservingNames
  Language.PureScript.TypeChecker.Monad.putEnv
  Language.PureScript.TypeChecker.Monad.rethrowWithPositionTC
  Language.PureScript.TypeChecker.Monad.runCheck
  Language.PureScript.TypeChecker.Monad.runCheck'
  Language.PureScript.TypeChecker.Monad.warnAndRethrowWithPositionTC
  Language.PureScript.TypeChecker.Monad.withBindingGroupVisible
  Language.PureScript.TypeChecker.Monad.withErrorMessageHint
  Language.PureScript.TypeChecker.Monad.withFreshSubstitution
  Language.PureScript.TypeChecker.Monad.withScopedTypeVars
  Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries
  Language.PureScript.TypeChecker.Monad.withoutWarnings
  Language.PureScript.TypeChecker.Monad.CheckState{Language.PureScript.TypeChecker.Monad.CheckState checkCurrentModule checkEnv checkHints checkNextKind checkNextSkolem checkNextSkolemScope checkNextType checkSubstitution}
  Language.PureScript.TypeChecker.Monad.Substitution{Language.PureScript.TypeChecker.Monad.Substitution substKind substType}
  Language.PureScript.TypeChecker.Monad.Unknown
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0 boxes-0.1.5
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.5.11.0
                      deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      microlens-0.4.9.1 microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1 mtl-2.2.2
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 scientific-0.3.6.2
                      sourcemap-0.1.6 split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List.NonEmpty 595ee3baddcadebc4831ea7541427984
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Type.Equality 9bb29c7615a8eec000fd03d114737416
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  Context 44dd7830663f65e1b8791f79a13f4cc0
  CycleInDeclaration e0dfc89422b1ddae332185ecc0077f4a
  ErrorMessageHint e92f6ee78a22c0eadc3566d7d1f48d5b
  NameIsUndefined 95fff85d3aa32709f78982493966418a
  ShadowedTypeVar 4c52be86526b8358b21559ef04c405da
  UndefinedTypeVariable 753aa04f581392bbd8dc7e51e2d8b736
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  SourceSpan 1e0cf2bd3ea18f97a2ff152297f09219
import  -/  Language.PureScript.Environment 467b25d81b890e1aaabe28d0f09d192d
  exports: a0cb6cb8c78c56365f58c9f88d1fe000
  Defined 324606166c226f373232031c92abddc6
  Environment 7eb61fe78108d98d82e39145869b2402
  LocalTypeVariable e2c76fd80d42fa567d79861fae05116e
  NameKind 7e23f4ddba2350405f465a39833424c7
  NameVisibility 22706fecc369659455f7dc5f13f3340f
  Private fa142db41a2d9e82cee092dfbb31a494
  ScopedTypeVar 3c76c2f4f1b2cfce95479237b75857ca
  TypeKind 713362c52c19b15de0cab368ddfda667
  Undefined 33d3e9c9b0e559f52c77c918db8d0dd4
  initEnvironment 3ad13bed759e200214c30a8db150a0f5
  names 7eb61fe78108d98d82e39145869b2402
  typeClassDictionaries 7eb61fe78108d98d82e39145869b2402
  types 7eb61fe78108d98d82e39145869b2402
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  exports: 8e61484c4664eceb943d9fc4820c721b
  MultipleErrors e1ef6a17348ccfe3ef65185d3c5f9026
  addHint 4d7c0f041e7397261babf0b1c1669b2a
  errorMessage 4308e76c0636918842d6acdb173a8e4b
  positionedError 294ba93655a5845067da4cbeb75d1347
  rethrow 3f15f6976fa85d5a6c226df5a731c52a
  warnWithPosition 7ad80b7c006a458b8324a8a9926b1f43
import  -/  Language.PureScript.Kinds e26b9cf8211f7e72bb44fdd3faed066e
  exports: fe71635ad7964c0d620fb0685614a050
  SourceKind 4cdf50d4b2444221832ca704f3a0c468
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  exports: ad7ae34f85124c68e8ba1c90fb2e732f
  ClassName c5d98a635cb261f6a93bf01096d0c6ed
  Ident 71f167265716f619863a793fa311e198
  Ident bad3562aa6138b6192713ac281080869
  ModuleName 1b2ddf0c04464d2fa2588925f10c1966
  ProperName f69d3801241fcb4773f1284cd28f2dee
  ProperName a7268334e0b909381550b9329cb80fcc
  Qualified b6e1bc9e7244a41d3c6149c9b5c2d6d8
  Qualified 1b2ddf0c04464d2fa2588925f10c1966
  TypeName 40ce511c66a72431b4e87351210f7b03
  disqualify bf1cc3b0e6c1ffc0008a6113bf8116c0
import  -/  Language.PureScript.TypeClassDictionaries 7fbd42662a194b8e85db9d2e22a4ea07
  exports: d83fdf73223cc4030d8649333c7594ad
  NamedDict 5e215d8e3d225869af57b18c7fc0b693
  TypeClassDictionaryInScope 83c0c3aa36a88c60dd2bb2e7525bc817
  tcdClassName d6c50933d00906849633ac7fdfbcd506
  tcdValue d6c50933d00906849633ac7fdfbcd506
import  -/  Language.PureScript.Types 80a51f62cb3e6c71f024289b88f07b7f
  exports: 229bb7528146da886cffbefad5822e19
  SourceType 0ac818517c14fedd280ef5885ae0cdc3
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
0bdcc74dcf778c671a2040bdef627268
  $s$fEqMaybe ::
    GHC.Classes.Eq
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                  (\ (ds :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (ds1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> GHC.Classes.$fEq[]_$c==
                               @ (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.Namespace)
                               (Language.PureScript.Names.$fEqProperName
                                  @ 'Language.PureScript.Names.Namespace)
                               a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  Language.PureScript.TypeChecker.Monad.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
c2f4b9491bb1558edf2fa4e88ca07ee9
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ (Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.Namespace)
                                  (Language.PureScript.Names.$fEqProperName
                                     @ 'Language.PureScript.Names.Namespace)
                                  a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                  b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
e11c6beb1deca8b8e245ea1905a7e1a9
  $s$fEqQualified ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName))
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fEqProperName
                        @ 'Language.PureScript.Names.ClassName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/= -}
973641fbc0528a0906dc726cb847f2b7
  $s$fEqQualified1 ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName))
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fEqProperName
                        @ 'Language.PureScript.Names.TypeName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=1 -}
0201bbed76010a35edd24d8d1adeb517
  $s$fEqQualified2 ::
    GHC.Classes.Eq
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       Language.PureScript.Names.Ident)
                  (Language.PureScript.Names.$fEqQualified_$c==
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fEqIdent)
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=2 -}
a17da36e36d8f11358e0471418086912
  $s$fEqQualified_$s$fEqQualified_$c/= ::
    Language.PureScript.Names.Qualified
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName)
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U,U,U))><S(SL),1*U(1*U,1*U(U,U,U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                   (y :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName)) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ (Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.ClassName)
                        (Language.PureScript.Names.$fEqProperName
                           @ 'Language.PureScript.Names.ClassName)
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0d91e322207df7c30edeba510b67bc3a
  $s$fEqQualified_$s$fEqQualified_$c/=1 ::
    Language.PureScript.Names.Qualified
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName)
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U,U,U))><S(SL),1*U(1*U,1*U(U,U,U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName))
                   (y :: Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName)) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ (Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.TypeName)
                        (Language.PureScript.Names.$fEqProperName
                           @ 'Language.PureScript.Names.TypeName)
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a17bd11be04ffaf77c9e132d1610d0ea
  $s$fEqQualified_$s$fEqQualified_$c/=2 ::
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                   (y :: Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident) ->
                 case Language.PureScript.Names.$fEqQualified_$c==
                        @ Language.PureScript.Names.Ident
                        Language.PureScript.Names.$fEqIdent
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7d98682eea8d3e5161a99e3747b4ba06
  $s$fOrdMaybe ::
    GHC.Classes.Ord
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                  Language.PureScript.TypeChecker.Monad.$s$fEqMaybe
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.EQ
                          GHC.Base.Just ipv -> GHC.Types.LT }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.GT
                          GHC.Base.Just b1
                          -> GHC.Classes.$fOrd[]_$ccompare
                               @ (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.Namespace)
                               (Language.PureScript.Names.$fOrdProperName
                                  @ 'Language.PureScript.Names.Namespace)
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> Language.PureScript.Names.$fOrdModuleName6
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case b of wild {
                     GHC.Base.Nothing
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a2
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case b of wild {
                     GHC.Base.Nothing
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case a1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1
                          -> Language.PureScript.Names.$fOrdModuleName6
                               a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                               b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } })
                  (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } })
                  (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case y of wild {
                     GHC.Base.Nothing -> x
                     GHC.Base.Just a1
                     -> case x of wild1 {
                          GHC.Base.Nothing -> wild
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> wild GHC.Types.LT -> wild1 } } })
                  (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                     (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                   case y of wild {
                     GHC.Base.Nothing
                     -> case x of wild1 { DEFAULT ->
                        GHC.Base.Nothing @ Language.PureScript.Names.ModuleName }
                     GHC.Base.Just a1
                     -> case x of wild1 {
                          GHC.Base.Nothing
                          -> GHC.Base.Nothing @ Language.PureScript.Names.ModuleName
                          GHC.Base.Just b1
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.Namespace)
                                    (Language.PureScript.Names.$fOrdProperName
                                       @ 'Language.PureScript.Names.Namespace)
                                    a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                    b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                               DEFAULT -> wild1 GHC.Types.LT -> wild } } }) -}
030851f69ec711932f883856a0f9e752
  $s$fOrdMaybe_$c< ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> Language.PureScript.Names.$fOrdModuleName6
                             a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                             b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } }) -}
88214454c2674babd0f30ceeba826bf3
  $s$fOrdMaybe_$ccompare ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (b :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.EQ
                        GHC.Base.Just ipv -> GHC.Types.LT }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.GT
                        GHC.Base.Just b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.Namespace)
                             (Language.PureScript.Names.$fOrdProperName
                                @ 'Language.PureScript.Names.Namespace)
                             a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                             b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) } }) -}
c619f2b887e0947eb2a2674350fcec8e
  $s$fOrdMaybe_$cmax ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (y :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 case y of wild {
                   GHC.Base.Nothing -> x
                   GHC.Base.Just a1
                   -> case x of wild1 {
                        GHC.Base.Nothing -> wild
                        GHC.Base.Just b1
                        -> case GHC.Classes.$fOrd[]_$ccompare
                                  @ (Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.Namespace)
                                  (Language.PureScript.Names.$fOrdProperName
                                     @ 'Language.PureScript.Names.Namespace)
                                  a1 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                  b1 `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                             DEFAULT -> wild GHC.Types.LT -> wild1 } } }) -}
82feb828d45096b2c279b06cbdbca925
  $s$fOrdQualified ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName))
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName))
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.ClassName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.ClassName)
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.ClassName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.ClassName)
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
ef18323dae6f2e8e312f79df0d2495f8
  $s$fOrdQualified1 ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName))
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified1
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName))
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName))
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ (Language.PureScript.Names.ProperName
                          'Language.PureScript.Names.TypeName)
                     (Language.PureScript.Names.$fOrdProperName
                        @ 'Language.PureScript.Names.TypeName)
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName))
                     (b :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName))
                     (y :: Language.PureScript.Names.Qualified
                             (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.TypeName)) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)
                          (Language.PureScript.Names.$fOrdProperName
                             @ 'Language.PureScript.Names.TypeName)
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
f318b593cb454018ede2becff1480918
  $s$fOrdQualified2 ::
    GHC.Classes.Ord
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.PureScript.Names.Qualified
                       Language.PureScript.Names.Ident)
                  Language.PureScript.TypeChecker.Monad.$s$fEqQualified2
                  (Language.PureScript.Names.$fOrdQualified_$ccompare
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent)
                  (Language.PureScript.Names.$fOrdQualified_$c<
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   Language.PureScript.Names.$fOrdQualified_$c<
                     @ Language.PureScript.Names.Ident
                     Language.PureScript.Names.$fOrdIdent
                     b
                     a1)
                  (\ (a1 :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                     (b :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident)
                     (y :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident)
                     (y :: Language.PureScript.Names.Qualified
                             Language.PureScript.Names.Ident) ->
                   case Language.PureScript.Names.$fOrdQualified_$c<
                          @ Language.PureScript.Names.Ident
                          Language.PureScript.Names.$fOrdIdent
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
0f6d012f876ac29f586acfc21715f1c7
  $sfromList ::
    [(Language.PureScript.Names.Qualified
        Language.PureScript.Names.Ident,
      a)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
  {- Arity: 1, Strictness: <S,1*U> -}
eba2d37bf3920784a3db1a3f6da5d2f7
  $sfromList1 ::
    [(Language.PureScript.Names.Qualified
        (Language.PureScript.Names.ProperName
           'Language.PureScript.Names.TypeName),
      a)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
  {- Arity: 1, Strictness: <S,1*U> -}
f9f4f8b5f98fd17a8c79ae57650e2852
  $sinsertWithKey_$sgo13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
                  (Language.PureScript.Names.Qualified
                     Language.PureScript.Names.Ident)))))
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
                  (Language.PureScript.Names.Qualified
                     Language.PureScript.Names.Ident))))
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> GHC.Classes.Ord
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) =>
       Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               (GHC.Base.NonEmpty
                  Language.PureScript.TypeClassDictionaries.NamedDict)))
  {- Arity: 4,
     Strictness: <S,1*U><L,U><S,1*U><L,U(A,C(C1(U)),A,A,A,A,A,A)> -}
15cdd4fdcf28a79df3d81383a47de1ab
  $slookup7 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ds1 :: Data.Map.Internal.Map
                             (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a) ->
                 case ds of ds2 { DEFAULT ->
                 case ds1 of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ds2 of wild1 {
                        GHC.Base.Nothing
                        -> case ipv1 of wild2 {
                             GHC.Base.Nothing -> GHC.Base.Just @ a ipv2
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go1
                                  @ a
                                  ipv3 }
                        GHC.Base.Just a2
                        -> case ipv1 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                  @ a
                                  ipv4
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                       @ a
                                       ipv3
                                       a2
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
                                       @ a
                                       ipv4
                                       a2 } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a } }) -}
5ef131244b9ac0ed85f98f979d47629f
  $slookup_$s$wpoly_go1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Language.PureScript.Names.Ident -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
2f23ec0955e3ead92140cbfa61a7e6d7
  $slookup_$s$wpoly_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Language.PureScript.Names.Ident
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
c48ab5492ee67a4bc7cc0f85c6bc9516
  $slookup_$s$wpoly_go2 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind
         (Language.PureScript.AST.SourcePos.SourceSpan,
          [Language.PureScript.Comments.Comment]),
       Language.PureScript.Environment.TypeKind)
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe
         (Language.PureScript.Kinds.SourceKind,
          Language.PureScript.Environment.TypeKind)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
252293f74b66ca89e24cc79ad561b742
  $slookup_$s$wpoly_go3 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind
         (Language.PureScript.AST.SourcePos.SourceSpan,
          [Language.PureScript.Comments.Comment]),
       Language.PureScript.Environment.TypeKind)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName :: *)) =>
       Language.PureScript.Names.ModuleName
       -> GHC.Base.Maybe
            (Language.PureScript.Kinds.SourceKind,
             Language.PureScript.Environment.TypeKind)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U> -}
d63029b08652513e05e4b840e45301c1
  $slookup_$s$wpoly_go5 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
547284f7132487273ebf3c3b0ebea697
  $slookup_$s$wpoly_go6 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U,U)> -}
ee802350335ae64fe41474cfd4c55bd0
  $slookup_$s$wpoly_go7 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      a
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName :: *)) =>
       GHC.Base.Maybe a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U> -}
404d3711f4cb22ece25b1de0e83bcbdb
  $slookup_$spoly_go1 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> GHC.Base.Maybe a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
998bb87e687eda30933e28e6d54b78f1
  $slookup_$spoly_go13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Language.PureScript.Names.ModuleName -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
4e561d486fc912725270765649fae7f1
  $smember_$s$wpoly_go1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind
         (Language.PureScript.AST.SourcePos.SourceSpan,
          [Language.PureScript.Comments.Comment]),
       Language.PureScript.Environment.TypeKind)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ((Data.Text.Internal.Text :: *)
        ~R# (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName :: *)) =>
       Language.PureScript.Names.ModuleName -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U> -}
1dfdad4ed213635c51a02faf1cffdc11
  $smember_$s$wpoly_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.Kind
         (Language.PureScript.AST.SourcePos.SourceSpan,
          [Language.PureScript.Comments.Comment]),
       Language.PureScript.Environment.TypeKind)
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName
    -> Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U)><L,U> -}
6a151703ede39092e27ba9cc03e5ef6d
  $sunion ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.TypeName))
         a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
c57d320641e48463e3434b7e5998253f
  $sunion1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
c719030bd1b6b569361d749e1e859a9d
  $sunionWith ::
    (a -> a -> a)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
36bcaa3555e04d3e74ee5ff0e2c8dacc
  $sunionWith1 ::
    (a -> a -> a)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
eb9652de9f051ec50cec4abdcfaa13ad
  $sunionWith2 ::
    (a -> a -> a)
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
70845bfa185c48d6375f310485321df9
  $tc'CheckState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18355879979369724534##
                   15599978113964073718##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState2
                   0#
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState1) -}
d2cc81cc4faa95e4a7af49ad8259806e
  $tc'CheckState1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fee9e4322751ef42e1ffcb65c47381a6
  $tc'CheckState2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tc'CheckState3) -}
526890cc93c67de75a587e8dc1a34852
  $tc'CheckState3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CheckState"#) -}
14ca80e7fd5758506911bdc2d30a0247
  $tc'Substitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12468847607280250357##
                   14882254057156527159##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution2
                   0#
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution1) -}
132c9777cf534a8d69be2674f8c30766
  $tc'Substitution1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
629972ab56a2487370e642529343dc69
  $tc'Substitution2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tc'Substitution3) -}
7ca9ed4de4d31b3aa902c227c9d52401
  $tc'Substitution3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Substitution"#) -}
5105e7caa43529815daa9bb128f7be4e
  $tcCheckState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10607928417126862108##
                   17545318933733252518##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tcCheckState1
                   0#
                   GHC.Types.krep$*) -}
1c2559fa8c4c7b63f25622ebd8d8cea3
  $tcCheckState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tcCheckState2) -}
108486fd885a6f04d284179304464c08
  $tcCheckState2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CheckState"#) -}
4d468c5e9c11c0e0e1b3b2a138b69e27
  $tcSubstitution :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14000694807932694739##
                   17397713771255722725##
                   Language.PureScript.TypeChecker.Monad.$trModule
                   Language.PureScript.TypeChecker.Monad.$tcSubstitution1
                   0#
                   GHC.Types.krep$*) -}
172bbd4b7e4d191395550f21e090aca5
  $tcSubstitution1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$tcSubstitution2) -}
376c9e1b2a55aa7b2c9f8540e6bde742
  $tcSubstitution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Substitution"#) -}
99c146338f4b54a44e1b18b603b64984
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.Monad.$trModule3
                   Language.PureScript.TypeChecker.Monad.$trModule1) -}
bfdf9f09d6f694609bb1a4899a3ba943
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$trModule2) -}
32aa02cabfbde62c0140bbaba64219d4
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.Monad"#) -}
45e547d9722c68b52e9c03e7e14038d4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Monad.$trModule4) -}
d0fb27b0101edb6c3e54d0d962e2bbc5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
ac3d310170305ff579e2e5d776c410b3
  $wcheckVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Ident -> m ()
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ e
                   @ m :: * -> *
                   (w :: (e :: *)
                         Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   (w1 :: Control.Monad.State.Class.MonadState
                            Language.PureScript.TypeChecker.Monad.CheckState m)
                   (w2 :: Control.Monad.Error.Class.MonadError e m)
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.Ident) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        w `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       w1
                 } in
                 let {
                   lvl29 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   lvl30 :: m ()
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       w2 `cast` (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ ()
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.CycleInDeclaration ww1))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.NameVisibility
                   @ ()
                   (Language.PureScript.TypeChecker.Monad.getVisibility
                      @ Language.PureScript.Errors.MultipleErrors
                      @ m
                      (GHC.Types.Eq#
                         @ *
                         @ *
                         @ Language.PureScript.Errors.MultipleErrors
                         @ Language.PureScript.Errors.MultipleErrors
                         @~ <Language.PureScript.Errors.MultipleErrors>_N)
                        `cast`
                      (Sym (Data.Type.Equality.N:~[0]
                                <*>_N) <Language.PureScript.Errors.MultipleErrors>_N <Language.PureScript.Errors.MultipleErrors>_N)
                      w1
                      w2 `cast` (Control.Monad.Error.Class.MonadError co <m>_N)_R
                      (Language.PureScript.Names.Qualified
                         @ Language.PureScript.Names.Ident
                         ww
                         ww1))
                   (\ (vis :: Language.PureScript.Environment.NameVisibility) ->
                    case vis of wild {
                      Language.PureScript.Environment.Undefined -> lvl30
                      Language.PureScript.Environment.Defined -> lvl29 }) }) -}
f88793025618ecff4aa4214ca495eb2c
  $wpoly_go13 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Ident
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.Ident)
                   (w :: Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           a) ->
                 case w of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ipv1 of ww3 { Language.PureScript.Names.Qualified ww4 ww5 ->
                      case ww of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> case Language.PureScript.Names.$fOrdIdent_$ccompare
                                       ww1
                                       ww5 of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                       @ a
                                       ipv3
                                       ww1
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                       @ a
                                       ipv4
                                       ww1 }
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
                                  @ a
                                  ipv3
                                  ww1 }
                        GHC.Base.Just a2
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                  @ a
                                  ipv4
                                  ww1
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                       @ a
                                       ipv3
                                       ww1
                                       a2
                                  GHC.Types.EQ
                                  -> case Language.PureScript.Names.$fOrdIdent_$ccompare
                                            ww1
                                            ww5 of wild4 {
                                       GHC.Types.LT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                            @ a
                                            ipv3
                                            ww1
                                            a2
                                       GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                       GHC.Types.GT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                            @ a
                                            ipv4
                                            ww1
                                            a2 }
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
                                       @ a
                                       ipv4
                                       ww1
                                       a2 } } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a }) -}
069557df1a09c3288f4be051779ab4a6
  $wpoly_go2 ::
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ClassName
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U(U,U,U)><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (ww1 :: Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.ClassName)
                   (w :: Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                           a) ->
                 case w of wild {
                   Data.Map.Internal.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ipv1 of ww3 { Language.PureScript.Names.Qualified ww4 ww5 ->
                      case ww of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> case ww1
                                       `cast`
                                     (Language.PureScript.Names.N:ProperName[0]
                                          <'Language.PureScript.Names.ClassName>_P) of ww2 { Data.Text.Internal.Text ww6 ww7 ww8 ->
                                case ww5
                                       `cast`
                                     (Language.PureScript.Names.N:ProperName[0]
                                          <'Language.PureScript.Names.ClassName>_P) of ww9 { Data.Text.Internal.Text ww10 ww11 ww12 ->
                                case Data.Text.$w$ccompare ww6 ww7 ww8 ww10 ww11 ww12 of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
                                       @ a
                                       ipv3
                                       ww6
                                       ww7
                                       ww8
                                       @~ (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.ClassName>_P))
                                  GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
                                       @ a
                                       ipv4
                                       ww6
                                       ww7
                                       ww8
                                       @~ (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.ClassName>_P)) } } }
                             GHC.Base.Just ipv7
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go6
                                  @ a
                                  ipv3
                                  ww1 }
                        GHC.Base.Just a2
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                  @ a
                                  ipv4
                                  ww1
                                  a2
                             GHC.Base.Just b1
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.Namespace)
                                       (Language.PureScript.Names.$fOrdProperName
                                          @ 'Language.PureScript.Names.Namespace)
                                       a2 `cast` (Language.PureScript.Names.N:ModuleName[0])
                                       b1
                                         `cast`
                                       (Language.PureScript.Names.N:ModuleName[0]) of wild3 {
                                  GHC.Types.LT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                       @ a
                                       ipv3
                                       ww1
                                       a2
                                  GHC.Types.EQ
                                  -> case ww1
                                            `cast`
                                          (Language.PureScript.Names.N:ProperName[0]
                                               <'Language.PureScript.Names.ClassName>_P) of ww2 { Data.Text.Internal.Text ww6 ww7 ww8 ->
                                     case ww5
                                            `cast`
                                          (Language.PureScript.Names.N:ProperName[0]
                                               <'Language.PureScript.Names.ClassName>_P) of ww9 { Data.Text.Internal.Text ww10 ww11 ww12 ->
                                     case Data.Text.$w$ccompare
                                            ww6
                                            ww7
                                            ww8
                                            ww10
                                            ww11
                                            ww12 of wild4 {
                                       GHC.Types.LT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                            @ a
                                            ipv3
                                            ww2
                                              `cast`
                                            (Sym (Language.PureScript.Names.N:ProperName[0]
                                                      <'Language.PureScript.Names.ClassName>_P))
                                            a2
                                       GHC.Types.EQ -> GHC.Base.Just @ a ipv2
                                       GHC.Types.GT
                                       -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                            @ a
                                            ipv4
                                            ww2
                                              `cast`
                                            (Sym (Language.PureScript.Names.N:ProperName[0]
                                                      <'Language.PureScript.Names.ClassName>_P))
                                            a2 } } }
                                  GHC.Types.GT
                                  -> Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
                                       @ a
                                       ipv4
                                       ww1
                                       a2 } } } }
                   Data.Map.Internal.Tip -> GHC.Base.Nothing @ a }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  data CheckState
    = CheckState {checkEnv :: Language.PureScript.Environment.Environment,
                  checkNextType :: GHC.Types.Int,
                  checkNextKind :: GHC.Types.Int,
                  checkNextSkolem :: GHC.Types.Int,
                  checkNextSkolemScope :: GHC.Types.Int,
                  checkCurrentModule :: GHC.Base.Maybe
                                          Language.PureScript.Names.ModuleName,
                  checkSubstitution :: Language.PureScript.TypeChecker.Monad.Substitution,
                  checkHints :: [Language.PureScript.AST.Declarations.ErrorMessageHint]}
6dc37f96b1ad41d81e906d34e56bda73
  data Substitution
    = Substitution {substType :: Data.Map.Internal.Map
                                   GHC.Types.Int Language.PureScript.Types.SourceType,
                    substKind :: Data.Map.Internal.Map
                                   GHC.Types.Int Language.PureScript.Kinds.SourceKind}
028897d769a6e3f1725285ae2a682928
  type Unknown = GHC.Types.Int
4279c05238f284a784d5ffc5c8b120e7
  bindLocalTypeVariables ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Names.ModuleName
    -> [(Language.PureScript.Names.ProperName
           'Language.PureScript.Names.TypeName,
         Language.PureScript.Kinds.SourceKind)]
    -> m a
    -> m a
  {- Arity: 3,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U><L,1*U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (moduleName :: Language.PureScript.Names.ModuleName)
                   (bindings :: [(Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.TypeName,
                                  Language.PureScript.Kinds.SourceKind)]) ->
                 Language.PureScript.TypeChecker.Monad.bindTypes
                   @ m
                   @ a
                   $dMonadState
                   (let {
                      lvl29 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName
                      = GHC.Base.Just @ Language.PureScript.Names.ModuleName moduleName
                    } in
                    Language.PureScript.TypeChecker.Monad.$sfromList1
                      @ (Language.PureScript.Kinds.SourceKind,
                         Language.PureScript.Environment.TypeKind)
                      (GHC.Base.map
                         @ (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.TypeName,
                            Language.PureScript.Kinds.SourceKind)
                         @ (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName),
                            (Language.PureScript.Kinds.SourceKind,
                             Language.PureScript.Environment.TypeKind))
                         (\ (ds :: (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.TypeName,
                                    Language.PureScript.Kinds.SourceKind)) ->
                          case ds of wild { (,) pn kind ->
                          (Language.PureScript.Names.Qualified
                             @ (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.TypeName)
                             lvl29
                             pn,
                           (kind, Language.PureScript.Environment.LocalTypeVariable)) })
                         bindings))) -}
d3d61817e30c6d14fa74cb55dc1b127f
  bindLocalVariables ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    [(Language.PureScript.Names.Ident,
      Language.PureScript.Types.SourceType,
      Language.PureScript.Environment.NameVisibility)]
    -> m a -> m a
  {- Arity: 2,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (bindings :: [(Language.PureScript.Names.Ident,
                                  Language.PureScript.Types.SourceType,
                                  Language.PureScript.Environment.NameVisibility)]) ->
                 Language.PureScript.TypeChecker.Monad.bindNames
                   @ m
                   @ a
                   $dMonadState
                   (Language.PureScript.TypeChecker.Monad.$sfromList
                      @ (Language.PureScript.Types.SourceType,
                         Language.PureScript.Environment.NameKind,
                         Language.PureScript.Environment.NameVisibility)
                      (GHC.Base.build
                         @ (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident,
                            (Language.PureScript.Types.SourceType,
                             Language.PureScript.Environment.NameKind,
                             Language.PureScript.Environment.NameVisibility))
                         (\ @ b1
                            (c :: (Language.PureScript.Names.Qualified
                                     Language.PureScript.Names.Ident,
                                   (Language.PureScript.Types.SourceType,
                                    Language.PureScript.Environment.NameKind,
                                    Language.PureScript.Environment.NameVisibility))
                                  -> b1 -> b1)[OneShot]
                            (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ (Language.PureScript.Names.Ident,
                               Language.PureScript.Types.SourceType,
                               Language.PureScript.Environment.NameVisibility)
                            @ b1
                            (GHC.Base.mapFB
                               @ (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident,
                                  (Language.PureScript.Types.SourceType,
                                   Language.PureScript.Environment.NameKind,
                                   Language.PureScript.Environment.NameVisibility))
                               @ b1
                               @ (Language.PureScript.Names.Ident,
                                  Language.PureScript.Types.SourceType,
                                  Language.PureScript.Environment.NameVisibility)
                               c
                               Language.PureScript.TypeChecker.Monad.bindLocalVariables1)
                            n
                            bindings)))) -}
47f54c8b237b73b5953802063e938750
  bindLocalVariables1 ::
    (Language.PureScript.Names.Ident,
     Language.PureScript.Types.SourceType,
     Language.PureScript.Environment.NameVisibility)
    -> (Language.PureScript.Names.Qualified
          Language.PureScript.Names.Ident,
        (Language.PureScript.Types.SourceType,
         Language.PureScript.Environment.NameKind,
         Language.PureScript.Environment.NameVisibility))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.PureScript.Names.Ident,
                           Language.PureScript.Types.SourceType,
                           Language.PureScript.Environment.NameVisibility)) ->
                 case ds of wild { (,,) name ty visibility ->
                 (Language.PureScript.Names.Qualified
                    @ Language.PureScript.Names.Ident
                    (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                    name,
                  (ty, Language.PureScript.Environment.Private, visibility)) }) -}
cec978aa2d75cee2ffee6b227b8740ed
  bindNames ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      (Language.PureScript.Types.SourceType,
       Language.PureScript.Environment.NameKind,
       Language.PureScript.Environment.NameVisibility)
    -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Data.Map.Internal.Map
                             (Language.PureScript.Names.Qualified
                                Language.PureScript.Names.Ident)
                             (Language.PureScript.Types.SourceType,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility))
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              (Language.PureScript.TypeChecker.Monad.$sunion1
                                 @ (Language.PureScript.Types.SourceType,
                                    Language.PureScript.Environment.NameKind,
                                    Language.PureScript.Environment.NameVisibility)
                                 eta
                                 ds8)
                              ds9
                              ds10
                              ds11
                              ds12
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           Language.PureScript.Names.Ident)
                                        (Language.PureScript.Types.SourceType,
                                         Language.PureScript.Environment.NameKind,
                                         Language.PureScript.Environment.NameVisibility)
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds8 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    lvl31
                                    ds9
                                    ds10
                                    ds11
                                    ds12
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
dd91a14f9b244064796c050693047d4f
  bindTypes ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName))
      (Language.PureScript.Kinds.SourceKind,
       Language.PureScript.Environment.TypeKind)
    -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Data.Map.Internal.Map
                             (Language.PureScript.Names.Qualified
                                (Language.PureScript.Names.ProperName
                                   'Language.PureScript.Names.TypeName))
                             (Language.PureScript.Kinds.SourceKind,
                              Language.PureScript.Environment.TypeKind))
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              ds8
                              (Language.PureScript.TypeChecker.Monad.$sunion
                                 @ (Language.PureScript.Kinds.SourceKind,
                                    Language.PureScript.Environment.TypeKind)
                                 eta
                                 ds9)
                              ds10
                              ds11
                              ds12
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           (Language.PureScript.Names.ProperName
                                              'Language.PureScript.Names.TypeName))
                                        (Language.PureScript.Kinds.SourceKind,
                                         Language.PureScript.Environment.TypeKind)
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds9 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    ds8
                                    lvl31
                                    ds10
                                    ds11
                                    ds12
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
cee45a72eb61672224a0779e05d02a52
  captureSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m (a, Language.PureScript.TypeChecker.Monad.Substitution)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(A,C(C1(U)),A,C(U),A),U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 Language.PureScript.TypeChecker.Monad.capturingSubstitution
                   @ m
                   @ a
                   @ (a, Language.PureScript.TypeChecker.Monad.Substitution)
                   $dMonadState
                   (GHC.Tuple.(,)
                      @ a
                      @ Language.PureScript.TypeChecker.Monad.Substitution)) -}
40acdbe38860b70b451bd591b4f7215f
  capturingSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    (a -> Language.PureScript.TypeChecker.Monad.Substitution -> b)
    -> m a -> m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),A,C(U),A),1*U,A,A)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ b
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: a
                           -> Language.PureScript.TypeChecker.Monad.Substitution -> b)
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m Language.PureScript.TypeChecker.Monad.Substitution
                   = GHC.Base.>>=
                       @ m
                       $dMonad
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ Language.PureScript.TypeChecker.Monad.Substitution
                       (Control.Monad.State.Class.get
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState)
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        GHC.Base.return
                          @ m
                          $dMonad
                          @ Language.PureScript.TypeChecker.Monad.Substitution
                          (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           ds6 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ a
                   @ b
                   eta1
                   (\ (a1 :: a) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.Substitution
                      @ b
                      lvl29
                      (\ (subst :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                       GHC.Base.return @ m $dMonad @ b (eta a1 subst)))) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkCurrentModule ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> GHC.Base.Maybe Language.PureScript.Names.ModuleName
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),1*U(A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds6 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkEnv ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Environment.Environment
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLL),1*U(1*U(U,U,U,U,U,U,U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds1 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkHints ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> [Language.PureScript.AST.Declarations.ErrorMessageHint]
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),1*U(A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds8 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextKind ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),1*U(A,A,1*U(U),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds3 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextSkolem ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),1*U(A,A,A,1*U(U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds4 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextSkolemScope ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),1*U(A,A,A,A,1*U(U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds5 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextType ::
    Language.PureScript.TypeChecker.Monad.CheckState -> GHC.Types.Int
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),1*U(A,1*U(U),A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds2 }) -}
9cc3cef00c43c0c2ac24a31e9b521e29
  checkSubstitution ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.TypeChecker.Monad.Substitution
  RecSel Left Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U(U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds7 }) -}
cf16ff61c4446f9bda6bae4524621e38
  checkVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ e
                   @ m :: * -> *
                   (w :: (e :: *)
                         Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   (w1 :: Control.Monad.State.Class.MonadState
                            Language.PureScript.TypeChecker.Monad.CheckState m)
                   (w2 :: Control.Monad.Error.Class.MonadError e m)
                   (w3 :: Language.PureScript.Names.Qualified
                            Language.PureScript.Names.Ident) ->
                 case w3 of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                 Language.PureScript.TypeChecker.Monad.$wcheckVisibility
                   @ e
                   @ m
                   w
                   w1
                   w2
                   ww1
                   ww2 }) -}
702a26b401e2a266972b7fdf9b28e232
  emptyCheckState ::
    Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (env :: Language.PureScript.Environment.Environment) ->
                 Language.PureScript.TypeChecker.Monad.CheckState
                   env
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                   Language.PureScript.TypeChecker.Monad.emptySubstitution
                   (GHC.Types.[]
                      @ Language.PureScript.AST.Declarations.ErrorMessageHint)) -}
e6213dae2ee5dc748e8a7defc5a0ea6a
  emptyCheckState1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
d30b061696cff17c025817e53ed3da58
  emptySubstitution ::
    Language.PureScript.TypeChecker.Monad.Substitution
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Language.PureScript.TypeChecker.Monad.Substitution
                   (Data.Map.Internal.Tip
                      @ GHC.Types.Int
                      @ Language.PureScript.Types.SourceType)
                   (Data.Map.Internal.Tip
                      @ GHC.Types.Int
                      @ Language.PureScript.Kinds.SourceKind)) -}
69aa315a68211d8605a99340dd649d82
  getEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.Environment.Environment
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ Language.PureScript.Environment.Environment
                   Language.PureScript.TypeChecker.Monad.checkEnv
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
bbecaeac63bedc9e4f131a49eb366479
  getHints ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m [Language.PureScript.AST.Declarations.ErrorMessageHint]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ [Language.PureScript.AST.Declarations.ErrorMessageHint]
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ [Language.PureScript.AST.Declarations.ErrorMessageHint]
                      (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       GHC.List.reverse1
                         @ Language.PureScript.AST.Declarations.ErrorMessageHint
                         ds7
                         (GHC.Types.[]
                            @ Language.PureScript.AST.Declarations.ErrorMessageHint) }))) -}
223085abf14117e3398e0e666d63e54f
  getLocalContext ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.AST.Declarations.Context
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,C(U),A),U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.AST.Declarations.Context
                   (Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState)
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ [(Language.PureScript.Names.Ident,
                          Language.PureScript.Types.SourceType)]
                      (case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       Language.PureScript.TypeChecker.Monad.getLocalContext_go13
                         (GHC.Types.[]
                            @ (Language.PureScript.Names.Ident,
                               Language.PureScript.Types.SourceType))
                         ds1 }))) -}
a1a1264e24d6f5f5da0e780548bdd0b7
  getLocalContext_go13 ::
    [(Language.PureScript.Names.Ident,
      Language.PureScript.Types.SourceType)]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (Language.PureScript.Types.SourceType,
          Language.PureScript.Environment.NameKind,
          Language.PureScript.Environment.NameVisibility)
    -> [(Language.PureScript.Names.Ident,
         Language.PureScript.Types.SourceType)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
299df08a9844c25fa62c56a713d7ba37
  getTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m (Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               (GHC.Base.NonEmpty
                  Language.PureScript.TypeClassDictionaries.NamedDict))))
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ (Data.Map.Internal.Map
                        (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName))
                           (Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 Language.PureScript.Names.Ident)
                              (GHC.Base.NonEmpty
                                 Language.PureScript.TypeClassDictionaries.NamedDict))))
                   Language.PureScript.TypeChecker.Monad.getTypeClassDictionaries1
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
2e20316b99808b3986c4f3055e500a6f
  getTypeClassDictionaries1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               (GHC.Base.NonEmpty
                  Language.PureScript.TypeClassDictionaries.NamedDict)))
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLLSLL)LLLLLLL),1*U(1*U(A,A,A,A,1*U,A,A),A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 case x of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                 ds12 } }) -}
6dbb2b20f7d8dbe1d19534e103e429fc
  getVisibility ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m Language.PureScript.Environment.NameVisibility
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (qual :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident) ->
                 let {
                   lvl30 :: m Language.PureScript.Environment.NameVisibility
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Environment.NameVisibility
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.NameIsUndefined
                                (case qual of wild { Language.PureScript.Names.Qualified ds1 a1 ->
                                 a1 })))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Environment.NameVisibility
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case qual of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go13
                           @ (Language.PureScript.Types.SourceType,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility)
                           ww1
                           ww2
                           ds1 of wild1 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds
                      -> case ds of wild2 { (,,) ds11 ds12 vis ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Environment.NameVisibility
                           vis } } } }) }) -}
d2b3f12e05a1d4c8c1e59f1c8f3292d4
  guardWith ::
    Control.Monad.Error.Class.MonadError e m =>
    e -> GHC.Types.Bool -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(1*U(A,A,A,1*C1(U),A),1*C1(U),A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ e
                   @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m)
                   (eta :: e)
                   (eta1 :: GHC.Types.Bool) ->
                 case eta1 of wild {
                   GHC.Types.False
                   -> Control.Monad.Error.Class.throwError
                        @ e
                        @ m
                        $dMonadError
                        @ ()
                        eta
                   GHC.Types.True
                   -> GHC.Base.return
                        @ m
                        (Control.Monad.Error.Class.$p1MonadError @ e @ m $dMonadError)
                        @ ()
                        GHC.Tuple.() }) -}
72f4353405ed3f4fb5489909c051e43c
  lookupTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> m (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               (GHC.Base.NonEmpty
                  Language.PureScript.TypeClassDictionaries.NamedDict)))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A),1*U,A,A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: GHC.Base.Maybe Language.PureScript.Names.ModuleName) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           (GHC.Base.NonEmpty
                              Language.PureScript.TypeClassDictionaries.NamedDict)))
                   (\ (x :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    case x of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                    case Language.PureScript.TypeChecker.Monad.$slookup7
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.ClassName))
                                (Data.Map.Internal.Map
                                   (Language.PureScript.Names.Qualified
                                      Language.PureScript.Names.Ident)
                                   (GHC.Base.NonEmpty
                                      Language.PureScript.TypeClassDictionaries.NamedDict)))
                           eta
                           ds12 of wild2 {
                      GHC.Base.Nothing
                      -> Data.Map.Internal.Tip
                           @ (Language.PureScript.Names.Qualified
                                (Language.PureScript.Names.ProperName
                                   'Language.PureScript.Names.ClassName))
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   Language.PureScript.Names.Ident)
                                (GHC.Base.NonEmpty
                                   Language.PureScript.TypeClassDictionaries.NamedDict))
                      GHC.Base.Just v -> v } } })
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)) -}
f828a7aded735803a5224827776bcb64
  lookupTypeClassDictionariesForClass ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName)
    -> m (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(S(C(C(S))L)LLLLL)LLLL)LLL),U(U(U(U(C(C1(U)),A),A,A,A,A,A),A,A,A,A),U,A,A)><L,U><L,U(U,U(U,U,U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                   (eta1 :: Language.PureScript.Names.Qualified
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.ClassName)) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.State.Class.$p1MonadState
                            @ Language.PureScript.TypeChecker.Monad.CheckState
                            @ m
                            $dMonadState)))
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           (Language.PureScript.Names.ProperName
                              'Language.PureScript.Names.ClassName))
                        (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           (GHC.Base.NonEmpty
                              Language.PureScript.TypeClassDictionaries.NamedDict)))
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        (GHC.Base.NonEmpty
                           Language.PureScript.TypeClassDictionaries.NamedDict))
                   (\ (x :: Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 (Language.PureScript.Names.ProperName
                                    'Language.PureScript.Names.ClassName))
                              (Data.Map.Internal.Map
                                 (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident)
                                 (GHC.Base.NonEmpty
                                    Language.PureScript.TypeClassDictionaries.NamedDict))) ->
                    case eta1 of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go2
                           @ (Data.Map.Internal.Map
                                (Language.PureScript.Names.Qualified
                                   Language.PureScript.Names.Ident)
                                (GHC.Base.NonEmpty
                                   Language.PureScript.TypeClassDictionaries.NamedDict))
                           ww1
                           ww2
                           x of wild {
                      GHC.Base.Nothing
                      -> Data.Map.Internal.Tip
                           @ (Language.PureScript.Names.Qualified
                                Language.PureScript.Names.Ident)
                           @ (GHC.Base.NonEmpty
                                Language.PureScript.TypeClassDictionaries.NamedDict)
                      GHC.Base.Just v -> v } })
                   (Language.PureScript.TypeChecker.Monad.lookupTypeClassDictionaries
                      @ m
                      $dMonadState
                      eta)) -}
1a21a6dd4b005eb084941ab698608c7b
  lookupTypeVariable ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
    -> m Language.PureScript.Kinds.SourceKind
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (currentModule :: Language.PureScript.Names.ModuleName)
                   (ds :: Language.PureScript.Names.Qualified
                            (Language.PureScript.Names.ProperName
                               'Language.PureScript.Names.TypeName)) ->
                 case ds of wild { Language.PureScript.Names.Qualified moduleName name ->
                 let {
                   lvl30 :: m Language.PureScript.Kinds.SourceKind
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Kinds.SourceKind
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.UndefinedTypeVariable name))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 let {
                   lvl31 :: Language.PureScript.Names.ModuleName
                   = case moduleName of wild1 {
                       GHC.Base.Nothing -> currentModule GHC.Base.Just v -> v }
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Kinds.SourceKind
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case env of wild1 { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go2
                           ds2
                           name
                           lvl31 of wild2 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds11
                      -> case ds11 of wild3 { (,) k ds12 ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Kinds.SourceKind
                           k } } }) } }) -}
e5ee90a12677ea7029a891b4e37ff4df
  lookupVariable ::
    ((e :: *)
     Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *),
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError e m) =>
    Language.PureScript.Names.Qualified Language.PureScript.Names.Ident
    -> m Language.PureScript.Types.SourceType
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,C(U),A),U,A,A)><L,U(A,C(U),A)>,
     Unfolding: (\ @ e
                   @ m :: * -> *
                   ($d~ :: (e :: *)
                           Data.Type.Equality.~ (Language.PureScript.Errors.MultipleErrors :: *))
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError e m) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ e
                        @ Language.PureScript.Errors.MultipleErrors
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <e>_N <Language.PureScript.Errors.MultipleErrors>_N) of co { DEFAULT ->
                 let {
                   lvl29 :: m Language.PureScript.Environment.Environment
                   = Language.PureScript.TypeChecker.Monad.getEnv @ m $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 \ (qual :: Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident) ->
                 let {
                   lvl30 :: m Language.PureScript.Types.SourceType
                   = Control.Monad.Error.Class.throwError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                         `cast`
                       (Control.Monad.Error.Class.MonadError co <m>_N)_R
                       @ Language.PureScript.Types.SourceType
                       (GHC.Types.:
                          @ Language.PureScript.AST.Declarations.ErrorMessage
                          (Language.PureScript.AST.Declarations.ErrorMessage
                             (GHC.Types.[]
                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             (Language.PureScript.AST.Declarations.NameIsUndefined
                                (case qual of wild { Language.PureScript.Names.Qualified ds1 a1 ->
                                 a1 })))
                          (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Environment.Environment
                   @ Language.PureScript.Types.SourceType
                   lvl29
                   (\ (env :: Language.PureScript.Environment.Environment) ->
                    case qual of ww { Language.PureScript.Names.Qualified ww1 ww2 ->
                    case env of wild { Language.PureScript.Environment.Environment ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                    case Language.PureScript.TypeChecker.Monad.$wpoly_go13
                           @ (Language.PureScript.Types.SourceType,
                              Language.PureScript.Environment.NameKind,
                              Language.PureScript.Environment.NameVisibility)
                           ww1
                           ww2
                           ds1 of wild1 {
                      GHC.Base.Nothing -> lvl30
                      GHC.Base.Just ds
                      -> case ds of wild2 { (,,) ty ds11 ds12 ->
                         GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Types.SourceType
                           ty } } } }) }) -}
f26d7d5148f07c0c19e39dc15bb01669
  makeBindingGroupVisible ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible1) -}
b1ccfe177562d48a92f23815c078d823
  makeBindingGroupVisible1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> ((), Language.PureScript.TypeChecker.Monad.CheckState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,U,U,U,U,U,U),U,U,U,U,U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 (GHC.Tuple.(),
                  case w of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  Language.PureScript.TypeChecker.Monad.CheckState
                    (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                     Language.PureScript.Environment.Environment
                       (Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible_go13
                          ds8)
                       ds9
                       ds10
                       ds11
                       ds12
                       ds13
                       ds14 })
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7 })) -}
1e1344532c3c9e376658f3f7215956e8
  makeBindingGroupVisible_go13 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      (Language.PureScript.Types.SourceType,
       Language.PureScript.Environment.NameKind,
       Language.PureScript.Environment.NameVisibility)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (Language.PureScript.Types.SourceType,
          Language.PureScript.Environment.NameKind,
          Language.PureScript.Environment.NameVisibility)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
afbc6b07aa67ac6d360aae150935b381
  modifyEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    (Language.PureScript.Environment.Environment
     -> Language.PureScript.Environment.Environment)
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (f1 :: Language.PureScript.Environment.Environment
                          -> Language.PureScript.Environment.Environment) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    (GHC.Tuple.(),
                     case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                     Language.PureScript.TypeChecker.Monad.CheckState
                       (f1 ds)
                       ds1
                       ds2
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7 }))) -}
e905c80e24a9ffccbb94ce955ddb8398
  preservingNames ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        (Language.PureScript.Types.SourceType,
                         Language.PureScript.Environment.NameKind,
                         Language.PureScript.Environment.NameVisibility))
                   @ a
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ (Data.Map.Internal.Map
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)
                           (Language.PureScript.Types.SourceType,
                            Language.PureScript.Environment.NameKind,
                            Language.PureScript.Environment.NameVisibility))
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Data.Map.Internal.Map
                              (Language.PureScript.Names.Qualified
                                 Language.PureScript.Names.Ident)
                              (Language.PureScript.Types.SourceType,
                               Language.PureScript.Environment.NameKind,
                               Language.PureScript.Environment.NameVisibility))
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                          case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                          ds8 } })))
                   (\ (orig :: Data.Map.Internal.Map
                                 (Language.PureScript.Names.Qualified
                                    Language.PureScript.Names.Ident)
                                 (Language.PureScript.Types.SourceType,
                                  Language.PureScript.Environment.NameKind,
                                  Language.PureScript.Environment.NameVisibility)) ->
                    let {
                      lvl29 :: m ()
                      = Control.Monad.State.Class.state
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState
                          @ ()
                          (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                           (GHC.Tuple.(),
                            case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                            Language.PureScript.TypeChecker.Monad.CheckState
                              (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               Language.PureScript.Environment.Environment
                                 orig
                                 ds9
                                 ds10
                                 ds11
                                 ds12
                                 ds13
                                 ds14 })
                              ds1
                              ds2
                              ds3
                              ds4
                              ds5
                              ds6
                              ds7 }))
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ a
                      @ a
                      eta
                      (\ (a1 :: a) ->
                       GHC.Base.>>
                         @ m
                         $dMonad
                         @ ()
                         @ a
                         lvl29
                         (GHC.Base.return @ m $dMonad @ a a1)))) -}
81e626fdbef8a42017f8f358ebf2913f
  putEnv ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Environment.Environment -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (env :: Language.PureScript.Environment.Environment) ->
                 Control.Monad.State.Class.state
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ m
                   $dMonadState
                   @ ()
                   (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    (GHC.Tuple.(),
                     case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                     Language.PureScript.TypeChecker.Monad.CheckState
                       env
                       ds1
                       ds2
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7 }))) -}
e6322f134367ef65b6658cc8367e1f0c
  rethrowWithPositionTC ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.SourcePos.SourceSpan -> m a -> m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,C(U),C(C1(U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   (pos :: Language.PureScript.AST.SourcePos.SourceSpan) ->
                 Language.PureScript.TypeChecker.Monad.withErrorMessageHint
                   @ m
                   @ a
                   $dMonadState
                   $dMonadError
                   (Language.PureScript.Errors.positionedError pos)) -}
af86b60eea198b4ded19ef1fa9b905af
  runCheck ::
    GHC.Base.Functor m =>
    Control.Monad.Trans.State.Lazy.StateT
      Language.PureScript.TypeChecker.Monad.CheckState m a
    -> m (a, Language.PureScript.Environment.Environment)
  {- Arity: 2,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             Language.PureScript.TypeChecker.Monad.CheckState m a) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (a, Language.PureScript.TypeChecker.Monad.CheckState)
                   @ (a, Language.PureScript.Environment.Environment)
                   (Language.PureScript.TypeChecker.Monad.runCheck2 @ a)
                   (eta
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <Language.PureScript.TypeChecker.Monad.CheckState>_N <m>_R <a>_N)
                      Language.PureScript.TypeChecker.Monad.runCheck1)) -}
a85aa9a51f9f809c972072c9aa714394
  runCheck' ::
    GHC.Base.Functor m =>
    Language.PureScript.TypeChecker.Monad.CheckState
    -> Control.Monad.Trans.State.Lazy.StateT
         Language.PureScript.TypeChecker.Monad.CheckState m a
    -> m (a, Language.PureScript.Environment.Environment)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dFunctor :: GHC.Base.Functor m)
                   (st :: Language.PureScript.TypeChecker.Monad.CheckState)
                   (check :: Control.Monad.Trans.State.Lazy.StateT
                               Language.PureScript.TypeChecker.Monad.CheckState m a) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (a, Language.PureScript.TypeChecker.Monad.CheckState)
                   @ (a, Language.PureScript.Environment.Environment)
                   (Language.PureScript.TypeChecker.Monad.runCheck2 @ a)
                   (check
                      `cast`
                    (Control.Monad.Trans.State.Lazy.N:StateT[0]
                         <Language.PureScript.TypeChecker.Monad.CheckState>_N <m>_R <a>_N)
                      st)) -}
ef01dcf906e5d8aeb7a8fb54dbd66b8a
  runCheck1 :: Language.PureScript.TypeChecker.Monad.CheckState
  {- Strictness: m,
     Unfolding: (Language.PureScript.TypeChecker.Monad.CheckState
                   Language.PureScript.Environment.initEnvironment
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   Language.PureScript.TypeChecker.Monad.emptyCheckState1
                   (GHC.Base.Nothing @ Language.PureScript.Names.ModuleName)
                   Language.PureScript.TypeChecker.Monad.emptySubstitution
                   (GHC.Types.[]
                      @ Language.PureScript.AST.Declarations.ErrorMessageHint)) -}
54153471f53e26e86098e7cb56b7cc56
  runCheck2 ::
    (a, Language.PureScript.TypeChecker.Monad.CheckState)
    -> (a, Language.PureScript.Environment.Environment)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U,1*U(1*U,A,A,A,A,A,A,A))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   (ds :: (a, Language.PureScript.TypeChecker.Monad.CheckState)) ->
                 (case ds of wild { (,) x y -> x },
                  case ds of wild { (,) x y ->
                  case y of wild1 { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  ds1 } })) -}
6dc37f96b1ad41d81e906d34e56bda73
  substKind ::
    Language.PureScript.TypeChecker.Monad.Substitution
    -> Data.Map.Internal.Map
         GHC.Types.Int Language.PureScript.Kinds.SourceKind
  RecSel Left Language.PureScript.TypeChecker.Monad.Substitution
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.Substitution ds1 ds2 ->
                 ds2 }) -}
6dc37f96b1ad41d81e906d34e56bda73
  substType ::
    Language.PureScript.TypeChecker.Monad.Substitution
    -> Data.Map.Internal.Map
         GHC.Types.Int Language.PureScript.Types.SourceType
  RecSel Left Language.PureScript.TypeChecker.Monad.Substitution
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.TypeChecker.Monad.Substitution) ->
                 case ds of wild { Language.PureScript.TypeChecker.Monad.Substitution ds1 ds2 ->
                 ds1 }) -}
52783f0f0cdec5b6ee7f6ff28f5a789f
  warnAndRethrowWithPositionTC ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.Writer.Class.MonadWriter
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.SourcePos.SourceSpan -> m a -> m a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,C(U),C(C1(U)))><L,U(A,U(A,C(C1(U)),A,C(U),A),A,A,A,C(U))><L,U(U,U(U(U),U(U)),U(U(U),U(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter
                                       Language.PureScript.Errors.MultipleErrors m)
                   (pos :: Language.PureScript.AST.SourcePos.SourceSpan)
                   (eta :: m a) ->
                 Language.PureScript.TypeChecker.Monad.withErrorMessageHint
                   @ m
                   @ a
                   $dMonadState
                   $dMonadError
                   (Language.PureScript.AST.Declarations.PositionedError
                      (GHC.Base.:|
                         @ Language.PureScript.AST.SourcePos.SourceSpan
                         pos
                         (GHC.Types.[] @ Language.PureScript.AST.SourcePos.SourceSpan)))
                   (Language.PureScript.Errors.warnWithPosition
                      @ m
                      @ a
                      $dMonadWriter
                      pos
                      eta)) -}
f838abdb4c649e2bda552b5c91c16743
  withBindingGroupVisible ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 Language.PureScript.TypeChecker.Monad.preservingNames
                   @ m
                   @ a
                   $dMonadState
                   (GHC.Base.>>
                      @ m
                      (Control.Monad.State.Class.$p1MonadState
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      @ ()
                      @ a
                      (Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         Language.PureScript.TypeChecker.Monad.makeBindingGroupVisible1)
                      eta)) -}
873c4b1b4503ece5c9a614f4d08067e6
  withErrorMessageHint ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.AST.Declarations.ErrorMessageHint -> m a -> m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U(A,C(U),1*C1(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   (eta :: Language.PureScript.AST.Declarations.ErrorMessageHint)
                   (eta1 :: m a) ->
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessageHint
                              eta
                              ds7) }))
                 } in
                 let {
                   lvl30 :: m a
                   = Control.Monad.Error.Class.catchError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                       @ a
                       eta1
                       (\ (x :: Language.PureScript.Errors.MultipleErrors) ->
                        Control.Monad.Error.Class.throwError
                          @ Language.PureScript.Errors.MultipleErrors
                          @ m
                          $dMonadError
                          @ a
                          (Language.PureScript.Errors.addHint1 eta x)
                            `cast`
                          (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl31 :: m ()
                         = let {
                             lvl32 :: [Language.PureScript.AST.Declarations.ErrorMessageHint]
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               ds7 }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 ds
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 lvl32 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         lvl30
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl31
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
284ea6d9c874971bc31a265754a070ff
  withFreshSubstitution ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: m a) ->
                 let {
                   lvl29 :: m ()
                   = Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       Language.PureScript.TypeChecker.Monad.withFreshSubstitution1
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Language.PureScript.TypeChecker.Monad.Substitution
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               ds6 }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 ds
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 lvl31
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
9350c80bda4fcfb762034801de7c4f01
  withFreshSubstitution1 ::
    Language.PureScript.TypeChecker.Monad.CheckState
    -> ((), Language.PureScript.TypeChecker.Monad.CheckState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                 (GHC.Tuple.(),
                  case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  Language.PureScript.TypeChecker.Monad.CheckState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    Language.PureScript.TypeChecker.Monad.emptySubstitution
                    ds7 })) -}
a0453ee66ce276d2444e395405e450c4
  withScopedTypeVars ::
    (Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m,
     Control.Monad.Writer.Class.MonadWriter
       Language.PureScript.Errors.MultipleErrors m) =>
    Language.PureScript.Names.ModuleName
    -> [(Data.Text.Internal.Text,
         Language.PureScript.Kinds.SourceKind)]
    -> m a
    -> m a
  {- Arity: 2,
     Strictness: <L,U(U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U(A,A,A,C(U),A,A)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter
                                       Language.PureScript.Errors.MultipleErrors m) ->
                 let {
                   lvl29 :: m Language.PureScript.TypeChecker.Monad.CheckState
                   = Control.Monad.State.Class.get
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl30 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   lvl31 :: m ()
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad @ m $dMonad)
                       @ ()
                       GHC.Tuple.()
                 } in
                 \ (mn :: Language.PureScript.Names.ModuleName)
                   (ks :: [(Data.Text.Internal.Text,
                            Language.PureScript.Kinds.SourceKind)])
                   (ma :: m a) ->
                 let {
                   lvl32 :: m a
                   = Language.PureScript.TypeChecker.Monad.bindTypes
                       @ m
                       @ a
                       $dMonadState
                       (let {
                          lvl33 :: GHC.Base.Maybe Language.PureScript.Names.ModuleName
                          = GHC.Base.Just @ Language.PureScript.Names.ModuleName mn
                        } in
                        Language.PureScript.TypeChecker.Monad.$sfromList1
                          @ (Language.PureScript.Kinds.SourceKind,
                             Language.PureScript.Environment.TypeKind)
                          (GHC.Base.map
                             @ (Data.Text.Internal.Text, Language.PureScript.Kinds.SourceKind)
                             @ (Language.PureScript.Names.Qualified
                                  (Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.TypeName),
                                (Language.PureScript.Kinds.SourceKind,
                                 Language.PureScript.Environment.TypeKind))
                             (\ (ds :: (Data.Text.Internal.Text,
                                        Language.PureScript.Kinds.SourceKind)) ->
                              case ds of wild { (,) name k ->
                              (Language.PureScript.Names.Qualified
                                 @ (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.TypeName)
                                 lvl33
                                 name
                                   `cast`
                                 (Sym (Language.PureScript.Names.N:ProperName[0]
                                           <'Language.PureScript.Names.TypeName>_P)),
                               (k, Language.PureScript.Environment.ScopedTypeVar)) })
                             ks))
                       ma
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   lvl29
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      (letrec {
                         go :: [(Data.Text.Internal.Text,
                                 Language.PureScript.Kinds.SourceKind)]
                               -> m ()
                           {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [(Data.Text.Internal.Text,
                                      Language.PureScript.Kinds.SourceKind)]) ->
                           case ds of wild {
                             [] -> lvl30
                             : y ys
                             -> GHC.Base.>>
                                  @ m
                                  $dMonad
                                  @ ()
                                  @ ()
                                  (case y of wild1 { (,) name ds1 ->
                                   case orig of wild2 { Language.PureScript.TypeChecker.Monad.CheckState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                                   case ds2 of wild3 { Language.PureScript.Environment.Environment ds10 ds11 ds12 ds13 ds14 ds15 ds16 ->
                                   case Language.PureScript.TypeChecker.Monad.$smember_$s$wpoly_go13
                                          ds11
                                          name
                                            `cast`
                                          (Sym (Language.PureScript.Names.N:ProperName[0]
                                                    <'Language.PureScript.Names.TypeName>_P))
                                          mn of wild4 {
                                     GHC.Types.False -> lvl31
                                     GHC.Types.True
                                     -> Control.Monad.Writer.Class.tell
                                          @ Language.PureScript.Errors.MultipleErrors
                                          @ m
                                          $dMonadWriter
                                          (GHC.Types.:
                                             @ Language.PureScript.AST.Declarations.ErrorMessage
                                             (Language.PureScript.AST.Declarations.ErrorMessage
                                                (GHC.Types.[]
                                                   @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                                (Language.PureScript.AST.Declarations.ShadowedTypeVar
                                                   name))
                                             (GHC.Types.[]
                                                @ Language.PureScript.AST.Declarations.ErrorMessage))
                                            `cast`
                                          (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) } } } })
                                  (go ys) }
                       } in
                       go ks)
                      lvl32)) -}
a48b8b4088719f7d173311a4d14e9441
  withTypeClassDictionaries ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    [Language.PureScript.TypeClassDictionaries.NamedDict] -> m a -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))><L,1*U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: [Language.PureScript.TypeClassDictionaries.NamedDict])
                   (eta1 :: m a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 let {
                   lvl29 :: m ()
                   = let {
                       mentries :: Data.Map.Internal.Map
                                     (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                                     (Data.Map.Internal.Map
                                        (Language.PureScript.Names.Qualified
                                           (Language.PureScript.Names.ProperName
                                              'Language.PureScript.Names.ClassName))
                                        (Data.Map.Internal.Map
                                           (Language.PureScript.Names.Qualified
                                              Language.PureScript.Names.Ident)
                                           (GHC.Base.NonEmpty
                                              Language.PureScript.TypeClassDictionaries.NamedDict)))
                       = Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries_go13
                           (Data.Map.Internal.Tip
                              @ (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                              @ (Data.Map.Internal.Map
                                   (Language.PureScript.Names.Qualified
                                      (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.ClassName))
                                   (Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      (GHC.Base.NonEmpty
                                         Language.PureScript.TypeClassDictionaries.NamedDict))))
                           (Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries_go
                              eta)
                     } in
                     Control.Monad.State.Class.state
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                       @ ()
                       (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                        (GHC.Tuple.(),
                         case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         Language.PureScript.TypeChecker.Monad.CheckState
                           (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                            Language.PureScript.Environment.Environment
                              ds8
                              ds9
                              ds10
                              ds11
                              (Language.PureScript.TypeChecker.Monad.$sunionWith2
                                 @ (Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      (Data.Map.Internal.Map
                                         (Language.PureScript.Names.Qualified
                                            Language.PureScript.Names.Ident)
                                         (GHC.Base.NonEmpty
                                            Language.PureScript.TypeClassDictionaries.NamedDict)))
                                 Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries1
                                 ds12
                                 mentries)
                              ds13
                              ds14 })
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7 }))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.TypeChecker.Monad.CheckState
                   @ a
                   (Control.Monad.State.Class.get
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (\ (orig :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ a
                      lvl29
                      (let {
                         lvl30 :: m ()
                         = let {
                             lvl31 :: Data.Map.Internal.Map
                                        (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
                                        (Data.Map.Internal.Map
                                           (Language.PureScript.Names.Qualified
                                              (Language.PureScript.Names.ProperName
                                                 'Language.PureScript.Names.ClassName))
                                           (Data.Map.Internal.Map
                                              (Language.PureScript.Names.Qualified
                                                 Language.PureScript.Names.Ident)
                                              (GHC.Base.NonEmpty
                                                 Language.PureScript.TypeClassDictionaries.NamedDict)))
                             = case orig of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                               ds12 } }
                           } in
                           Control.Monad.State.Class.state
                             @ Language.PureScript.TypeChecker.Monad.CheckState
                             @ m
                             $dMonadState
                             @ ()
                             (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                              (GHC.Tuple.(),
                               case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                               Language.PureScript.TypeChecker.Monad.CheckState
                                 (case ds of wild1 { Language.PureScript.Environment.Environment ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                                  Language.PureScript.Environment.Environment
                                    ds8
                                    ds9
                                    ds10
                                    ds11
                                    lvl31
                                    ds13
                                    ds14 })
                                 ds1
                                 ds2
                                 ds3
                                 ds4
                                 ds5
                                 ds6
                                 ds7 }))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ a
                         @ a
                         eta1
                         (\ (a1 :: a) ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ a
                            lvl30
                            (GHC.Base.return @ m $dMonad @ a a1))))) -}
74a082730f69d9e2e495ebfe6ca24ea6
  withTypeClassDictionaries1 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.ClassName))
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (GHC.Base.NonEmpty
            Language.PureScript.TypeClassDictionaries.NamedDict))
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               Language.PureScript.TypeClassDictionaries.NamedDict))
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               Language.PureScript.TypeClassDictionaries.NamedDict))
  {- Arity: 2,
     Unfolding: (Language.PureScript.TypeChecker.Monad.$sunionWith
                   @ (Data.Map.Internal.Map
                        (Language.PureScript.Names.Qualified
                           Language.PureScript.Names.Ident)
                        (GHC.Base.NonEmpty
                           Language.PureScript.TypeClassDictionaries.NamedDict))
                   Language.PureScript.TypeChecker.Monad.withTypeClassDictionaries2) -}
7836616107ceb0f064e4988cf457d194
  withTypeClassDictionaries2 ::
    Data.Map.Internal.Map
      (Language.PureScript.Names.Qualified
         Language.PureScript.Names.Ident)
      (GHC.Base.NonEmpty
         Language.PureScript.TypeClassDictionaries.NamedDict)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (GHC.Base.NonEmpty
            Language.PureScript.TypeClassDictionaries.NamedDict)
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            Language.PureScript.Names.Ident)
         (GHC.Base.NonEmpty
            Language.PureScript.TypeClassDictionaries.NamedDict)
  {- Arity: 2,
     Unfolding: (Language.PureScript.TypeChecker.Monad.$sunionWith1
                   @ (GHC.Base.NonEmpty
                        Language.PureScript.TypeClassDictionaries.NamedDict)
                   (GHC.Base.$fSemigroupNonEmpty_$c<>
                      @ (Language.PureScript.TypeClassDictionaries.TypeClassDictionaryInScope
                           (Language.PureScript.Names.Qualified
                              Language.PureScript.Names.Ident)))) -}
ea1949a9a2b1eb30f198b296a60f9fef
  withTypeClassDictionaries_go ::
    [Language.PureScript.TypeClassDictionaries.NamedDict]
    -> [(GHC.Base.Maybe Language.PureScript.Names.ModuleName,
         Data.Map.Internal.Map
           (Language.PureScript.Names.Qualified
              (Language.PureScript.Names.ProperName
                 'Language.PureScript.Names.ClassName))
           (Data.Map.Internal.Map
              (Language.PureScript.Names.Qualified
                 Language.PureScript.Names.Ident)
              (GHC.Base.NonEmpty
                 Language.PureScript.TypeClassDictionaries.NamedDict)))]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7cdfa2b684ea6c13261c1cb32aaa733a
  withTypeClassDictionaries_go13 ::
    Data.Map.Internal.Map
      (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
      (Data.Map.Internal.Map
         (Language.PureScript.Names.Qualified
            (Language.PureScript.Names.ProperName
               'Language.PureScript.Names.ClassName))
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               Language.PureScript.Names.Ident)
            (GHC.Base.NonEmpty
               Language.PureScript.TypeClassDictionaries.NamedDict)))
    -> [(GHC.Base.Maybe Language.PureScript.Names.ModuleName,
         Data.Map.Internal.Map
           (Language.PureScript.Names.Qualified
              (Language.PureScript.Names.ProperName
                 'Language.PureScript.Names.ClassName))
           (Data.Map.Internal.Map
              (Language.PureScript.Names.Qualified
                 Language.PureScript.Names.Ident)
              (GHC.Base.NonEmpty
                 Language.PureScript.TypeClassDictionaries.NamedDict)))]
    -> Data.Map.Internal.Map
         (GHC.Base.Maybe Language.PureScript.Names.ModuleName)
         (Data.Map.Internal.Map
            (Language.PureScript.Names.Qualified
               (Language.PureScript.Names.ProperName
                  'Language.PureScript.Names.ClassName))
            (Data.Map.Internal.Map
               (Language.PureScript.Names.Qualified
                  Language.PureScript.Names.Ident)
               (GHC.Base.NonEmpty
                  Language.PureScript.TypeClassDictionaries.NamedDict)))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
9a25073ac27c6847631231a5b0c65e08
  withoutWarnings ::
    Control.Monad.Writer.Class.MonadWriter w m => m a -> m (a, w)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLC(S)),U(1*U(A,1*U,A,A),U(A,C(C1(U)),A,C(U),A),A,A,1*C1(U),C(U))><L,U>,
     Unfolding: (\ @ w
                   @ m :: * -> *
                   @ a
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter w m)
                   (eta :: m a) ->
                 Control.Monad.Writer.Class.censor
                   @ w
                   @ m
                   @ (a, w)
                   $dMonadWriter
                   (let {
                      x :: GHC.Base.Monoid w
                      = Control.Monad.Writer.Class.$p1MonadWriter @ w @ m $dMonadWriter
                    } in
                    let { x1 :: w = GHC.Base.mempty @ w x } in \ (ds :: w) -> x1)
                   (Control.Monad.Writer.Class.listen
                      @ w
                      @ m
                      $dMonadWriter
                      @ a
                      eta)) -}
"SC:$wpoly_go130" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      a)
                             (sc1 :: Language.PureScript.Names.Ident)
  Language.PureScript.TypeChecker.Monad.$wpoly_go13 @ a
                                                    (GHC.Base.Nothing
                                                       @ Language.PureScript.Names.ModuleName)
                                                    sc1
                                                    sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go1
      @ a
      sc
      sc1
"SC:$wpoly_go130" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.ClassName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Nothing
                                                      @ Language.PureScript.Names.ModuleName)
                                                   sc1
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go6
      @ a
      sc
      sc1
"SC:$wpoly_go131" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         Language.PureScript.Names.Ident)
                                      a)
                             (sc1 :: Language.PureScript.Names.Ident)
                             (sc2 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go13 @ a
                                                    (GHC.Base.Just
                                                       @ Language.PureScript.Names.ModuleName
                                                       sc2)
                                                    sc1
                                                    sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go13
      @ a
      sc
      sc1
      sc2
"SC:$wpoly_go131" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.ClassName)
                             (sc2 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Just
                                                      @ Language.PureScript.Names.ModuleName
                                                      sc2)
                                                   sc1
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go5
      @ a
      sc
      sc1
      sc2
"SC:$wpoly_go132" [0] forall @ a
                             (sc :: Data.Map.Internal.Map
                                      (Language.PureScript.Names.Qualified
                                         (Language.PureScript.Names.ProperName
                                            'Language.PureScript.Names.ClassName))
                                      a)
                             (sc1 :: GHC.Prim.ByteArray#)
                             (sc2 :: GHC.Prim.Int#)
                             (sc3 :: GHC.Prim.Int#)
                             (sg :: (Data.Text.Internal.Text :: *)
                                    ~R# (Language.PureScript.Names.ProperName
                                           'Language.PureScript.Names.ClassName :: *))
  Language.PureScript.TypeChecker.Monad.$wpoly_go2 @ a
                                                   (GHC.Base.Nothing
                                                      @ Language.PureScript.Names.ModuleName)
                                                   (Data.Text.Internal.Text sc1 sc2 sc3) `cast` sg
                                                   sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$s$wpoly_go7
      @ a
      sc
      sc1
      sc2
      sc3
      @~ sg
"SC:poly_go130" forall @ a
                       (sc :: Data.Map.Internal.Map
                                (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a)
  Language.PureScript.TypeChecker.Monad.$slookup7 @ a
                                                  (GHC.Base.Nothing
                                                     @ Language.PureScript.Names.ModuleName)
                                                  sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go1 @ a sc
"SC:poly_go131" forall @ a
                       (sc :: Data.Map.Internal.Map
                                (GHC.Base.Maybe Language.PureScript.Names.ModuleName) a)
                       (sc1 :: Language.PureScript.Names.ModuleName)
  Language.PureScript.TypeChecker.Monad.$slookup7 @ a
                                                  (GHC.Base.Just
                                                     @ Language.PureScript.Names.ModuleName
                                                     sc1)
                                                  sc
  = Language.PureScript.TypeChecker.Monad.$slookup_$spoly_go13
      @ a
      sc
      sc1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqMaybe @ ModuleName" [orphan] forall (v :: GHC.Classes.Eq
                                                                                            Language.PureScript.Names.ModuleName)
  GHC.Base.$fEqMaybe @ Language.PureScript.Names.ModuleName v
  = Language.PureScript.TypeChecker.Monad.$s$fEqMaybe
"SPEC/Language.PureScript.TypeChecker.Monad $fEqMaybe_$c/= @ ModuleName" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                    Language.PureScript.Names.ModuleName)
  GHC.Base.$fEqMaybe_$c/= @ Language.PureScript.Names.ModuleName $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ (ProperName
                                                              'ClassName)" [orphan] forall (v :: GHC.Classes.Eq
                                                                                                                                                                           (Language.PureScript.Names.ProperName
                                                                                                                                                                              'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fEqQualified @ (Language.PureScript.Names.ProperName
                                               'Language.PureScript.Names.ClassName)
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ (ProperName
                                                              'TypeName)" [orphan] forall (v :: GHC.Classes.Eq
                                                                                                                                                                          (Language.PureScript.Names.ProperName
                                                                                                                                                                             'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fEqQualified @ (Language.PureScript.Names.ProperName
                                               'Language.PureScript.Names.TypeName)
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified @ Ident" [orphan] forall (v :: GHC.Classes.Eq
                                                                                           Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fEqQualified @ Language.PureScript.Names.Ident
                                          v
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified2
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ (ProperName
                                                                   'ClassName)" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                                                                                                        (Language.PureScript.Names.ProperName
                                                                                                                                                                                           'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fEqQualified_$c/= @ (Language.PureScript.Names.ProperName
                                                    'Language.PureScript.Names.ClassName)
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ (ProperName
                                                                   'TypeName)" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                                                                                                       (Language.PureScript.Names.ProperName
                                                                                                                                                                                          'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fEqQualified_$c/= @ (Language.PureScript.Names.ProperName
                                                    'Language.PureScript.Names.TypeName)
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=1
"SPEC/Language.PureScript.TypeChecker.Monad $fEqQualified_$c/= @ Ident" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                   Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fEqQualified_$c/= @ Language.PureScript.Names.Ident
                                               $dEq
  = Language.PureScript.TypeChecker.Monad.$s$fEqQualified_$s$fEqQualified_$c/=2
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe @ ModuleName" [orphan] forall (v :: GHC.Classes.Ord
                                                                                             Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe @ Language.PureScript.Names.ModuleName v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$c< @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                     Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$c< @ Language.PureScript.Names.ModuleName
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$c<
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$ccompare @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                           Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$ccompare @ Language.PureScript.Names.ModuleName
                                $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$ccompare
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdMaybe_$cmax @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                       Language.PureScript.Names.ModuleName)
  GHC.Base.$fOrdMaybe_$cmax @ Language.PureScript.Names.ModuleName
                            $dOrd
  = Language.PureScript.TypeChecker.Monad.$s$fOrdMaybe_$cmax
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ (ProperName
                                                               'ClassName)" [orphan] forall (v :: GHC.Classes.Ord
                                                                                                                                                                             (Language.PureScript.Names.ProperName
                                                                                                                                                                                'Language.PureScript.Names.ClassName))
  Language.PureScript.Names.$fOrdQualified @ (Language.PureScript.Names.ProperName
                                                'Language.PureScript.Names.ClassName)
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ (ProperName
                                                               'TypeName)" [orphan] forall (v :: GHC.Classes.Ord
                                                                                                                                                                            (Language.PureScript.Names.ProperName
                                                                                                                                                                               'Language.PureScript.Names.TypeName))
  Language.PureScript.Names.$fOrdQualified @ (Language.PureScript.Names.ProperName
                                                'Language.PureScript.Names.TypeName)
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified1
"SPEC/Language.PureScript.TypeChecker.Monad $fOrdQualified @ Ident" [orphan] forall (v :: GHC.Classes.Ord
                                                                                            Language.PureScript.Names.Ident)
  Language.PureScript.Names.$fOrdQualified @ Language.PureScript.Names.Ident
                                           v
  = Language.PureScript.TypeChecker.Monad.$s$fOrdQualified2
"SPEC/Language.PureScript.TypeChecker.Monad fromList @ (Qualified
                                                         (ProperName 'TypeName)) _" [orphan] forall @ a
                                                                                                                                                                      ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                                  (Language.PureScript.Names.Qualified
                                                                                                                                                                                     (Language.PureScript.Names.ProperName
                                                                                                                                                                                        'Language.PureScript.Names.TypeName)))
  Data.Map.Internal.fromList @ (Language.PureScript.Names.Qualified
                                  (Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.TypeName))
                             @ a
                             $dOrd
  = Language.PureScript.TypeChecker.Monad.$sfromList1 @ a
"SPEC/Language.PureScript.TypeChecker.Monad fromList @ (Qualified
                                                         Ident) _" [orphan] forall @ a
                                                                                                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                 (Language.PureScript.Names.Qualified
                                                                                                                                                                    Language.PureScript.Names.Ident))
  Data.Map.Internal.fromList @ (Language.PureScript.Names.Qualified
                                  Language.PureScript.Names.Ident)
                             @ a
                             $dOrd
  = Language.PureScript.TypeChecker.Monad.$sfromList @ a
"SPEC/Language.PureScript.TypeChecker.Monad union @ (Qualified
                                                      (ProperName 'TypeName)) _" [orphan] forall @ a
                                                                                                                                                                ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                            (Language.PureScript.Names.Qualified
                                                                                                                                                                               (Language.PureScript.Names.ProperName
                                                                                                                                                                                  'Language.PureScript.Names.TypeName)))
  Data.Map.Internal.union @ (Language.PureScript.Names.Qualified
                               (Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.TypeName))
                          @ a
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunion @ a
"SPEC/Language.PureScript.TypeChecker.Monad union @ (Qualified
                                                      Ident) _" [orphan] forall @ a
                                                                                                                                               ($dOrd :: GHC.Classes.Ord
                                                                                                                                                           (Language.PureScript.Names.Qualified
                                                                                                                                                              Language.PureScript.Names.Ident))
  Data.Map.Internal.union @ (Language.PureScript.Names.Qualified
                               Language.PureScript.Names.Ident)
                          @ a
                          $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunion1 @ a
"SPEC/Language.PureScript.TypeChecker.Monad unionWith @ (Maybe
                                                          ModuleName) _" [orphan] forall @ a
                                                                                                                                                        ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                    (GHC.Base.Maybe
                                                                                                                                                                       Language.PureScript.Names.ModuleName))
  Data.Map.Internal.unionWith @ (GHC.Base.Maybe
                                   Language.PureScript.Names.ModuleName)
                              @ a
                              $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunionWith2 @ a
"SPEC/Language.PureScript.TypeChecker.Monad unionWith @ (Qualified
                                                          (ProperName 'ClassName)) _" [orphan] forall @ a
                                                                                                                                                                         ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                                     (Language.PureScript.Names.Qualified
                                                                                                                                                                                        (Language.PureScript.Names.ProperName
                                                                                                                                                                                           'Language.PureScript.Names.ClassName)))
  Data.Map.Internal.unionWith @ (Language.PureScript.Names.Qualified
                                   (Language.PureScript.Names.ProperName
                                      'Language.PureScript.Names.ClassName))
                              @ a
                              $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunionWith @ a
"SPEC/Language.PureScript.TypeChecker.Monad unionWith @ (Qualified
                                                          Ident) _" [orphan] forall @ a
                                                                                                                                                       ($dOrd :: GHC.Classes.Ord
                                                                                                                                                                   (Language.PureScript.Names.Qualified
                                                                                                                                                                      Language.PureScript.Names.Ident))
  Data.Map.Internal.unionWith @ (Language.PureScript.Names.Qualified
                                   Language.PureScript.Names.Ident)
                              @ a
                              $dOrd
  = Language.PureScript.TypeChecker.Monad.$sunionWith1 @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

