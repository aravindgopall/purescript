
==================== FINAL INTERFACE ====================
2019-01-24 14:17:54.016998 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Rebuild 8043
  interface hash: cd4ee882648e028897326530e6942a9b
  ABI hash: f2d4271054f9ecf8479a5fb7f6a9391d
  export-list hash: 32a4b9feb8bf7543b0225778c3f6edd7
  orphan hash: e069e5dd25b1d81d69433d898dcdc0eb
  flag hash: e036ad898ec24d32848ada8496fa514b
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: True
  where
exports:
  Language.PureScript.Ide.Rebuild.rebuildFile
  Language.PureScript.Ide.Rebuild.rebuildFileAsync
  Language.PureScript.Ide.Rebuild.rebuildFileSync
module dependencies: Control.Monad.Logger Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript
                     Language.PureScript.AST Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.CodeGen.JS
                     Language.PureScript.CodeGen.JS.Common
                     Language.PureScript.CodeGen.JS.Printer Language.PureScript.Comments
                     Language.PureScript.Constants Language.PureScript.CoreFn
                     Language.PureScript.CoreFn.Ann Language.PureScript.CoreFn.Binders
                     Language.PureScript.CoreFn.Desugar Language.PureScript.CoreFn.Expr
                     Language.PureScript.CoreFn.Meta Language.PureScript.CoreFn.Module
                     Language.PureScript.CoreFn.Optimizer
                     Language.PureScript.CoreFn.ToJSON
                     Language.PureScript.CoreFn.Traversals
                     Language.PureScript.CoreImp.AST
                     Language.PureScript.CoreImp.Optimizer
                     Language.PureScript.CoreImp.Optimizer.Blocks
                     Language.PureScript.CoreImp.Optimizer.Common
                     Language.PureScript.CoreImp.Optimizer.Inliner
                     Language.PureScript.CoreImp.Optimizer.MagicDo
                     Language.PureScript.CoreImp.Optimizer.TCO
                     Language.PureScript.CoreImp.Optimizer.Unused
                     Language.PureScript.Crash Language.PureScript.Docs.Convert.Single
                     Language.PureScript.Docs.RenderedCode
                     Language.PureScript.Docs.RenderedCode.RenderKind
                     Language.PureScript.Docs.RenderedCode.RenderType
                     Language.PureScript.Docs.RenderedCode.Types
                     Language.PureScript.Docs.Types
                     Language.PureScript.Docs.Utils.MonoidExtras
                     Language.PureScript.Environment Language.PureScript.Errors
                     Language.PureScript.Errors.JSON Language.PureScript.Externs
                     Language.PureScript.Ide.Error Language.PureScript.Ide.Externs
                     Language.PureScript.Ide.Logging Language.PureScript.Ide.Reexports
                     Language.PureScript.Ide.SourceFile Language.PureScript.Ide.State
                     Language.PureScript.Ide.Types Language.PureScript.Ide.Util
                     Language.PureScript.Kinds Language.PureScript.Label
                     Language.PureScript.Linter Language.PureScript.Linter.Exhaustive
                     Language.PureScript.Linter.Imports Language.PureScript.Make
                     Language.PureScript.Make.Actions Language.PureScript.Make.BuildPlan
                     Language.PureScript.Make.Monad
                     Language.PureScript.ModuleDependencies Language.PureScript.Names
                     Language.PureScript.Options Language.PureScript.PSString
                     Language.PureScript.Parser Language.PureScript.Parser.Common
                     Language.PureScript.Parser.Declarations
                     Language.PureScript.Parser.Kinds Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Parser.Types
                     Language.PureScript.Pretty Language.PureScript.Pretty.Common
                     Language.PureScript.Pretty.Kinds Language.PureScript.Pretty.Types
                     Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Renamer Language.PureScript.Sugar
                     Language.PureScript.Sugar.AdoNotation
                     Language.PureScript.Sugar.BindingGroups
                     Language.PureScript.Sugar.CaseDeclarations
                     Language.PureScript.Sugar.DoNotation
                     Language.PureScript.Sugar.LetPattern
                     Language.PureScript.Sugar.Names
                     Language.PureScript.Sugar.Names.Common
                     Language.PureScript.Sugar.Names.Env
                     Language.PureScript.Sugar.Names.Exports
                     Language.PureScript.Sugar.Names.Imports
                     Language.PureScript.Sugar.ObjectWildcards
                     Language.PureScript.Sugar.Operators
                     Language.PureScript.Sugar.Operators.Binders
                     Language.PureScript.Sugar.Operators.Common
                     Language.PureScript.Sugar.Operators.Expr
                     Language.PureScript.Sugar.Operators.Types
                     Language.PureScript.Sugar.TypeClasses
                     Language.PureScript.Sugar.TypeClasses.Deriving
                     Language.PureScript.Sugar.TypeDeclarations
                     Language.PureScript.Traversals Language.PureScript.TypeChecker
                     Language.PureScript.TypeChecker.Entailment
                     Language.PureScript.TypeChecker.Kinds
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeChecker.Subsumption
                     Language.PureScript.TypeChecker.Synonyms
                     Language.PureScript.TypeChecker.TypeSearch
                     Language.PureScript.TypeChecker.Types
                     Language.PureScript.TypeChecker.Unify
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript System.IO.UTF8
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      auto-update-0.1.4 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 bower-json-1.0.0.1 boxes-0.1.5
                      bytestring-0.10.8.2 clock-0.7.2 colour-2.3.4 conduit-1.3.0.3
                      conduit-extra-1.3.0 containers-0.5.11.0 data-ordlist-0.4.7.0
                      deepseq-1.4.3.0 directory-1.3.1.5 dlist-0.8.0.4 easy-file-0.2.2
                      exceptions-0.10.0 fast-logger-2.4.11 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 lifted-base-0.2.3.12 microlens-0.4.9.1
                      microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1
                      monad-control-1.0.2.3 monad-logger-0.3.28.5 monad-loops-0.4.3
                      mtl-2.2.2 old-locale-1.0.0.7 old-time-1.1.0.3 parallel-3.2.1.1
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 resourcet-1.2.1
                      safe-0.3.17 scientific-0.3.6.2 sourcemap-0.1.6 split-0.2.3.3
                      stm-2.4.5.0 stm-chans-3.0.0.4 stringsearch-0.3.6.6 syb-0.7
                      tagged-0.8.5 template-haskell-2.13.0.0 text-1.2.3.0
                      th-abstraction-0.2.8.0 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.5.0 transformers-base-0.4.5.2 unix-2.7.2.2
                      unix-time-0.3.8 unliftio-core-0.1.1.0 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: unix-time-0.3.8:Data.UnixTime.Diff
         syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic text-1.2.3.0:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bower-json-1.0.0.1:Web.Bower.PackageMeta.Internal
                         clock-0.7.2:System.Clock
                         conduit-1.3.0.3:Data.Conduit.Internal.Conduit
                         conduit-1.3.0.3:Data.Conduit.Internal.Pipe
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         monad-logger-0.3.28.5:Control.Monad.Logger
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Logger
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Docs.RenderedCode.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Docs.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Reexports
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Make.Monad
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         resourcet-1.2.1:Control.Monad.Trans.Resource.Internal
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  async-2.2.1:Control.Concurrent.Async 459357253edd9936fe4b88fefb91a0c0
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  containers-0.5.11.0:Data.Map.Lazy 04768812a57695fe69782cd0014b0c7b
import  -/  containers-0.5.11.0:Data.Set 7d3c64a641be4cacbcd8119445bab919
import  -/  containers-0.5.11.0:Data.Set.Internal 93fa3ef95853aa2a7aadf32d693bd451
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  monad-logger-0.3.28.5:Control.Monad.Logger ae6f9fbc4451af5ecbeab48dfdfd01ee
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  protolude-0.2.2:Protolude.Bool cdac0e1e4ccf4064999c851029bcfcb2
import  -/  Language.PureScript 4a24ccd892adbf021daf2410ebd61e22
  exports: 139dcaa90af8ddcee6aa0492159f351d
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  ImportDeclaration b98a8b3e9f19a9a91825a99d72954601
  Module 305128e30e200d34d712365aa2d509df
  Module 3342e00ee072addfd009ee61e87fb865
  getModuleName 7aa2ed3fa39338f5edb2f1938e29c924
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  internalModuleSourceSpan f13de72620ea3980769d3252f1949a4a
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  MultipleErrors e10d32697d8bc85ed39c4a4d256bc383
import  -/  Language.PureScript.Externs cf933be49760ec7d1e991d8ad7f6146f
  ExternsFile 3c90d25a909106e2dfae91839ad7749d
  ExternsFile c010c09fe85776adf7c6787c7d79c898
  ExternsImport a0c06180974368a22aa990853f271778
  efDeclarations c010c09fe85776adf7c6787c7d79c898
  efExports c010c09fe85776adf7c6787c7d79c898
  efFixities c010c09fe85776adf7c6787c7d79c898
  efImports c010c09fe85776adf7c6787c7d79c898
  efModuleName c010c09fe85776adf7c6787c7d79c898
  efSourceSpan c010c09fe85776adf7c6787c7d79c898
  efTypeFixities c010c09fe85776adf7c6787c7d79c898
  efVersion c010c09fe85776adf7c6787c7d79c898
import  -/  Language.PureScript.Ide.Error b6eb0f8da112a6cbb4342061d1afef05
  exports: 618489d4d27b48ee8032da6edee10f0b
  GeneralError 12e806af4285c37439d91c81a0757c61
  IdeError 347304649e024d1c6990f4b438ecc115
  RebuildError ac6614999a6bffce7ba847e12ceddf85
import  -/  Language.PureScript.Ide.Logging 7a72afda66c50413f726f7fcff793207
  exports: a81d71de8acd1b222a31676827fd6862
  labelTimespec 0d907ef0de3979242901311139028d3a
  logPerf 0e0bef938e0140f679afbba754e2f391
  runLogger 59824604358c607560bbe67cfd41a713
import  -/  Language.PureScript.Ide.State 6596e6b1b04a4a1b7b69c0256b5b2e95
  exports: 4a5f4f202d7d05e1561b603fd2daadc9
  cacheRebuild 8d026b55fae9c4a986facc5e8d233807
  getExternFiles 7b074820b990a95f0824c75debf70a69
  insertExterns 017ce8f07520bcf23e97e215fc9a4bd3
  insertModule 66795f39a6ec8c2285ea26ffbc233e0d
  populateVolatileState 9a1e82d6fe6e465c5f95071acff86867
import  -/  Language.PureScript.Ide.Types 4bb81e9de3788f7f63a68a23e190eb73
  exports: e5ee4d37ef25d4dfedd36ea1d435a17a
  Ide daf7e11ebbb1a4f28e92151bdfd877f7
  IdeEnvironment ae7ebb9016daec3c320aa4779032899f
  ModuleMap 70319f3e75143277feb6984fb77be89b
  RebuildSuccess 08830c766287082b81d1b5f9eb1ca6cb
  Success b9eb2ae0777aa82b05464c5c85d22086
  confEditorMode 60599607aeaddfb6ebe1e4768bb3aec5
  confLogLevel 60599607aeaddfb6ebe1e4768bb3aec5
  confOutputPath 60599607aeaddfb6ebe1e4768bb3aec5
  ideConfiguration ae7ebb9016daec3c320aa4779032899f
import  -/  Language.PureScript.Ide.Util 23feade20e7d884b8e398315c4ffa11e
  exports: b783a834cebd9a63a606ae4111317a86
  ideReadFile e90a75f47b35d9b93bb00b2e97526cbb
import  -/  Language.PureScript.Make a45ced05ef945b46ab201444ccadc5c9
  inferForeignModules 4909847491cbb47cc441123469e11d19
  rebuildModule cdf51a6925332865ebf416e4d8e33375
import  -/  Language.PureScript.Make.Actions d964d3443f97c4366835ba8624e5a3fb
  MakeActions b3e64d282c220fb028af7420464074c0
  RebuildAlways 4c02622e32018823187273644c1aae4d
  RebuildPolicy 9e87da6e8f3d80dfe923a125596f291e
  buildMakeActions ffd31c1d8bb38416a469a44f6d866eac
  codegen b3e64d282c220fb028af7420464074c0
  ffiCodegen b3e64d282c220fb028af7420464074c0
  progress b3e64d282c220fb028af7420464074c0
import  -/  Language.PureScript.Make.Monad 31242626e8d67103dbe8824cd3d4896a
  Make 2384e2052993ac0b8b29c8eccd939cb5
  runMake ab2867f8bdf000c620b889012835e285
import  -/  Language.PureScript.ModuleDependencies 76745f43818037b936a9569d78efb462
  sortModules 9064a8fe73bfe27487e0064715babcbf
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  runModuleName 58b788b37f600c0f34fa85241d7748ad
import  -/  Language.PureScript.Options 2e36bd5fcc2b2ebbc36ff47b336cef60
  CodegenTarget 01549f9098408b4144e13364de301586
  defaultOptions d5de66b0cf6e3104b6ad5f0defb7954a
  optionsCodegenTargets 43e82b7ea0c416dc61c77c04548dbdd3
import  -/  Language.PureScript.Parser.Declarations 4331277871d8b757c9139b8595a399c8
  parseModuleFromFile a5e431f010c7cf005e06404183762fa6
  toPositionedError c8dd5bf67db305236521a3f81e384d2f
import  -/  template-haskell-2.13.0.0:Language.Haskell.TH.Syntax 3e32e309555ba250b4e64084f1389487
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
8538565fae004dbe3cb29acf8ace019a
  $s$fApplicativeLoggingT ::
    GHC.Base.Applicative (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fFunctorLoggingT
                  (\ @ a (x :: a) ->
                   let {
                     x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, x #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x1)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*>
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, eta ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <c>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <c>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta2 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta2)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (eta1
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      eta2)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
aaa9c869cef1a4bf38d3f26d3c9047df
  $s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (loggerF :: Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b))
                   (loggerA :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (loggerF
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a -> b>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 case (loggerA
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
5c56582908f21f7578f888168a724072
  $s$fApplicativeLoggingT_$s$fFunctorLoggingT ::
    GHC.Base.Functor (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta1 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (# ipv, x #) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
a909e18eb74030b2e89851d707cfa30d
  $s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap ::
    (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (logger :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (logger
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 (# ipv, f ipv1 #) })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
e022e135ebf671f1202bcda0338acb48
  $s$fMonadIOExceptT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Control.Monad.Trans.Except.$fMonadExceptT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     (Control.Monad.Trans.Reader.$fMonadReaderT
                        @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT_$s$fMonadLoggingT))
                  (\ @ a
                     (x :: GHC.Types.IO a)
                     (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case x `cast` (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   (# ipv, Data.Either.Right @ e @ a ipv1 #) })
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Ide.Types.IdeEnvironment>_R
                         ->_R (<Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                    <GHC.Types.IO>_R
                                                                    <Data.Either.Either
                                                                       e
                                                                       a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                          <*>_N
                                                                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                          <Control.Monad.Logger.LoggingT
                                                                                             GHC.Types.IO>_R
                                                                                          <Data.Either.Either
                                                                                             e
                                                                                             a>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                              <e>_N
                                                                                                              <Control.Monad.Trans.Reader.ReaderT
                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                    GHC.Types.IO)>_R
                                                                                                              <a>_N))) -}
a35c56c40d3357311f1774e37debeaa7
  $s$fMonadIOExceptT_$s$fMonadLoggingT ::
    GHC.Base.Monad (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT
                  (\ @ a
                     @ b
                     (ds :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (f :: a -> Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   ((f ipv1)
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      r)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <a -> Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT_$s$fMonadLoggingT_$c>>
                  (\ @ a (eta :: a) ->
                   let {
                     x :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO a)) -}
1579182838428c97d96b45fb949255e9
  $s$fMonadIOExceptT_$s$fMonadLoggingT_$c>> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (k :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                   (r :: Language.Haskell.TH.Syntax.Loc
                         -> Control.Monad.Logger.LogSource
                         -> Control.Monad.Logger.LogLevel
                         -> System.Log.FastLogger.LogStr.LogStr
                         -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (k `cast`
                  (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                    r)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
8bd81e4c9b4ba1c18ee1b946418bb36b
  $s$fMonadLoggingT_$creturn ::
    a -> Control.Monad.Logger.LoggingT GHC.Types.IO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta :: a) ->
                 let {
                   x :: GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                     {- Arity: 1 -}
                   = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta #)
                 } in
                 (\ (ds :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ()) ->
                  x)
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                    <GHC.Types.IO>_R <a>_N))) -}
eb97289cfdcd21c7ce4d5a067e5879c4
  $s$fMonadReaderrExceptT ::
    Control.Monad.Reader.Class.MonadReader
      Language.PureScript.Ide.Types.IdeEnvironment
      (Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Trans.Reader.ReaderT
            Language.PureScript.Ide.Types.IdeEnvironment
            (Control.Monad.Logger.LoggingT GHC.Types.IO)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ Language.PureScript.Ide.Types.IdeEnvironment
                  @ (Control.Monad.Trans.Except.ExceptT
                       e
                       (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO)))
                  (Control.Monad.Trans.Except.$fMonadExceptT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     (Control.Monad.Trans.Reader.$fMonadReaderT
                        @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT_$s$fMonadLoggingT))
                  (\ (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s,
                      Data.Either.Right
                        @ e
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        r1 #))
                    `cast`
                  ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                    ->_R (<Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ()>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Either.Either
                                           e
                                           Language.PureScript.Ide.Types.IdeEnvironment>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                                                        <GHC.Types.IO>_R
                                                                                                        <Data.Either.Either
                                                                                                           e
                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                         <*>_N
                                                                                                                                                                         <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                                                                                                         <Control.Monad.Logger.LoggingT
                                                                                                                                                                            GHC.Types.IO>_R
                                                                                                                                                                         <Data.Either.Either
                                                                                                                                                                            e
                                                                                                                                                                            Language.PureScript.Ide.Types.IdeEnvironment>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                                                                                                        <e>_N
                                                                                                                                                                                                                                        <Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                           Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                                                                           (Control.Monad.Logger.LoggingT
                                                                                                                                                                                                                                              GHC.Types.IO)>_R
                                                                                                                                                                                                                                        <Language.PureScript.Ide.Types.IdeEnvironment>_N)))
                  (\ @ a
                     (eta :: Language.PureScript.Ide.Types.IdeEnvironment
                             -> Language.PureScript.Ide.Types.IdeEnvironment) ->
                   Control.Monad.Trans.Except.mapExceptT
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     @ a
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Language.PureScript.Ide.Types.IdeEnvironment
                          (Control.Monad.Logger.LoggingT GHC.Types.IO))
                     @ e
                     @ a
                     (Control.Monad.Trans.Reader.withReaderT
                        @ *
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        @ Language.PureScript.Ide.Types.IdeEnvironment
                        @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                        @ (Data.Either.Either e a)
                        eta))
                  (\ @ a
                     (eta :: Language.PureScript.Ide.Types.IdeEnvironment -> a)
                     (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s, Data.Either.Right @ e @ a (eta r1) #))
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Ide.Types.IdeEnvironment -> a>_R
                   ->_R (<Language.PureScript.Ide.Types.IdeEnvironment>_R
                         ->_R (<Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                e a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                    <GHC.Types.IO>_R
                                                                    <Data.Either.Either
                                                                       e
                                                                       a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                          <*>_N
                                                                                          <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                          <Control.Monad.Logger.LoggingT
                                                                                             GHC.Types.IO>_R
                                                                                          <Data.Either.Either
                                                                                             e
                                                                                             a>_N) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                              <e>_N
                                                                                                              <Control.Monad.Trans.Reader.ReaderT
                                                                                                                 Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                    GHC.Types.IO)>_R
                                                                                                              <a>_N))) -}
6428253783c92d59fad495ceb3b8baa9
  $sdelete_$sgo13 ::
    Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
e90ca3ff4c65cc4f2e490fe03410e1ae
  $sfromList ::
    [Language.PureScript.Names.ModuleName]
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.PureScript.Names.ModuleName]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x `cast`
                                (Language.PureScript.Names.N:ModuleName[0]) of nt { DEFAULT ->
                           Data.Set.Internal.Bin
                             @ Language.PureScript.Names.ModuleName
                             1#
                             nt `cast` (Sym (Language.PureScript.Names.N:ModuleName[0]))
                             (Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName)
                             (Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName) }
                        : ipv ipv1
                        -> case GHC.Classes.$fOrd[]_$ccompare
                                  @ (Language.PureScript.Names.ProperName
                                       'Language.PureScript.Names.Namespace)
                                  (Language.PureScript.Names.$fOrdProperName
                                     @ 'Language.PureScript.Names.Namespace)
                                  x `cast` (Language.PureScript.Names.N:ModuleName[0])
                                  ipv `cast` (Language.PureScript.Names.N:ModuleName[0]) of wild2 {
                             DEFAULT
                             -> case x `cast`
                                     (Language.PureScript.Names.N:ModuleName[0]) of nt { DEFAULT ->
                                Language.PureScript.Ide.Rebuild.$sfromList_$sgo4
                                  ipv
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Names.ModuleName
                                     1#
                                     nt `cast` (Sym (Language.PureScript.Names.N:ModuleName[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName)
                                     (Data.Set.Internal.Tip
                                        @ Language.PureScript.Names.ModuleName)) }
                             GHC.Types.LT
                             -> case x `cast`
                                     (Language.PureScript.Names.N:ModuleName[0]) of nt { DEFAULT ->
                                Language.PureScript.Ide.Rebuild.$sfromList_$s$wgo3
                                  ipv
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Names.ModuleName
                                     1#
                                     nt `cast` (Sym (Language.PureScript.Names.N:ModuleName[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName)
                                     (Data.Set.Internal.Tip @ Language.PureScript.Names.ModuleName))
                                  1# } } } }) -}
a45d22f7c34863774cc3eb0219385dd0
  $sfromList_$s$wgo3 ::
    Language.PureScript.Names.ModuleName
    -> [Language.PureScript.Names.ModuleName]
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
  {- Arity: 4, Strictness: <S,U><S,1*U><S,1*U><L,U> -}
95491d8c8ac18e933aa34e567e2dc9f3
  $sfromList_$sgo4 ::
    Language.PureScript.Names.ModuleName
    -> [Language.PureScript.Names.ModuleName]
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
  {- Arity: 3, Strictness: <S,U><S,1*U><S,1*U> -}
d043cb8f0481f5f38b0390dc0474c758
  $sinsert_$sgo3 ::
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.ModuleName
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
e9ba917832513530d89dcfa9490447ca
  $slookup1 ::
    Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
94dcd87dfdc3a8e2b163c76eaa0aa597
  $smember_go3 ::
    Language.PureScript.Names.ModuleName
    -> Data.Set.Internal.Set Language.PureScript.Names.ModuleName
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
47c11c523b6e4c8e3cec7d9fb01bc97a
  $tc'MakeActionsEnv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4897774285021382178##
                   17751582466463363407##
                   Language.PureScript.Ide.Rebuild.$trModule
                   Language.PureScript.Ide.Rebuild.$tc'MakeActionsEnv2
                   0#
                   Language.PureScript.Ide.Rebuild.$tc'MakeActionsEnv1) -}
ca2296da4eff253d0c1401a8a99a9320
  $tc'MakeActionsEnv1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
82811fd8cec577c4709261474112404f
  $tc'MakeActionsEnv2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.Rebuild.$tc'MakeActionsEnv3) -}
9ef748ac0eda06ff9d61b27da4fe21d0
  $tc'MakeActionsEnv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'MakeActionsEnv"#) -}
2c58b53cf7fa02694d502559e3d36c8d
  $tcMakeActionsEnv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2090914490217300915##
                   14858936980127183443##
                   Language.PureScript.Ide.Rebuild.$trModule
                   Language.PureScript.Ide.Rebuild.$tcMakeActionsEnv1
                   0#
                   GHC.Types.krep$*) -}
66bb4b5dc9002a7858567f2ada5a104a
  $tcMakeActionsEnv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.Rebuild.$tcMakeActionsEnv2) -}
f194098507f3f57ef17787d13f131082
  $tcMakeActionsEnv2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MakeActionsEnv"#) -}
47e75094fcd5ffd798bc0c204335632f
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Ide.Rebuild.$trModule3
                   Language.PureScript.Ide.Rebuild.$trModule1) -}
081dc5116441df551a70558fd74d6f9b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.Rebuild.$trModule2) -}
d4f55c328813782adccc59b4b6cb735c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.PureScript.Ide.Rebuild"#) -}
eda486ef058a3f9985ae83001e77ef80
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.Rebuild.$trModule4) -}
527785e2f79012c89b9b79ffd5d26dc8
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
0a7a10c95c0d437f688aa72598dce343
  data MakeActionsEnv
    = MakeActionsEnv {maeOutputDirectory :: GHC.IO.FilePath,
                      maeFilePathMap :: Language.PureScript.Ide.Types.ModuleMap
                                          (Data.Either.Either
                                             Language.PureScript.Make.Actions.RebuildPolicy
                                             GHC.IO.FilePath),
                      maeForeignPathMap :: Language.PureScript.Ide.Types.ModuleMap
                                             GHC.IO.FilePath,
                      maePrefixComment :: GHC.Types.Bool}
0a7a10c95c0d437f688aa72598dce343
  maeFilePathMap ::
    Language.PureScript.Ide.Rebuild.MakeActionsEnv
    -> Language.PureScript.Ide.Types.ModuleMap
         (Data.Either.Either
            Language.PureScript.Make.Actions.RebuildPolicy GHC.IO.FilePath)
  RecSel Left Language.PureScript.Ide.Rebuild.MakeActionsEnv
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Ide.Rebuild.MakeActionsEnv) ->
                 case ds of wild { Language.PureScript.Ide.Rebuild.MakeActionsEnv ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
0a7a10c95c0d437f688aa72598dce343
  maeForeignPathMap ::
    Language.PureScript.Ide.Rebuild.MakeActionsEnv
    -> Language.PureScript.Ide.Types.ModuleMap GHC.IO.FilePath
  RecSel Left Language.PureScript.Ide.Rebuild.MakeActionsEnv
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Ide.Rebuild.MakeActionsEnv) ->
                 case ds of wild { Language.PureScript.Ide.Rebuild.MakeActionsEnv ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
0a7a10c95c0d437f688aa72598dce343
  maeOutputDirectory ::
    Language.PureScript.Ide.Rebuild.MakeActionsEnv -> GHC.IO.FilePath
  RecSel Left Language.PureScript.Ide.Rebuild.MakeActionsEnv
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Ide.Rebuild.MakeActionsEnv) ->
                 case ds of wild { Language.PureScript.Ide.Rebuild.MakeActionsEnv ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
0a7a10c95c0d437f688aa72598dce343
  maePrefixComment ::
    Language.PureScript.Ide.Rebuild.MakeActionsEnv -> GHC.Types.Bool
  RecSel Left Language.PureScript.Ide.Rebuild.MakeActionsEnv
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Ide.Rebuild.MakeActionsEnv) ->
                 case ds of wild { Language.PureScript.Ide.Rebuild.MakeActionsEnv ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
83fb33321ef5464a1b90197901eb39db
  rebuildFile ::
    (Language.PureScript.Ide.Types.Ide m,
     Control.Monad.Logger.MonadLogger m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Ide.Error.IdeError m) =>
    GHC.IO.FilePath
    -> GHC.Base.Maybe GHC.IO.FilePath
    -> Data.Set.Internal.Set Language.PureScript.Options.CodegenTarget
    -> (Control.Monad.Trans.Reader.ReaderT
          Language.PureScript.Ide.Types.IdeEnvironment
          (Control.Monad.Logger.LoggingT GHC.Types.IO)
          ()
        -> m ())
    -> m Language.PureScript.Ide.Types.Success
  {- Arity: 3,
     Strictness: <L,U(U(U(U(U(C(C(U)),1*C1(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),C(U),C(U)),C(U)),U(A,U,A,1*C1(U)))><L,U(A,C(C1(C1(C1(C1(U))))))><L,U(A,C(U),A)> -}
4fdb1fcb477643ab95353b9f61ec2d30
  rebuildFileAsync ::
    (Language.PureScript.Ide.Types.Ide m,
     Control.Monad.Logger.MonadLogger m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Ide.Error.IdeError m) =>
    GHC.IO.FilePath
    -> GHC.Base.Maybe GHC.IO.FilePath
    -> Data.Set.Internal.Set Language.PureScript.Options.CodegenTarget
    -> m Language.PureScript.Ide.Types.Success
  {- Arity: 6,
     Strictness: <L,U(U(U(U(U(C(C(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),C(U),C(U)),C(U)),U(A,U,A,C(U)))><L,U(A,C(C1(C1(C1(C1(U))))))><L,U(A,C(U),A)><L,U><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%)1 :: Language.PureScript.Ide.Types.Ide m)
                   ($dMonadLogger :: Control.Monad.Logger.MonadLogger m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Ide.Error.IdeError m)
                   (eta :: GHC.IO.FilePath)
                   (eta1 :: GHC.Base.Maybe GHC.IO.FilePath)
                   (eta2 :: Data.Set.Internal.Set
                              Language.PureScript.Options.CodegenTarget) ->
                 let {
                   $dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                      Language.PureScript.Ide.Types.IdeEnvironment m
                   = GHC.Classes.$p2(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)1
                 } in
                 let {
                   lvl45 :: m Language.PureScript.Ide.Types.IdeEnvironment
                   = Control.Monad.Reader.Class.ask
                       @ Language.PureScript.Ide.Types.IdeEnvironment
                       @ m
                       $dMonadReader
                 } in
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)1
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dFunctor :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor m
                   = GHC.Base.$p1Applicative @ m $dFunctor
                 } in
                 Language.PureScript.Ide.Rebuild.rebuildFile
                   @ m
                   $d(%,%)1
                   $dMonadLogger
                   $dMonadError
                   eta
                   eta1
                   eta2
                   (\ (action :: Control.Monad.Trans.Reader.ReaderT
                                   Language.PureScript.Ide.Types.IdeEnvironment
                                   (Control.Monad.Logger.LoggingT GHC.Types.IO)
                                   ()) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ ()
                      lvl45
                      (\ (env :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                       GHC.Base.<$
                         @ m
                         $dFunctor1
                         @ ()
                         @ (Control.Concurrent.Async.Async ())
                         GHC.Tuple.()
                         (Control.Monad.IO.Class.liftIO
                            @ m
                            $dMonadIO
                            @ (Control.Concurrent.Async.Async ())
                            (Control.Concurrent.Async.async2
                               @ ()
                               Control.Concurrent.Async.rawForkIO
                               (Language.PureScript.Ide.Logging.$wrunLogger
                                  @ GHC.Types.IO
                                  @ ()
                                  (case env of wild { Language.PureScript.Ide.Types.IdeEnvironment ds1 ds2 ->
                                   case ds2 of wild1 { Language.PureScript.Ide.Types.IdeConfiguration ds4 ds5 ds3 ds6 ->
                                   ds5 } })
                                  (action
                                     `cast`
                                   (Control.Monad.Trans.Reader.N:ReaderT[0]
                                        <*>_N
                                        <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                        <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                        <()>_N)
                                     env)))
                              `cast`
                            (Sym (GHC.Types.N:IO[0]
                                      <Control.Concurrent.Async.Async ()>_R)))))) -}
abdcaaf28c0ff49b57ecb070068d7602
  rebuildFileSync ::
    (Language.PureScript.Ide.Types.Ide m,
     Control.Monad.Logger.MonadLogger m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Ide.Error.IdeError m) =>
    GHC.IO.FilePath
    -> GHC.Base.Maybe GHC.IO.FilePath
    -> Data.Set.Internal.Set Language.PureScript.Options.CodegenTarget
    -> m Language.PureScript.Ide.Types.Success
  {- Arity: 6,
     Strictness: <L,U(U(U(U(U(C(C(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),C(U),C(U)),C(U)),U(A,U,A,C(U)))><L,U(A,C(C1(C1(C1(C1(U))))))><L,U(A,C(U),A)><L,U><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%)1 :: Language.PureScript.Ide.Types.Ide m)
                   ($dMonadLogger :: Control.Monad.Logger.MonadLogger m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Ide.Error.IdeError m)
                   (eta :: GHC.IO.FilePath)
                   (eta1 :: GHC.Base.Maybe GHC.IO.FilePath)
                   (eta2 :: Data.Set.Internal.Set
                              Language.PureScript.Options.CodegenTarget) ->
                 let {
                   $dMonadReader :: Control.Monad.Reader.Class.MonadReader
                                      Language.PureScript.Ide.Types.IdeEnvironment m
                   = GHC.Classes.$p2(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)1
                 } in
                 let {
                   lvl45 :: m Language.PureScript.Ide.Types.IdeEnvironment
                   = Control.Monad.Reader.Class.ask
                       @ Language.PureScript.Ide.Types.IdeEnvironment
                       @ m
                       $dMonadReader
                 } in
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)1
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dFunctor :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor m
                   = GHC.Base.$p1Applicative @ m $dFunctor
                 } in
                 Language.PureScript.Ide.Rebuild.rebuildFile
                   @ m
                   $d(%,%)1
                   $dMonadLogger
                   $dMonadError
                   eta
                   eta1
                   eta2
                   (\ (action :: Control.Monad.Trans.Reader.ReaderT
                                   Language.PureScript.Ide.Types.IdeEnvironment
                                   (Control.Monad.Logger.LoggingT GHC.Types.IO)
                                   ()) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ ()
                      lvl45
                      (\ (env :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                       GHC.Base.<$
                         @ m
                         $dFunctor1
                         @ ()
                         @ ()
                         GHC.Tuple.()
                         (Control.Monad.IO.Class.liftIO
                            @ m
                            $dMonadIO
                            @ ()
                            (Language.PureScript.Ide.Logging.$wrunLogger
                               @ GHC.Types.IO
                               @ ()
                               (case env of wild { Language.PureScript.Ide.Types.IdeEnvironment ds1 ds2 ->
                                case ds2 of wild1 { Language.PureScript.Ide.Types.IdeConfiguration ds4 ds5 ds3 ds6 ->
                                ds5 } })
                               (action
                                  `cast`
                                (Control.Monad.Trans.Reader.N:ReaderT[0]
                                     <*>_N
                                     <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                     <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                     <()>_N)
                                  env)))))) -}
"SPEC/Language.PureScript.Ide.Rebuild $fApplicativeLoggingT @ IO" [orphan] forall (v :: GHC.Base.Applicative
                                                                                          GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT
"SPEC/Language.PureScript.Ide.Rebuild $fApplicativeLoggingT_$c<*> @ IO" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                            GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT_$c<*> @ GHC.Types.IO
                                                   $dApplicative
  = Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*>
"SPEC/Language.PureScript.Ide.Rebuild $fFunctorLoggingT @ IO" [orphan] forall (v :: GHC.Base.Functor
                                                                                      GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fFunctorLoggingT
"SPEC/Language.PureScript.Ide.Rebuild $fFunctorLoggingT_$cfmap @ IO" [orphan] forall ($dFunctor :: GHC.Base.Functor
                                                                                                     GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT_$cfmap @ GHC.Types.IO
                                                $dFunctor
  = Language.PureScript.Ide.Rebuild.$s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap
"SPEC/Language.PureScript.Ide.Rebuild $fMonadIOExceptT @ (ReaderT
                                                           IdeEnvironment (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                                              (v :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                         Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                                                            GHC.Types.IO)))
  Control.Monad.Trans.Except.$fMonadIOExceptT @ (Control.Monad.Trans.Reader.ReaderT
                                                   Language.PureScript.Ide.Types.IdeEnvironment
                                                   (Control.Monad.Logger.LoggingT GHC.Types.IO))
                                              @ e
                                              v
  = Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT @ e
"SPEC/Language.PureScript.Ide.Rebuild $fMonadLoggingT @ IO" [orphan] forall (v :: GHC.Base.Monad
                                                                                    GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT_$s$fMonadLoggingT
"SPEC/Language.PureScript.Ide.Rebuild $fMonadLoggingT_$c>> @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                               GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$c>> @ GHC.Types.IO $dMonad
  = Language.PureScript.Ide.Rebuild.$s$fMonadIOExceptT_$s$fMonadLoggingT_$c>>
"SPEC/Language.PureScript.Ide.Rebuild $fMonadLoggingT_$creturn @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                   GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$creturn @ GHC.Types.IO
                                                $dMonad
  = Language.PureScript.Ide.Rebuild.$s$fMonadLoggingT_$creturn
"SPEC/Language.PureScript.Ide.Rebuild $fMonadReaderrExceptT @ IdeEnvironment @ (ReaderT
                                                                                 IdeEnvironment
                                                                                 (LoggingT IO)) _" [orphan] forall @ e
                                                                                                                                                                                                                                                                                                           (v :: Control.Monad.Reader.Class.MonadReader
                                                                                                                                                                                                                                                                                                                   Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                                                                                                                                      Language.PureScript.Ide.Types.IdeEnvironment
                                                                                                                                                                                                                                                                                                                      (Control.Monad.Logger.LoggingT
                                                                                                                                                                                                                                                                                                                         GHC.Types.IO)))
  Control.Monad.Reader.Class.$fMonadReaderrExceptT @ Language.PureScript.Ide.Types.IdeEnvironment
                                                   @ (Control.Monad.Trans.Reader.ReaderT
                                                        Language.PureScript.Ide.Types.IdeEnvironment
                                                        (Control.Monad.Logger.LoggingT
                                                           GHC.Types.IO))
                                                   @ e
                                                   v
  = Language.PureScript.Ide.Rebuild.$s$fMonadReaderrExceptT @ e
"SPEC/Language.PureScript.Ide.Rebuild fromList @ ModuleName" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                         Language.PureScript.Names.ModuleName)
  Data.Set.Internal.fromList @ Language.PureScript.Names.ModuleName
                             $dOrd
  = Language.PureScript.Ide.Rebuild.$sfromList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

