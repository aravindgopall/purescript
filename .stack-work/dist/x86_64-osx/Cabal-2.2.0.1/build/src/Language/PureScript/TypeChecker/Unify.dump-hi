
==================== FINAL INTERFACE ====================
2019-01-24 14:15:30.947758 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeChecker.Unify 8043
  interface hash: f24d1edefa35fc83cc6b391975ddc0cb
  ABI hash: f1e03e30856471f44252b03f30788ea2
  export-list hash: 85c9b2e7abdd78234543aea834d2a6f2
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: afb16d9ab106d8a7ac575997bd317adb
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.Unify.alignRowsWith
  Language.PureScript.TypeChecker.Unify.freshType
  Language.PureScript.TypeChecker.Unify.replaceTypeWildcards
  Language.PureScript.TypeChecker.Unify.replaceVarWithUnknown
  Language.PureScript.TypeChecker.Unify.solveType
  Language.PureScript.TypeChecker.Unify.substituteType
  Language.PureScript.TypeChecker.Unify.unifyRows
  Language.PureScript.TypeChecker.Unify.unifyTypes
  Language.PureScript.TypeChecker.Unify.unknownsInType
  Language.PureScript.TypeChecker.Unify.varIfUnknown
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0 boxes-0.1.5
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.5.11.0
                      deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      microlens-0.4.9.1 microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1 mtl-2.2.2
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 scientific-0.3.6.2
                      sourcemap-0.1.6 split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Function 6e6aae9442025aeeb92a909c1bbc3fca
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Ord 8579f16310a4ec69c00617051bb5c3d9
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  ConstrainedTypeUnified 68b349f446a11480294fdc6e451f3186
  ErrorUnifyingTypes edab054a8bacddb8d896e88d9265b15d
  HoleInferredType 785c100e33c3249a5b102046be9d34f6
  InfiniteType e2f4250f10f710caa807fa33adae8ad5
  TypesDoNotUnify 8366c89ce370f5cc8b8094dd4b727eaf
  WildcardInferredType 387efde14cc07acdcea42bcae7f2e8c8
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  SourceAnn f5708ed135df009dfa0254486771ef74
import  -/  Language.PureScript.Crash 3dd739d57f17e8a1e9cd97afd3faf067
  exports: a9d2725f359c2d113bd38076e88ec681
  internalError d33c2a09c5cbe8e68c0bc27d1500ba1a
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  exports: 8e61484c4664eceb943d9fc4820c721b
  MultipleErrors e1ef6a17348ccfe3ef65185d3c5f9026
  errorMessage 4308e76c0636918842d6acdb173a8e4b
  warnWithPosition 7ad80b7c006a458b8324a8a9926b1f43
import  -/  Language.PureScript.TypeChecker.Monad 5c6d6cca9d9f5acb98ab527615b54d6d
  exports: 64079f93a7ca5d81f53055abc7f8ac53
  CheckState 9cc3cef00c43c0c2ac24a31e9b521e29
  Substitution 6dc37f96b1ad41d81e906d34e56bda73
  checkNextType 9cc3cef00c43c0c2ac24a31e9b521e29
  checkSubstitution 9cc3cef00c43c0c2ac24a31e9b521e29
  getLocalContext 223085abf14117e3398e0e666d63e54f
  guardWith d2b3f12e05a1d4c8c1e59f1c8f3292d4
  substType 6dc37f96b1ad41d81e906d34e56bda73
  withErrorMessageHint 873c4b1b4503ece5c9a614f4d08067e6
import  -/  Language.PureScript.TypeChecker.Skolems d6f507247d13250d325e185be25fccdf
  exports: 301c96fa595b923bfcf06694e88d029f
  newSkolemConstant 91bed389ec61482f5cc2507a66413032
  skolemize ab7369b4aafebf4d012bef1d822de302
import  -/  Language.PureScript.Types 80a51f62cb3e6c71f024289b88f07b7f
  exports: 229bb7528146da886cffbefad5822e19
  ConstrainedType 7b7b9fe5fc37a912cec5b01815c7784d
  ForAll 0750974c4b3c816f0559c95f8418f903
  KindedType 7d9c2ac5dbbe89c236f431d3c9412617
  RCons baa72184843999f17a8e5f8391aabd36
  REmpty 55ca0a758aacaf511eb4882e2b81a0fc
  RowListItem 0e3231b388d844db12bae63a4b5c2cc0
  RowListItem 7b3cb6d68aaa473367a70ce66e9633f6
  Skolem aef73915115b060ec7781cdd3859082f
  SourceType 0ac818517c14fedd280ef5885ae0cdc3
  TUnknown 9d429c357e98c51eb9f7f00bef0a2346
  Type d5fc19231e8a71936895da17eade4f5b
  TypeApp 9dadf19674ff2d747cbba0c42dfad343
  TypeConstructor c7b7bcec494a17e684a206aeb55ef57b
  TypeLevelString 8a25ec25c9b44a7602f610ae833b697e
  TypeVar 9a7c02efa8540e6f48c3a672f3ebc8db
  TypeWildcard e8def149f21247f8f38af9a4e50f9298
  everythingOnTypes a337a56452e37b7c1eabcf74ce7ae28d
  everywhereOnTypes 5f3bf314ceb4b05babcebbff5592df13
  everywhereOnTypesM 3778d2154e8de7bd894aef40e0e2cb61
  mkForAll 32dbaffce5d1be85229c96393de9b357
  replaceTypeVars 8488f0f4aa30ef197cec44bf58c83ec2
  rowFromList 50b0e46715e1ec543fc59e157404928e
  rowListType 7b3cb6d68aaa473367a70ce66e9633f6
  rowToSortedList 4b3b610491cf3b7f844f72d9b818fe87
  srcTUnknown 6cb4247114dcda9fed6a924ce268a9c6
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
68c467dfe23ced7773cbab8cbafbdb5c
  $sinsert_$sgo13 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> a1
    -> Data.Map.Internal.Map GHC.Types.Int a1
    -> Data.Map.Internal.Map GHC.Types.Int a1
  {- Arity: 4, Strictness: <L,U><S(S),1*U(U)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: a1)
                   (w3 :: Data.Map.Internal.Map GHC.Types.Int a1) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.TypeChecker.Unify.$w$sgo13
                   @ a1
                   w
                   ww1
                   w2
                   w3 }) -}
b8c680e6bde02c8f89e37acd796a5639
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.Unify.$trModule3
                   Language.PureScript.TypeChecker.Unify.$trModule1) -}
b735db2b472e352f43fa3f1026dcdbdf
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Unify.$trModule2) -}
4b7b3bc5c68921a6b851ee274862d473
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.Unify"#) -}
5b8e3e4834069480c8d395d203c7a5f6
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Unify.$trModule4) -}
3b6516586195143e5788dd6e1a418a36
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
5a6232d8e2a278c4caf267a77a179c3a
  $w$sgo13 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Internal.Map GHC.Types.Int a1
    -> Data.Map.Internal.Map GHC.Types.Int a1
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
c31dbafa4176cd9eb241ce9c6b3d8130
  $walignRowsWith ::
    (Language.PureScript.Types.Type a
     -> Language.PureScript.Types.Type a -> r)
    -> Language.PureScript.Types.Type a
    -> Language.PureScript.Types.Type a
    -> (# [r],
          (([Language.PureScript.Types.RowListItem a],
            Language.PureScript.Types.Type a),
           ([Language.PureScript.Types.RowListItem a],
            Language.PureScript.Types.Type a)) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><L,1*U>,
     Inline: [0] -}
f846f8b98454f9a8d6bca42eab95369c
  $wouter ::
    GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> Data.Text.Internal.Fusion.Common.C [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Text.Internal.Text #)
  {- Arity: 5, Strictness: <L,U><S,U><S,1*U><S,U><S,U>,
     Inline: [0] -}
669eae8b6dd206dd34bc7e704c4a31b7
  $wpoly_go13 ::
    GHC.Prim.Int#
    -> Data.Map.Internal.Map GHC.Types.Int a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
7648109f8dfd4cc9e8d5481b9cc350b4
  $wtoName :: GHC.Prim.Int# -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Text.Internal.Text #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         Language.PureScript.TypeChecker.Unify.$wouter
                           ipv1
                           4#
                           (Data.Text.Internal.Fusion.Common.C1
                              @ [GHC.Types.Char]
                              (GHC.Types.: @ GHC.Types.Char ww5 ww6))
                           0#
                           ipv }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 } }) -}
ff75fc054b275abed7b89153621f3800
  alignRowsWith ::
    (Language.PureScript.Types.Type a
     -> Language.PureScript.Types.Type a -> r)
    -> Language.PureScript.Types.Type a
    -> Language.PureScript.Types.Type a
    -> ([r],
        (([Language.PureScript.Types.RowListItem a],
          Language.PureScript.Types.Type a),
         ([Language.PureScript.Types.RowListItem a],
          Language.PureScript.Types.Type a)))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><L,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ r
                   (w :: Language.PureScript.Types.Type a
                         -> Language.PureScript.Types.Type a -> r)
                   (w1 :: Language.PureScript.Types.Type a)
                   (w2 :: Language.PureScript.Types.Type a) ->
                 case Language.PureScript.TypeChecker.Unify.$walignRowsWith
                        @ a
                        @ r
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
527baf8b1affd32c2669a112140804d8
  freshType ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.Types.SourceType
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Types.Int
                   @ Language.PureScript.Types.SourceType
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ GHC.Types.Int
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          ds2 })))
                   (\ (t :: GHC.Types.Int) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ Language.PureScript.Types.SourceType
                      (let {
                         lvl20 :: GHC.Types.Int
                         = case t of wild { GHC.Types.I# x ->
                           GHC.Types.I# (GHC.Prim.+# x 1#) }
                       } in
                       Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                          (GHC.Tuple.(),
                           case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           Language.PureScript.TypeChecker.Monad.CheckState
                             ds
                             lvl20
                             ds2
                             ds3
                             ds4
                             ds5
                             ds6
                             ds7 })))
                      (GHC.Base.return
                         @ m
                         $dMonad
                         @ Language.PureScript.Types.SourceType
                         (Language.PureScript.Types.TUnknown
                            @ Language.PureScript.AST.SourcePos.SourceAnn
                            Language.PureScript.AST.SourcePos.$bNullSourceAnn
                            t)))) -}
b30732ae357f3767b78cc0b808260fa1
  occursCheck ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors m =>
    GHC.Types.Int -> Language.PureScript.Types.SourceType -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLL),U(1*U(U(U(C(C1(U)),1*C1(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,C(U),A),1*C1(U),A)><L,U(U)><S,1*U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   (eta :: GHC.Types.Int)
                   (eta1 :: Language.PureScript.Types.Type
                              Language.PureScript.AST.SourcePos.SourceAnn) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Error.Class.$p1MonadError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                 } in
                 case eta1 of wild {
                   DEFAULT
                   -> GHC.Base.<$
                        @ m
                        (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                        @ ()
                        @ (Language.PureScript.Types.Type
                             Language.PureScript.AST.SourcePos.SourceAnn)
                        GHC.Tuple.()
                        (let {
                           lvl20 :: m (Language.PureScript.Types.Type
                                         Language.PureScript.AST.SourcePos.SourceAnn)
                           = Control.Monad.Error.Class.throwError
                               @ Language.PureScript.Errors.MultipleErrors
                               @ m
                               $dMonadError
                               @ (Language.PureScript.Types.Type
                                    Language.PureScript.AST.SourcePos.SourceAnn)
                               (GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (Language.PureScript.AST.Declarations.ErrorMessage
                                     (GHC.Types.[]
                                        @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                     (Language.PureScript.AST.Declarations.InfiniteType wild))
                                  (GHC.Types.[]
                                     @ Language.PureScript.AST.Declarations.ErrorMessage))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                         } in
                         Language.PureScript.Types.everywhereOnTypesM
                           @ m
                           @ Language.PureScript.AST.SourcePos.SourceAnn
                           $dMonad
                           (\ (ds :: Language.PureScript.Types.Type
                                       Language.PureScript.AST.SourcePos.SourceAnn) ->
                            case ds of wild1 {
                              DEFAULT
                              -> GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (Language.PureScript.Types.Type
                                        Language.PureScript.AST.SourcePos.SourceAnn)
                                   wild1
                              Language.PureScript.Types.TUnknown ds1 u'
                              -> case eta of wild2 { GHC.Types.I# x ->
                                 case u' of wild3 { GHC.Types.I# y ->
                                 case GHC.Prim.==# x y of lwild {
                                   DEFAULT
                                   -> GHC.Base.return
                                        @ m
                                        $dMonad
                                        @ (Language.PureScript.Types.Type
                                             Language.PureScript.AST.SourcePos.SourceAnn)
                                        wild1
                                   1# -> lvl20 } } } })
                           wild)
                   Language.PureScript.Types.TUnknown ds ds1
                   -> GHC.Base.return @ m $dMonad @ () GHC.Tuple.() }) -}
e6f96d995c50d5ea91c10ec9b8abc834
  replaceTypeWildcards ::
    (Control.Monad.Writer.Class.MonadWriter
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m) =>
    Language.PureScript.Types.SourceType
    -> m Language.PureScript.Types.SourceType
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,U(1*U(1*U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,C(U),A),A,C(U),A,C(U))><L,U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><S,1*U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadWriter :: Control.Monad.Writer.Class.MonadWriter
                                       Language.PureScript.Errors.MultipleErrors m)
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Language.PureScript.Types.Type
                             Language.PureScript.AST.SourcePos.SourceAnn) ->
                 let {
                   lvl20 :: m Language.PureScript.Types.SourceType
                   = Language.PureScript.TypeChecker.Unify.freshType @ m $dMonadState
                 } in
                 let {
                   lvl21 :: m Language.PureScript.AST.Declarations.Context
                   = Language.PureScript.TypeChecker.Monad.getLocalContext
                       @ m
                       $dMonadState
                 } in
                 Language.PureScript.Types.everywhereOnTypesM
                   @ m
                   @ Language.PureScript.AST.SourcePos.SourceAnn
                   (Control.Monad.Writer.Class.$p2MonadWriter
                      @ Language.PureScript.Errors.MultipleErrors
                      @ m
                      $dMonadWriter)
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.State.Class.$p1MonadState
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState
                    } in
                    \ (ds :: Language.PureScript.Types.Type
                               (Language.PureScript.AST.SourcePos.SourceSpan,
                                [Language.PureScript.Comments.Comment])) ->
                    case ds of wild {
                      DEFAULT
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.PureScript.Types.Type
                                (Language.PureScript.AST.SourcePos.SourceSpan,
                                 [Language.PureScript.Comments.Comment]))
                           wild
                      Language.PureScript.Types.TypeWildcard ann name
                      -> let {
                           lvl22 :: Language.PureScript.AST.SourcePos.SourceSpan
                           = case ann of wild1 { (,) x ds1 -> x }
                         } in
                         let {
                           lvl23 :: Language.PureScript.AST.Declarations.ErrorMessage
                                    -> Language.PureScript.AST.Declarations.ErrorMessage
                             {- Arity: 1 -}
                           = Language.PureScript.Errors.withPosition lvl22
                         } in
                         let {
                           lvl24 :: [Language.PureScript.AST.Declarations.ErrorMessage]
                                    -> [Language.PureScript.AST.Declarations.ErrorMessage]
                             {- Arity: 1 -}
                           = GHC.Base.map
                               @ Language.PureScript.AST.Declarations.ErrorMessage
                               @ Language.PureScript.AST.Declarations.ErrorMessage
                               lvl23
                         } in
                         GHC.Base.>>=
                           @ m
                           $dMonad
                           @ Language.PureScript.Types.SourceType
                           @ Language.PureScript.Types.SourceType
                           lvl20
                           (\ (t :: Language.PureScript.Types.SourceType) ->
                            let {
                              lvl25 :: m Language.PureScript.Types.SourceType
                              = GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ Language.PureScript.Types.SourceType
                                  t
                            } in
                            GHC.Base.>>=
                              @ m
                              $dMonad
                              @ Language.PureScript.AST.Declarations.Context
                              @ Language.PureScript.Types.SourceType
                              lvl21
                              (\ (ctx :: Language.PureScript.AST.Declarations.Context) ->
                               GHC.Base.>>
                                 @ m
                                 $dMonad
                                 @ ()
                                 @ Language.PureScript.Types.SourceType
                                 (Control.Monad.Writer.Class.censor
                                    @ Language.PureScript.Errors.MultipleErrors
                                    @ m
                                    @ ()
                                    $dMonadWriter
                                    lvl24
                                      `cast`
                                    (Sym (Language.PureScript.Errors.N:MultipleErrors[0])
                                     ->_R Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                                    (Control.Monad.Writer.Class.tell
                                       @ Language.PureScript.Errors.MultipleErrors
                                       @ m
                                       $dMonadWriter
                                       (GHC.Types.:
                                          @ Language.PureScript.AST.Declarations.ErrorMessage
                                          (Language.PureScript.AST.Declarations.ErrorMessage
                                             (GHC.Types.[]
                                                @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                             (case name of wild1 {
                                                GHC.Base.Nothing
                                                -> Language.PureScript.AST.Declarations.WildcardInferredType
                                                     t
                                                     ctx
                                                GHC.Base.Just x
                                                -> Language.PureScript.AST.Declarations.HoleInferredType
                                                     x
                                                     t
                                                     ctx
                                                     (GHC.Base.Nothing
                                                        @ Language.PureScript.AST.Declarations.TypeSearch) }))
                                          (GHC.Types.[]
                                             @ Language.PureScript.AST.Declarations.ErrorMessage))
                                         `cast`
                                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                                 lvl25)) })
                   eta) -}
8f647d768ad8e4d90f292540b8237e9b
  replaceVarWithUnknown ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Data.Text.Internal.Text
    -> Language.PureScript.Types.SourceType
    -> m Language.PureScript.Types.SourceType
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Data.Text.Internal.Text)
                   (eta1 :: Language.PureScript.Types.SourceType) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ Language.PureScript.Types.SourceType
                   @ Language.PureScript.Types.SourceType
                   (Language.PureScript.TypeChecker.Unify.freshType @ m $dMonadState)
                   (\ (tu :: Language.PureScript.Types.SourceType) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ (Language.PureScript.Types.Type
                           Language.PureScript.AST.SourcePos.SourceAnn)
                      (Language.PureScript.Types.replaceAllTypeVars_go
                         @ Language.PureScript.AST.SourcePos.SourceAnn
                         @ Language.PureScript.AST.SourcePos.SourceAnn
                         (GHC.Types.[] @ Data.Text.Internal.Text)
                         (GHC.Types.:
                            @ (Data.Text.Internal.Text,
                               Language.PureScript.Types.Type
                                 Language.PureScript.AST.SourcePos.SourceAnn)
                            (eta, tu)
                            (GHC.Types.[]
                               @ (Data.Text.Internal.Text,
                                  Language.PureScript.Types.Type
                                    Language.PureScript.AST.SourcePos.SourceAnn)))
                         eta1))) -}
9b3fb9fefe8534f147cdcff8a6cbae13
  solveType ::
    (Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m) =>
    GHC.Types.Int -> Language.PureScript.Types.SourceType -> m ()
  {- Arity: 4,
     Strictness: <S(S(LLC(C(S))LL)LL),U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),1*C1(C1(U)),C(U),A),C(U),A)><L,1*U(A,A,A,1*C1(U))><L,U(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m)
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: GHC.Types.Int)
                   (eta1 :: Language.PureScript.Types.SourceType) ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Error.Class.$p1MonadError
                      @ Language.PureScript.Errors.MultipleErrors
                      @ m
                      $dMonadError)
                   @ ()
                   @ ()
                   (Language.PureScript.TypeChecker.Unify.occursCheck
                      @ m
                      $dMonadError
                      eta
                      eta1)
                   (Control.Monad.State.Class.state
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState
                      @ ()
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       (GHC.Tuple.(),
                        case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                        Language.PureScript.TypeChecker.Monad.CheckState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          (case ds6 of wild1 { Language.PureScript.TypeChecker.Monad.Substitution ds8 ds9 ->
                           Language.PureScript.TypeChecker.Monad.Substitution
                             (Language.PureScript.TypeChecker.Unify.$sinsert_$sgo13
                                @ (Language.PureScript.Types.Type
                                     Language.PureScript.AST.SourcePos.SourceAnn)
                                eta
                                eta
                                eta1
                                ds8)
                             ds9 })
                          ds7 })))) -}
84a2cb6a429d91c98237ddbf8b2c5705
  substituteType ::
    Language.PureScript.TypeChecker.Monad.Substitution
    -> Language.PureScript.Types.SourceType
    -> Language.PureScript.Types.SourceType
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,A)><S,1*U> -}
97b7f7b5f251fabaf9485f6ed0805f15
  unifyRows ::
    (Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m) =>
    Language.PureScript.Types.SourceType
    -> Language.PureScript.Types.SourceType -> m ()
  {- Arity: 4,
     Strictness: <S(S(S(LLLLC(C(S))L)LLLL)LL),U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),C(C1(U)),A),C(C1(U)),C(C1(U)),C(U),A),C(U),C(C1(U)))><L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U><L,U> -}
58256f6c1ba2ea04f6e802cdc965b287
  unifyTypes ::
    (Control.Monad.Error.Class.MonadError
       Language.PureScript.Errors.MultipleErrors m,
     Control.Monad.State.Class.MonadState
       Language.PureScript.TypeChecker.Monad.CheckState m) =>
    Language.PureScript.Types.SourceType
    -> Language.PureScript.Types.SourceType -> m ()
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)LL),U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),C(C1(U)),A),C(C1(U)),C(C1(U)),C(U),A),C(U),C(C1(U)))><L,U(U(A,C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><L,U><L,U> -}
f5938e8c26386b124f071f997ebdd608
  unknownsInType ::
    Language.PureScript.Types.Type a -> [(a, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (t :: Language.PureScript.Types.Type a) ->
                 Language.PureScript.Types.everythingOnTypes
                   @ ([(a, GHC.Types.Int)] -> [(a, GHC.Types.Int)])
                   @ a
                   (GHC.Base..
                      @ [(a, GHC.Types.Int)]
                      @ [(a, GHC.Types.Int)]
                      @ [(a, GHC.Types.Int)])
                   (Language.PureScript.TypeChecker.Unify.unknownsInType1 @ a)
                   t
                   (GHC.Types.[] @ (a, GHC.Types.Int))) -}
e1ddc2d3c34e8c163a4c5a10721849f7
  unknownsInType1 ::
    Language.PureScript.Types.Type a
    -> [(a, GHC.Types.Int)] -> [(a, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (ds :: Language.PureScript.Types.Type a)
                   (eta :: [(a, GHC.Types.Int)]) ->
                 case ds of wild {
                   DEFAULT -> eta
                   Language.PureScript.Types.TUnknown ann u
                   -> GHC.Types.: @ (a, GHC.Types.Int) (ann, u) eta }) -}
0b3576ea6a1d1cc420f6433c06e7fd84
  varIfUnknown ::
    Language.PureScript.Types.SourceType
    -> Language.PureScript.Types.SourceType
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ty :: Language.PureScript.Types.SourceType) ->
                 Language.PureScript.TypeChecker.Unify.varIfUnknown_go2
                   (Data.OldList.sortBy
                      @ (Language.PureScript.AST.SourcePos.SourceAnn,
                         Data.Text.Internal.Text)
                      Language.PureScript.TypeChecker.Unify.varIfUnknown4
                      (GHC.Base.map
                         @ (Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)
                         @ (Language.PureScript.AST.SourcePos.SourceAnn,
                            Data.Text.Internal.Text)
                         Language.PureScript.TypeChecker.Unify.varIfUnknown3
                         (Data.OldList.nubBy
                            @ (Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)
                            Language.PureScript.TypeChecker.Unify.varIfUnknown2
                            (Language.PureScript.Types.everythingOnTypes
                               @ ([(Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)]
                                  -> [(Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)])
                               @ Language.PureScript.AST.SourcePos.SourceAnn
                               (GHC.Base..
                                  @ [(Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)]
                                  @ [(Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)]
                                  @ [(Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)])
                               (Language.PureScript.TypeChecker.Unify.unknownsInType1
                                  @ Language.PureScript.AST.SourcePos.SourceAnn)
                               ty
                               (GHC.Types.[]
                                  @ (Language.PureScript.AST.SourcePos.SourceAnn,
                                     GHC.Types.Int))))))
                   (Language.PureScript.Types.everywhereOnTypes
                      @ Language.PureScript.AST.SourcePos.SourceAnn
                      Language.PureScript.TypeChecker.Unify.varIfUnknown1
                      ty)) -}
2c593754d10eee79eade5c96e0d7e9da
  varIfUnknown1 ::
    Language.PureScript.Types.Type
      Language.PureScript.AST.SourcePos.SourceAnn
    -> Language.PureScript.Types.SourceType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Types.Type
                            Language.PureScript.AST.SourcePos.SourceAnn) ->
                 case ds of wild {
                   DEFAULT -> wild
                   Language.PureScript.Types.TUnknown ann u
                   -> Language.PureScript.Types.TypeVar
                        @ Language.PureScript.AST.SourcePos.SourceAnn
                        ann
                        (Language.PureScript.TypeChecker.Unify.varIfUnknown_toName u) }) -}
046a6c5e5ab5f3595e000ea895749d57
  varIfUnknown2 ::
    (Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)
    -> (Language.PureScript.AST.SourcePos.SourceAnn, GHC.Types.Int)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(A,1*U(U))><S(LS(S)),1*U(A,1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (Language.PureScript.AST.SourcePos.SourceAnn,
                          GHC.Types.Int))
                   (y :: (Language.PureScript.AST.SourcePos.SourceAnn,
                          GHC.Types.Int))[OneShot] ->
                 case x of wild { (,) ds1 y1 ->
                 case y of wild1 { (,) ds2 y2 -> GHC.Classes.eqInt y1 y2 } }) -}
04c346dcdfc415d125c3a5e260b3b819
  varIfUnknown3 ::
    ((Language.PureScript.AST.SourcePos.SourceSpan,
      [Language.PureScript.Comments.Comment]),
     GHC.Types.Int)
    -> ((Language.PureScript.AST.SourcePos.SourceSpan,
         [Language.PureScript.Comments.Comment]),
        Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <S,1*U(U,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ((Language.PureScript.AST.SourcePos.SourceSpan,
                            [Language.PureScript.Comments.Comment]),
                           GHC.Types.Int)) ->
                 case ds of wild { (,) x y ->
                 (x,
                  Language.PureScript.TypeChecker.Unify.varIfUnknown_toName y) }) -}
0bbfe9dde7e71b8fd6e1ae0f91fe934b
  varIfUnknown4 ::
    (Language.PureScript.AST.SourcePos.SourceAnn,
     Data.Text.Internal.Text)
    -> (Language.PureScript.AST.SourcePos.SourceAnn,
        Data.Text.Internal.Text)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(SSS)),1*U(A,1*U(U,U,U))><S(LS(SSS)),1*U(A,1*U(U,U,U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (Language.PureScript.AST.SourcePos.SourceAnn,
                          Data.Text.Internal.Text))
                   (y :: (Language.PureScript.AST.SourcePos.SourceAnn,
                          Data.Text.Internal.Text))[OneShot] ->
                 case x of wild { (,) ds1 y1 ->
                 case y of wild1 { (,) ds2 y2 ->
                 Data.Text.$fOrdText_$ccompare y1 y2 } }) -}
c7d8f8679d30ddff2ca43eb824e65876
  varIfUnknown_go2 ::
    [(Language.PureScript.AST.SourcePos.SourceAnn,
      Data.Text.Internal.Text)]
    -> Language.PureScript.Types.Type
         Language.PureScript.AST.SourcePos.SourceAnn
    -> Language.PureScript.Types.Type
         Language.PureScript.AST.SourcePos.SourceAnn
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
0a879e3021cb275b5e34f3e3347b2d01
  varIfUnknown_toName :: GHC.Types.Int -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.TypeChecker.Unify.$wtoName ww1 }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

