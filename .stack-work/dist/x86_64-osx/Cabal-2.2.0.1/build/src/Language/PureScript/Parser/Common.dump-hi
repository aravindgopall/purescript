
==================== FINAL INTERFACE ====================
2019-01-24 14:13:41.834592 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Parser.Common 8043
  interface hash: 64c2a8297456b8cfdc39e5e53c9fdabc
  ABI hash: d20a7af8a890a4e56d3068b2fdbe8def
  export-list hash: d3c94bc3b21495d0d5e265869136cfdc
  orphan hash: 8ba49e6e86ed91d668aa7137f014bd2e
  flag hash: af801e39deabea4814ba66209bc490c9
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Parser.Common.augment
  Language.PureScript.Parser.Common.buildPostfixParser
  Language.PureScript.Parser.Common.checkIndentation
  Language.PureScript.Parser.Common.dataConstructorName
  Language.PureScript.Parser.Common.fold
  Language.PureScript.Parser.Common.indented
  Language.PureScript.Parser.Common.kindName
  Language.PureScript.Parser.Common.mark
  Language.PureScript.Parser.Common.moduleName
  Language.PureScript.Parser.Common.parseIdent
  Language.PureScript.Parser.Common.parseLabel
  Language.PureScript.Parser.Common.parseOperator
  Language.PureScript.Parser.Common.parseQualified
  Language.PureScript.Parser.Common.properName
  Language.PureScript.Parser.Common.readComments
  Language.PureScript.Parser.Common.runTokenParser
  Language.PureScript.Parser.Common.same
  Language.PureScript.Parser.Common.toSourcePos
  Language.PureScript.Parser.Common.typeName
  Language.PureScript.Parser.Common.withSourceAnnF
  Language.PureScript.Parser.Common.withSourceSpan
  Language.PureScript.Parser.Common.withSourceSpan'
  Language.PureScript.Parser.Common.withSourceSpanF
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST.SourcePos
                     Language.PureScript.Comments Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State
package dependencies: aeson-1.3.1.1 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      mtl-2.2.2 parsec-3.1.13.0 pretty-1.1.3.6 primitive-0.6.3.0
                      random-1.1 scientific-0.3.6.2 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  parsec-3.1.13.0:Text.Parsec 963cbe7b4116cef91451434dc005a011
import  -/  parsec-3.1.13.0:Text.Parsec.Combinator 86d872425bd48a2d67c0d1ce1a8ccc8b
import  -/  parsec-3.1.13.0:Text.Parsec.Error 5c35aa426bd1cd52bcab90d9a1e3ce4c
import  -/  parsec-3.1.13.0:Text.Parsec.Pos 85d30a347a2120f1b5f286869826a471
import  -/  parsec-3.1.13.0:Text.Parsec.Prim 4e0ad30f54008188b8c54f509e1a8ed9
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  exports: a1e32a05596348684f99f9072c553e2b
  SourceAnn f5708ed135df009dfa0254486771ef74
  SourcePos 1f89874c7dcd77e53f0f74e4d28f0a8c
  SourcePos 1e0cf2bd3ea18f97a2ff152297f09219
  SourceSpan 153dcf157f0acf76a2cdcf153aac30d3
  SourceSpan 1e0cf2bd3ea18f97a2ff152297f09219
import  -/  Language.PureScript.Comments 1a682522a2f855328ca87bb68705794c
  exports: 9921c985b3279420b3b7a2b7ccc8b32e
  Comment 2e827a5b834f92cc9beef533348585fa
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  exports: ad7ae34f85124c68e8ba1c90fb2e732f
  ConstructorName 84054a8bbbe827ba2ce7da83056a95ee
  Ident 71f167265716f619863a793fa311e198
  Ident bad3562aa6138b6192713ac281080869
  KindName 7782d66ce60bd67282cf566485701e07
  ModuleName e77bf9e056798332a9668212060e8e06
  ModuleName 1b2ddf0c04464d2fa2588925f10c1966
  OpName 1de386ff6f2b8aed453243e73483f454
  OpName 9af301165f72160425c5e0dde6525338
  ProperName f69d3801241fcb4773f1284cd28f2dee
  ProperName a7268334e0b909381550b9329cb80fcc
  Qualified b6e1bc9e7244a41d3c6149c9b5c2d6d8
  Qualified 1b2ddf0c04464d2fa2588925f10c1966
  TypeName 40ce511c66a72431b4e87351210f7b03
import  -/  Language.PureScript.PSString 482bcd39d274b3e3efbde5749bd9d797
  exports: dedd5d31dc509736134f041863efd1d4
  PSString 96ffea2472d48cda76cc39d47ab7bb82
  mkString a727d038908a3b0e30ed0d1d71565e4b
import  -/  Language.PureScript.Parser.Lexer ea857194274ee8b3812ad62bbb2c9ed1
  exports: ca7efc854dfe3379de291b0f8c8d7ea0
  PositionedToken bc5773f44100b87481d9bda3f9e246b7
  TokenParser 6e8d7b68c7546ba407a16e8526c7556f
  dconsname d4e1a14321595b7f35da211d957677b6
  identifier 694a9255e1b6cb3d8c5e23ccd5c0704b
  kiname 3d9765d6ed6aa1077d78b41f3ed8217e
  lname e6d2248b6cef9835fc21ed990a9a9f5a
  mname ddb7a12738546f3d739d4eae51236357
  ptComments bc5773f44100b87481d9bda3f9e246b7
  ptPrevEndPos bc5773f44100b87481d9bda3f9e246b7
  qualifier 10d4e9a621b54ed0a86368b9d31aa39c
  stringLiteral 07d9c3a7dcb697ede90a3401e8d445d0
  symbol 99f9bd1c3cc328461c9c3f0e625dbd70
  tyname bad2b5d5088002f28817c15bc5b31705
  uname d26aa9b1095a33d7b2bed5c0902c7f7c
import  -/  Language.PureScript.Parser.State 30ecb6d393d258ed6a43e1772eca1abf
  exports: dd6ef157d2027be1acaee486dc7fca19
  ParseState 9509774a216185e71910825a8de6b17e
  ParseState 62a6f136821eff488575d67f3b51d3ef
  indentationLevel 62a6f136821eff488575d67f3b51d3ef
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  text-1.2.3.0:Data.Text.Show 3b4b6fb2985a731022d67f636682da2b
1bff77ced8ea1dc9025e17d30aa4b591
  $s$fStream[]mtok ::
    Text.Parsec.Prim.Stream [tok] Data.Functor.Identity.Identity tok
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ tok.
                  @ [tok]
                  @ Data.Functor.Identity.Identity
                  @ tok
                  Data.Functor.Identity.$fMonadIdentity
                  (Language.PureScript.Parser.Common.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
                     @ tok) -}
a30d686880dbda51b05080f4d8fb4da8
  $s$fStream[]mtok_$s$fStream[]mtok_$cuncons ::
    [tok]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok]))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ tok (ds :: [tok]) ->
                 case ds of wild {
                   []
                   -> (GHC.Base.Nothing @ (tok, [tok]))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R))
                   : t ts
                   -> (GHC.Base.Just @ (tok, [tok]) (t, ts))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R)) }) -}
b6a4d7d91e859c7857f0896911a1a2d6
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Parser.Common.$trModule3
                   Language.PureScript.Parser.Common.$trModule1) -}
914bf44b3107fa21d3452173e1a51e9c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Common.$trModule2) -}
eed57dfc6c49d4aabe039d6d718db3b7
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.Parser.Common"#) -}
9bc74fe589030334645621e6318639a7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Common.$trModule4) -}
95bb2732238522020627892108c7b57b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
2477d28ae3fd54a3eefb12c17487ac46
  $waugment ::
    Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m b
    -> (a -> b -> a)
    -> forall b1.
       Text.Parsec.Prim.State s u
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> m b1
  {- Arity: 8, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: (\ @ s
                   @ m :: * -> *
                   @ t
                   @ u
                   @ a
                   @ b
                   (w :: Text.Parsec.Prim.ParsecT s u m a)
                   (w1 :: Text.Parsec.Prim.ParsecT s u m b)
                   (w2 :: a -> b -> a)
                   @ b1
                   (w3 :: Text.Parsec.Prim.State s u)
                   (w4 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b1)
                   (w5 :: Text.Parsec.Error.ParseError -> m b1)
                   (w6 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b1)
                   (w7 :: Text.Parsec.Error.ParseError -> m b1) ->
                 let {
                   f :: a -> GHC.Base.Maybe b -> a
                     {- Arity: 2, Strictness: <L,U><S,1*U>,
                        Unfolding: InlineRule (2, True, False)
                                   (\ (x :: a) (y :: GHC.Base.Maybe b) ->
                                    case y of wild {
                                      GHC.Base.Nothing -> x GHC.Base.Just x1 -> w2 x x1 }) -}
                   = \ (x :: a) (y :: GHC.Base.Maybe b) ->
                     case y of wild {
                       GHC.Base.Nothing -> x GHC.Base.Just x1 -> w2 x x1 }
                 } in
                 Text.Parsec.Prim.$fAlternativeParsecT2
                   @ s
                   @ u
                   @ m
                   @ (GHC.Base.Maybe b)
                   @ a
                   (\ @ b2
                      (s1 :: Text.Parsec.Prim.State s u)[OneShot]
                      (cok :: (GHC.Base.Maybe b -> a)
                              -> Text.Parsec.Prim.State s u
                              -> Text.Parsec.Error.ParseError
                              -> m b2)[OneShot]
                      (cerr :: Text.Parsec.Error.ParseError -> m b2)[OneShot]
                      (eok :: (GHC.Base.Maybe b -> a)
                              -> Text.Parsec.Prim.State s u
                              -> Text.Parsec.Error.ParseError
                              -> m b2)[OneShot]
                      (eerr :: Text.Parsec.Error.ParseError -> m b2)[OneShot] ->
                    w `cast` (Text.Parsec.Prim.N:ParsecT[0] <s>_R <u>_R <m>_R <a>_R)
                      @ b2
                      s1
                      (\ (x :: a) -> cok (f x))
                      cerr
                      (\ (x :: a) -> eok (f x))
                      eerr)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <s>_R <u>_R <m>_R <GHC.Base.Maybe b -> a>_R))
                   (\ @ b2
                      (w8 :: Text.Parsec.Prim.State s u)
                      (w9 :: GHC.Base.Maybe b
                             -> Text.Parsec.Prim.State s u
                             -> Text.Parsec.Error.ParseError
                             -> m b2)[OneShot]
                      (w10 :: Text.Parsec.Error.ParseError -> m b2)[OneShot]
                      (w11 :: GHC.Base.Maybe b
                              -> Text.Parsec.Prim.State s u
                              -> Text.Parsec.Error.ParseError
                              -> m b2)[OneShot]
                      (w12 :: Text.Parsec.Error.ParseError -> m b2)[OneShot] ->
                    Text.Parsec.Combinator.$woptionMaybe
                      @ s
                      @ m
                      @ t
                      @ u
                      @ b
                      w1
                      @ b2
                      w8
                      w9
                      w10
                      w11)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <s>_R <u>_R <m>_R <GHC.Base.Maybe b>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
e5660195875f058f00324e11058092a6
  $wbuildPostfixParser ::
    [a -> Text.Parsec.Prim.ParsecT s u m a]
    -> Text.Parsec.Prim.ParsecT s u m a
    -> forall b.
       Text.Parsec.Prim.State s u
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b)
       -> (Text.Parsec.Error.ParseError -> m b)
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b)
       -> (Text.Parsec.Error.ParseError -> m b)
       -> m b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,U><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [0] -}
3d409bbddf2d75505e78091d34450f56
  $wcheckIndentation ::
    (Text.Parsec.Pos.Column -> Data.Text.Internal.Text)
    -> (Text.Parsec.Pos.Column
        -> Text.Parsec.Pos.Column -> GHC.Types.Bool)
    -> forall b.
       Text.Parsec.Prim.State
         s Language.PureScript.Parser.State.ParseState
       -> (()
           -> Text.Parsec.Prim.State
                s Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,1*C1(U(U,U,U))><C(C(S)),1*C1(C1(U))><L,U(U,U(U,U,U),U(U))><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0] -}
3c6434aab40201adbb98021f045e09f5
  $wdataConstructorName ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.ConstructorName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.ProperName
                           'Language.PureScript.Names.ConstructorName
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp1
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w x `cast`
                      (Sym (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.ConstructorName>_P)))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.dconsname2 }))) -}
4ad43784104661d2c64a26f1e83bca92
  $windented :: GHC.Prim.Int# -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
c85599b5f417781aeab5b512ef2428c8
  $wkindName ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.KindName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.ProperName
                           'Language.PureScript.Names.KindName
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp1
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w x `cast`
                      (Sym (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.KindName>_P)))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.kiname2 }))) -}
9a02d3e467d87825c70ade2d2f4954dd
  $wparseIdent ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.Ident
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.Ident
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp3
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w (Language.PureScript.Names.Ident x))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.identifier2 }))) -}
7d1e04dc002f08001d72c1e57ac69a16
  $wparseLabel ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,U><L,U><L,U><L,C(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.PSString.PSString
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Lexer.$wp5
                   @ b
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w (Language.PureScript.PSString.mkString1 x)
                        `cast`
                      (Sym (Language.PureScript.PSString.N:PSString[0])))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    Language.PureScript.Parser.Lexer.$wp10
                      @ b
                      ww
                      ww1
                      ww2
                      w
                      (\ (err1 :: Text.Parsec.Error.ParseError)[OneShot] ->
                       w1
                         (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                          case Text.Parsec.Prim.$wsetExpectErrors
                                 ww4
                                 ww5
                                 Language.PureScript.Parser.Lexer.identifier2 of ww6 { Text.Parsec.Error.ParseError ww7 ww8 ->
                          case ww7 of ww9 { Text.Parsec.Pos.SourcePos ww10 ww11 ww12 ->
                          case err1 of ww13 { Text.Parsec.Error.ParseError ww14 ww15 ->
                          case Text.Parsec.Prim.$wsetExpectErrors
                                 ww14
                                 ww15
                                 Language.PureScript.Parser.Lexer.stringLiteral2 of ww16 { Text.Parsec.Error.ParseError ww17 ww18 ->
                          case ww17 of ww19 { Text.Parsec.Pos.SourcePos ww20 ww21 ww22 ->
                          case Text.Parsec.Error.$wmergeError
                                 ww10
                                 ww11
                                 ww12
                                 ww8
                                 ww20
                                 ww21
                                 ww22
                                 ww18 of ww23 { (#,#) ww24 ww25 ->
                          Text.Parsec.Error.ParseError ww24 ww25 } } } } } } })))) -}
c66bdc7334830a92e791aebfc53bf279
  $wparseOperator ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.OpName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ a :: Language.PureScript.Names.OpNameType
                   @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.OpName a
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp11
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w x `cast` (Sym (Language.PureScript.Names.N:OpName[0] <a>_P)))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.symbol2 }))) -}
a395cdfed421f72b426b6c2edc004601
  $wparseQualified ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> forall b.
       [Language.PureScript.Parser.Lexer.PositionedToken]
       -> Text.Parsec.Pos.SourcePos
       -> Language.PureScript.Parser.State.ParseState
       -> (Language.PureScript.Names.Qualified a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Language.PureScript.Names.Qualified a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 8,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><S,U><L,U><L,U><L,C(U)><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0] -}
87fffa77c0a9b6fe1e8f35ba9fee2711
  $wpart ::
    [Language.PureScript.Names.ProperName
       'Language.PureScript.Names.Namespace]
    -> forall b.
       [Language.PureScript.Parser.Lexer.PositionedToken]
       -> Text.Parsec.Pos.SourcePos
       -> Language.PureScript.Parser.State.ParseState
       -> (Language.PureScript.Names.ModuleName
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <L,U><S,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)><L,C(U)>,
     Inline: [0] -}
1a679706340543ccff475c533ee0450f
  $wproperName ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ a :: Language.PureScript.Names.ProperNameType
                   @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.ProperName a
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp12
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text) ->
                    w x `cast` (Sym (Language.PureScript.Names.N:ProperName[0] <a>_P)))
                   (\ (err :: Text.Parsec.Error.ParseError) ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.uname2 }))) -}
a3aadb5f95fa9c328e3b0e2ffa35f6ec
  $wsame :: GHC.Prim.Int# -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
d3cc9d6ad784613fbff54d530402d3d9
  $wtypeName ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.TypeName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Names.ProperName
                           'Language.PureScript.Names.TypeName
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Lexer.$wp1
                   @ b1
                   ww
                   ww1
                   ww2
                   (\ (x :: Data.Text.Internal.Text)[OneShot] ->
                    w x `cast`
                      (Sym (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.TypeName>_P)))
                   (\ (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    w1
                      (case err of ww3 { Text.Parsec.Error.ParseError ww4 ww5 ->
                       Text.Parsec.Prim.$wsetExpectErrors
                         ww4
                         ww5
                         Language.PureScript.Parser.Lexer.tyname2 }))) -}
b0edc0207a63731535725006cf8bb489
  augment ::
    Text.Parsec.Prim.Stream s m t =>
    Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m b
    -> (a -> b -> a)
    -> Text.Parsec.Prim.ParsecT s u m a
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,A><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.augment1
                  `cast`
                (forall (s :: <*>_N) (m :: <*
                                            -> *>_N) (t :: <*>_N) (u :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Parsec.Prim.Stream s m t>_R
                 ->_R <Text.Parsec.Prim.ParsecT s u m a>_R
                 ->_R <Text.Parsec.Prim.ParsecT s u m b>_R
                 ->_R <a -> b -> a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <s>_R <u>_R <m>_R <a>_R)) -}
6bbff29635dadae7709c972a3e05ef43
  augment1 ::
    Text.Parsec.Prim.Stream s m t =>
    Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m b
    -> (a -> b -> a)
    -> forall b1.
       Text.Parsec.Prim.State s u
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> m b1
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,A><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: InlineRule (9, True, True)
                (\ @ s
                   @ m :: * -> *
                   @ t
                   @ u
                   @ a
                   @ b
                   (w :: Text.Parsec.Prim.Stream s m t)
                   (w1 :: Text.Parsec.Prim.ParsecT s u m a)
                   (w2 :: Text.Parsec.Prim.ParsecT s u m b)
                   (w3 :: a -> b -> a)
                   @ b1
                   (w4 :: Text.Parsec.Prim.State s u)
                   (w5 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b1)
                   (w6 :: Text.Parsec.Error.ParseError -> m b1)
                   (w7 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b1)
                   (w8 :: Text.Parsec.Error.ParseError -> m b1) ->
                 Language.PureScript.Parser.Common.$waugment
                   @ s
                   @ m
                   @ t
                   @ u
                   @ a
                   @ b
                   w1
                   w2
                   w3
                   @ b1
                   w4
                   w5
                   w6
                   w7
                   w8) -}
0028a0425b67ec725fd838daa9893fd2
  buildPostfixParser ::
    Text.Parsec.Prim.Stream s m t =>
    [a -> Text.Parsec.Prim.ParsecT s u m a]
    -> Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m a
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,A><L,U><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.buildPostfixParser1
                  `cast`
                (forall (s :: <*>_N) (m :: <*
                                            -> *>_N) (t :: <*>_N) (a :: <*>_N) (u :: <*>_N).
                 <Text.Parsec.Prim.Stream s m t>_R
                 ->_R <[a -> Text.Parsec.Prim.ParsecT s u m a]>_R
                 ->_R <Text.Parsec.Prim.ParsecT s u m a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <s>_R <u>_R <m>_R <a>_R)) -}
981c12fa94de5a1bcfccce5f4d19cedd
  buildPostfixParser1 ::
    Text.Parsec.Prim.Stream s m t =>
    [a -> Text.Parsec.Prim.ParsecT s u m a]
    -> Text.Parsec.Prim.ParsecT s u m a
    -> forall b.
       Text.Parsec.Prim.State s u
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b)
       -> (Text.Parsec.Error.ParseError -> m b)
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b)
       -> (Text.Parsec.Error.ParseError -> m b)
       -> m b
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,A><L,U><C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: InlineRule (8, True, True)
                (\ @ s
                   @ m :: * -> *
                   @ t
                   @ a
                   @ u
                   (w :: Text.Parsec.Prim.Stream s m t)
                   (w1 :: [a -> Text.Parsec.Prim.ParsecT s u m a])
                   (w2 :: Text.Parsec.Prim.ParsecT s u m a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State s u)
                   (w4 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b)
                   (w5 :: Text.Parsec.Error.ParseError -> m b)
                   (w6 :: a
                          -> Text.Parsec.Prim.State s u
                          -> Text.Parsec.Error.ParseError
                          -> m b)
                   (w7 :: Text.Parsec.Error.ParseError -> m b) ->
                 Language.PureScript.Parser.Common.$wbuildPostfixParser
                   @ s
                   @ m
                   @ t
                   @ a
                   @ u
                   w1
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
3e03a70b0bc15276f31306755da25033
  checkIndentation ::
    (Text.Parsec.Pos.Column -> Data.Text.Internal.Text)
    -> (Text.Parsec.Pos.Column
        -> Text.Parsec.Pos.Column -> GHC.Types.Bool)
    -> Text.Parsec.Prim.Parsec
         s Language.PureScript.Parser.State.ParseState ()
  {- Arity: 7,
     Strictness: <L,1*C1(U(U,U,U))><C(C(S)),1*C1(C1(U))><L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.checkIndentation1
                  `cast`
                (forall (s :: <*>_N).
                 <Text.Parsec.Pos.Column -> Data.Text.Internal.Text>_R
                 ->_R <Text.Parsec.Pos.Column
                       -> Text.Parsec.Pos.Column -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <s>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <()>_R)) -}
27cd9c18c1286772bfaf8f5435a80026
  checkIndentation1 ::
    (Text.Parsec.Pos.Column -> Data.Text.Internal.Text)
    -> (Text.Parsec.Pos.Column
        -> Text.Parsec.Pos.Column -> GHC.Types.Bool)
    -> forall b.
       Text.Parsec.Prim.State
         s Language.PureScript.Parser.State.ParseState
       -> (()
           -> Text.Parsec.Prim.State
                s Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Parsec.Prim.State
                s Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <L,1*C1(U(U,U,U))><C(C(S)),1*C1(C1(U))><L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (7, True, True)
                (\ @ s
                   (w :: Text.Parsec.Pos.Column -> Data.Text.Internal.Text)
                   (w1 :: Text.Parsec.Pos.Column
                          -> Text.Parsec.Pos.Column -> GHC.Types.Bool)
                   @ b
                   (w2 :: Text.Parsec.Prim.State
                            s Language.PureScript.Parser.State.ParseState)
                   (w3 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Common.$wcheckIndentation
                   @ s
                   w
                   w1
                   @ b
                   w2
                   w5
                   w6) -}
8e54fd0d7db06a38f6099219b412c1ab
  dataConstructorName ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.ConstructorName)
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.dataConstructorName1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.ConstructorName>_R)) -}
578f38352d3c46006308dadc68e176db
  dataConstructorName1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.ConstructorName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.ConstructorName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.ConstructorName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.ConstructorName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wdataConstructorName
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
32d39dd8db2c980cf199fa151211cb61
  fold ::
    Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m b
    -> (a -> b -> a)
    -> Text.Parsec.Prim.ParsecT s u m a
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.fold1
                  `cast`
                (forall (s :: <*>_N) (u :: <*>_N) (m :: <*
                                                         -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Parsec.Prim.ParsecT s u m a>_R
                 ->_R <Text.Parsec.Prim.ParsecT s u m b>_R
                 ->_R <a -> b -> a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <s>_R <u>_R <m>_R <a>_R)) -}
fed2fdab43cc098d1066fd31aa671758
  fold1 ::
    Text.Parsec.Prim.ParsecT s u m a
    -> Text.Parsec.Prim.ParsecT s u m b
    -> (a -> b -> a)
    -> forall b1.
       Text.Parsec.Prim.State s u
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> (a
           -> Text.Parsec.Prim.State s u
           -> Text.Parsec.Error.ParseError
           -> m b1)
       -> (Text.Parsec.Error.ParseError -> m b1)
       -> m b1
  {- Arity: 8,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
220f6fa1c62819e97598e6353a4b65e1
  indented ::
    Text.Parsec.Prim.Parsec
      s Language.PureScript.Parser.State.ParseState ()
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.indented1
                  `cast`
                (forall (s :: <*>_N).
                 Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <s>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
a9acbcf5fcbd7c58566fededf9a280ef
  indented1 ::
    Text.Parsec.Prim.State
      s Language.PureScript.Parser.State.ParseState
    -> (()
        -> Text.Parsec.Prim.State
             s Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State
             s Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: (\ @ s
                   @ b
                   (w :: Text.Parsec.Prim.State
                           s Language.PureScript.Parser.State.ParseState)
                   (w1 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Common.$wcheckIndentation
                   @ s
                   Language.PureScript.Parser.Common.indented2
                   GHC.Classes.gtInt
                   @ b
                   w
                   w3
                   w4) -}
d590f1b95c861ee7524f0187d2b29520
  indented2 :: Text.Parsec.Pos.Column -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Text.Parsec.Pos.Column) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.Parser.Common.$windented ww1 }) -}
bbed90a701b4e22259fa4ef795a896a3
  kindName ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.KindName)
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.kindName1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.KindName>_R)) -}
f5fe0c634b15bec42e7c0acdc081a2fe
  kindName1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.KindName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.KindName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.KindName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.KindName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wkindName
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
83d35623fe4be371bfcc0211f3ba9f7c
  mark ::
    Text.Parsec.Prim.Parsec
      s Language.PureScript.Parser.State.ParseState a
    -> Text.Parsec.Prim.Parsec
         s Language.PureScript.Parser.State.ParseState a
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U(1*U))><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.mark1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Text.Parsec.Prim.Parsec
                    s Language.PureScript.Parser.State.ParseState a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <s>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
272660ce53e41e313fd017e1877a7932
  mark1 ::
    Text.Parsec.Prim.Parsec
      s Language.PureScript.Parser.State.ParseState a
    -> forall b.
       Text.Parsec.Prim.State
         s Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                s Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                s Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U(1*U))><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
a83926d1edbe8e436623c0a918e65628
  moduleName ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.Names.ModuleName
  {- Arity: 5,
     Strictness: <S(SSS),1*U(U,U,U)><L,C(C1(C1(U)))><L,C(U)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.moduleName1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.ModuleName>_R)) -}
1bdc736e52a2e01c4b7363d2269a5534
  moduleName1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ModuleName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Names.ModuleName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(U,U,U)><L,C(C1(C1(U)))><L,C(U)><L,A><L,C(U)>,
     Unfolding: (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.ModuleName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Names.ModuleName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wpart
                   (GHC.Types.[]
                      @ (Language.PureScript.Names.ProperName
                           'Language.PureScript.Names.Namespace))
                   @ b
                   ww1
                   ww2
                   ww3
                   w1
                   w2
                   w4 }) -}
6a6e6dc3aa2d481c9710a1965b07c4fa
  parseIdent ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.Names.Ident
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.parseIdent1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.Ident>_R)) -}
16047724ea851d95edfe90f8b487bf72
  parseIdent1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.Ident
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.Ident
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.Ident
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.Ident
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wparseIdent
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
43be08075001e75d4ae738ed6bf8164a
  parseLabel ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.PSString.PSString
  {- Arity: 5,
     Strictness: <S(SSS),1*U(U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.parseLabel1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.PSString.PSString>_R)) -}
ec80a2bb2eae20ebff77fcee23462e18
  parseLabel1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wparseLabel
                   @ b
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
f5962e1a380a460d4b830d99b141a9dd
  parseOperator ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Language.PureScript.Names.OpName a)
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.parseOperator1
                  `cast`
                (forall (a :: <Language.PureScript.Names.OpNameType>_N).
                 Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.OpName a>_R)) -}
2b649be555c011de27fc7cad7aa26e12
  parseOperator1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.OpName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.OpName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a :: Language.PureScript.Names.OpNameType
                   @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.OpName a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.OpName a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wparseOperator
                   @ a
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
b47db6f48fd0bee3e9e160f31046eb17
  parseQualified ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser
         (Language.PureScript.Names.Qualified a)
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U,U)><L,C(U)><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.parseQualified1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Parser.Lexer.TokenParser a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <Language.PureScript.Names.Qualified a>_R)) -}
03e677b7f9e188f529201a5db110d8a5
  parseQualified1 ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (Language.PureScript.Names.Qualified a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Language.PureScript.Names.Qualified a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U,U)><L,C(U)><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w :: Language.PureScript.Parser.Lexer.TokenParser a)
                   @ b
                   (w1 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w2 :: Language.PureScript.Names.Qualified a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Language.PureScript.Names.Qualified a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w1 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wparseQualified
                   @ a
                   w
                   @ b
                   ww1
                   ww2
                   ww3
                   w2
                   w3
                   w4
                   w5 }) -}
63562594bd59f85cfa83885dc7f1b0dd
  properName ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Language.PureScript.Names.ProperName a)
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.properName1
                  `cast`
                (forall (a :: <Language.PureScript.Names.ProperNameType>_N).
                 Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.ProperName a>_R)) -}
35d1adbbed00837208455c872fc25c99
  properName1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.ProperName a
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a :: Language.PureScript.Names.ProperNameType
                   @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.ProperName a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.ProperName a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wproperName
                   @ a
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
e2dc65750bc1cc3664308377b00ccabd
  readComments ::
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      u
      [Language.PureScript.Comments.Comment]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.readComments1
                  `cast`
                (forall (u :: <*>_N).
                 Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <u>_R
                          <Data.Functor.Identity.Identity>_R
                          <[Language.PureScript.Comments.Comment]>_R)) -}
9e6c858f9b7fdb476126c2c15b492d8c
  readComments1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken] u
    -> ([Language.PureScript.Comments.Comment]
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([Language.PureScript.Comments.Comment]
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken] u)
                   (w1 :: [Language.PureScript.Comments.Comment]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken] u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: [Language.PureScript.Comments.Comment]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken] u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww1 of wild {
                   []
                   -> w4
                        (Text.Parsec.Error.ParseError ww2 Text.Parsec.Combinator.anyToken2)
                   : t ts
                   -> w3
                        (case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                         ds5 })
                        (Text.Parsec.Prim.State
                           @ [Language.PureScript.Parser.Lexer.PositionedToken]
                           @ u
                           wild
                           ww2
                           ww3)
                        (Text.Parsec.Error.ParseError
                           ww2
                           (GHC.Types.[] @ Text.Parsec.Error.Message)) } }) -}
9dae932fdac5969d57d0bce79e0d461b
  runTokenParser ::
    GHC.IO.FilePath
    -> Language.PureScript.Parser.Lexer.TokenParser a
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Data.Either.Either Text.Parsec.Error.ParseError a
  {- Arity: 3, Strictness: <L,U><L,1*C1(C1(C1(C1(C1(U)))))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.runTokenParser1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.IO.FilePath>_R
                 ->_R <Language.PureScript.Parser.Lexer.TokenParser a>_R
                 ->_R <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <Data.Either.Either Text.Parsec.Error.ParseError a>_R) -}
56f862ac8374c9d4b6295954138374bf
  runTokenParser1 ::
    GHC.IO.FilePath
    -> Language.PureScript.Parser.Lexer.TokenParser a
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Data.Functor.Identity.Identity
         (Data.Either.Either Text.Parsec.Error.ParseError a)
  {- Arity: 3, Strictness: <L,U><L,1*C1(C1(C1(C1(C1(U)))))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (filePath :: GHC.IO.FilePath)
                   (p :: Language.PureScript.Parser.Lexer.TokenParser a)
                   (eta :: [Language.PureScript.Parser.Lexer.PositionedToken]) ->
                 Text.Parsec.Prim.runPT
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   (Language.PureScript.Parser.Common.$s$fStream[]mtok
                      @ Language.PureScript.Parser.Lexer.PositionedToken)
                   p
                   Language.PureScript.Parser.Common.runTokenParser2
                   filePath
                   eta) -}
4d878a97f91d4deebb0f370899a75a8e
  runTokenParser2 :: Language.PureScript.Parser.State.ParseState
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Language.PureScript.Parser.State.ParseState
                   Language.PureScript.Parser.Common.runTokenParser3) -}
d174e33e7bd60a54d9009daf27e05ba8
  runTokenParser3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
568fb570455053ebd4f0317b8229f51c
  same ::
    Text.Parsec.Prim.Parsec
      s Language.PureScript.Parser.State.ParseState ()
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.same1
                  `cast`
                (forall (s :: <*>_N).
                 Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <s>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
44145fb8d7cc66fc07a75b9b44f7a37c
  same1 ::
    Text.Parsec.Prim.State
      s Language.PureScript.Parser.State.ParseState
    -> (()
        -> Text.Parsec.Prim.State
             s Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State
             s Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U(U))><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Unfolding: (\ @ s
                   @ b
                   (w :: Text.Parsec.Prim.State
                           s Language.PureScript.Parser.State.ParseState)
                   (w1 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: ()
                          -> Text.Parsec.Prim.State
                               s Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Common.$wcheckIndentation
                   @ s
                   Language.PureScript.Parser.Common.same2
                   GHC.Classes.eqInt
                   @ b
                   w
                   w3
                   w4) -}
75b4eef3d62e3758049c2e13567391e4
  same2 :: Text.Parsec.Pos.Column -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Text.Parsec.Pos.Column) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.Parser.Common.$wsame ww1 }) -}
44fc0f937b14652cbd83de755ae4c717
  toSourcePos ::
    Text.Parsec.Pos.SourcePos
    -> Language.PureScript.AST.SourcePos.SourcePos
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (pos :: Text.Parsec.Pos.SourcePos) ->
                 Language.PureScript.AST.SourcePos.SourcePos
                   (Text.Parsec.Pos.sourceLine pos)
                   (Text.Parsec.Pos.sourceColumn pos)) -}
380540cd608e01be72e14a2ed47ee295
  typeName ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Language.PureScript.Names.ProperName
         'Language.PureScript.Names.TypeName)
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.typeName1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Names.ProperName
                             'Language.PureScript.Names.TypeName>_R)) -}
7db17ed0b1e6756e2772c4896da5dd00
  typeName1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.TypeName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Names.ProperName
          'Language.PureScript.Names.TypeName
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.TypeName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.TypeName
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Common.$wtypeName
                   @ b1
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
40307b0e4ea19d81c349792c48a8f907
  withSourceAnnF ::
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      u
      (Language.PureScript.AST.SourcePos.SourceAnn -> a)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
  {- Arity: 6,
     Unfolding: InlineRule (0, True, True)
                (\ @ u @ a ->
                 Language.PureScript.Parser.Common.withSourceAnnF1 @ a @ u)
                  `cast`
                (forall (u :: <*>_N) (a :: <*>_N).
                 <Text.Parsec.Prim.Parsec
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    u
                    ((Language.PureScript.AST.SourcePos.SourceSpan,
                      [Language.PureScript.Comments.Comment])
                     -> a)>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <u>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
ffd1971f3bf85735d33e276b624c8762
  withSourceAnnF1 ::
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      u
      ((Language.PureScript.AST.SourcePos.SourceSpan,
        [Language.PureScript.Comments.Comment])
       -> a)
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken] u
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Unfolding: (\ @ a @ u ->
                 Language.PureScript.Parser.Common.withSourceAnnF3
                   @ ((Language.PureScript.AST.SourcePos.SourceSpan,
                       [Language.PureScript.Comments.Comment])
                      -> a)
                   @ a
                   @ u
                   (Language.PureScript.Parser.Common.withSourceAnnF2 @ a)) -}
5dd1dc36d6e3292520d9778c215b0c2d
  withSourceAnnF2 ::
    Language.PureScript.AST.SourcePos.SourceSpan
    -> [Language.PureScript.Comments.Comment]
    -> ((Language.PureScript.AST.SourcePos.SourceSpan,
         [Language.PureScript.Comments.Comment])
        -> a)
    -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (ss :: Language.PureScript.AST.SourcePos.SourceSpan)
                   (com :: [Language.PureScript.Comments.Comment])
                   (f :: (Language.PureScript.AST.SourcePos.SourceSpan,
                          [Language.PureScript.Comments.Comment])
                         -> a) ->
                 f (ss, com)) -}
cd6bc5fae0c960a9364f4ad490c81a00
  withSourceAnnF3 ::
    (Language.PureScript.AST.SourcePos.SourceSpan
     -> [Language.PureScript.Comments.Comment] -> a -> b)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
    -> forall b1.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken] u
       -> (b
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (b
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 7,
     Strictness: <L,C(C1(C1(U)))><L,1*C1(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
400076cd3e88a80ac3e6c4190539d64b
  withSourceSpan ::
    (Language.PureScript.AST.SourcePos.SourceSpan
     -> [Language.PureScript.Comments.Comment] -> a -> b)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u b
  {- Arity: 7,
     Strictness: <L,C(C1(C1(U)))><L,1*C1(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.withSourceAnnF3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (u :: <*>_N).
                 <Language.PureScript.AST.SourcePos.SourceSpan
                  -> [Language.PureScript.Comments.Comment] -> a -> b>_R
                 ->_R <Text.Parsec.Prim.Parsec
                         [Language.PureScript.Parser.Lexer.PositionedToken] u a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <u>_R
                               <Data.Functor.Identity.Identity>_R
                               <b>_R)) -}
b6db8cc4ce577974b82c682cee81e08e
  withSourceSpan' ::
    (Language.PureScript.AST.SourcePos.SourceSpan -> a -> b)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u b
  {- Arity: 7,
     Strictness: <L,C(C1(U))><L,1*C1(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Common.withSourceSpan'1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (u :: <*>_N).
                 <Language.PureScript.AST.SourcePos.SourceSpan -> a -> b>_R
                 ->_R <Text.Parsec.Prim.Parsec
                         [Language.PureScript.Parser.Lexer.PositionedToken] u a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <u>_R
                               <Data.Functor.Identity.Identity>_R
                               <b>_R)) -}
cfe926bd6548dd5aba214a15c030d919
  withSourceSpan'1 ::
    (Language.PureScript.AST.SourcePos.SourceSpan -> a -> b)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
    -> forall b1.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken] u
       -> (b
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (b
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 7,
     Strictness: <L,C(C1(U))><L,1*C1(C1(C1(C1(C1(U)))))><S(SSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (7, True, False)
                (\ @ a
                   @ b
                   @ u
                   (f :: Language.PureScript.AST.SourcePos.SourceSpan -> a -> b)
                   (eta :: Text.Parsec.Prim.Parsec
                             [Language.PureScript.Parser.Lexer.PositionedToken] u a)
                   @ b1
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken] u)
                   (eta2 :: b
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken] u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1)
                   (eta4 :: b
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken] u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1) ->
                 Language.PureScript.Parser.Common.withSourceAnnF3
                   @ a
                   @ b
                   @ u
                   (\ (ss :: Language.PureScript.AST.SourcePos.SourceSpan)
                      (ds :: [Language.PureScript.Comments.Comment])[OneShot] ->
                    f ss)
                   eta
                   @ b1
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
8db3c867b926face9075b4326b48effc
  withSourceSpanF ::
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      u
      (Language.PureScript.AST.SourcePos.SourceSpan -> a)
    -> Text.Parsec.Prim.Parsec
         [Language.PureScript.Parser.Lexer.PositionedToken] u a
  {- Arity: 6,
     Unfolding: InlineRule (0, True, True)
                (\ @ u @ a ->
                 Language.PureScript.Parser.Common.withSourceSpanF1 @ a @ u)
                  `cast`
                (forall (u :: <*>_N) (a :: <*>_N).
                 <Text.Parsec.Prim.Parsec
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    u
                    (Language.PureScript.AST.SourcePos.SourceSpan -> a)>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <u>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
ca54d1546bb6a6cb8b64c2d08e2490e0
  withSourceSpanF1 ::
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      u
      (Language.PureScript.AST.SourcePos.SourceSpan -> a)
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken] u
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Unfolding: (\ @ a @ u ->
                 Language.PureScript.Parser.Common.withSourceAnnF3
                   @ (Language.PureScript.AST.SourcePos.SourceSpan -> a)
                   @ a
                   @ u
                   (Language.PureScript.Parser.Common.withSourceSpanF2 @ a)) -}
d9e2f9d8d7b2eb85a6f1b9e3981567f8
  withSourceSpanF2 ::
    Language.PureScript.AST.SourcePos.SourceSpan
    -> [Language.PureScript.Comments.Comment]
    -> (Language.PureScript.AST.SourcePos.SourceSpan -> a)
    -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   (ss :: Language.PureScript.AST.SourcePos.SourceSpan)
                   (ds :: [Language.PureScript.Comments.Comment])
                   (f :: Language.PureScript.AST.SourcePos.SourceSpan -> a) ->
                 f ss) -}
"SPEC/Language.PureScript.Parser.Common $fStream[]mtok @ Identity _" [orphan] forall @ tok
                                                                                     (v :: GHC.Base.Monad
                                                                                             Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok @ Data.Functor.Identity.Identity
                                  @ tok
                                  v
  = Language.PureScript.Parser.Common.$s$fStream[]mtok @ tok
"SPEC/Language.PureScript.Parser.Common $fStream[]mtok_$cuncons @ Identity _" [orphan] forall @ tok
                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                            Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cuncons @ Data.Functor.Identity.Identity
                                           @ tok
                                           $dMonad
  = Language.PureScript.Parser.Common.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
      @ tok
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

