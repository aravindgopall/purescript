
==================== FINAL INTERFACE ====================
2019-01-24 14:17:44.535037 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.State 8043
  interface hash: c92060a23289f1b8a6dd995931a0127c
  ABI hash: 6596e6b1b04a4a1b7b69c0256b5b2e95
  export-list hash: 4a5f4f202d7d05e1561b603fd2daadc9
  orphan hash: 93a4c41f84b7aa0fbe3ddb05856cc0f2
  flag hash: 40c9df1c9c54f4995cad6ab02a187ed7
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Ide.State.cacheRebuild
  Language.PureScript.Ide.State.cachedRebuild
  Language.PureScript.Ide.State.getAllModules
  Language.PureScript.Ide.State.getExternFiles
  Language.PureScript.Ide.State.getFileState
  Language.PureScript.Ide.State.getLoadedModulenames
  Language.PureScript.Ide.State.insertExterns
  Language.PureScript.Ide.State.insertExternsSTM
  Language.PureScript.Ide.State.insertModule
  Language.PureScript.Ide.State.populateVolatileState
  Language.PureScript.Ide.State.populateVolatileStateSTM
  Language.PureScript.Ide.State.populateVolatileStateSync
  Language.PureScript.Ide.State.resetIdeState
  Language.PureScript.Ide.State.resolveDataConstructorsForModule
  Language.PureScript.Ide.State.resolveInstances
  Language.PureScript.Ide.State.resolveOperatorsForModule
module dependencies: Control.Monad.Logger Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript
                     Language.PureScript.AST Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.CodeGen.JS
                     Language.PureScript.CodeGen.JS.Common
                     Language.PureScript.CodeGen.JS.Printer Language.PureScript.Comments
                     Language.PureScript.Constants Language.PureScript.CoreFn
                     Language.PureScript.CoreFn.Ann Language.PureScript.CoreFn.Binders
                     Language.PureScript.CoreFn.Desugar Language.PureScript.CoreFn.Expr
                     Language.PureScript.CoreFn.Meta Language.PureScript.CoreFn.Module
                     Language.PureScript.CoreFn.Optimizer
                     Language.PureScript.CoreFn.ToJSON
                     Language.PureScript.CoreFn.Traversals
                     Language.PureScript.CoreImp.AST
                     Language.PureScript.CoreImp.Optimizer
                     Language.PureScript.CoreImp.Optimizer.Blocks
                     Language.PureScript.CoreImp.Optimizer.Common
                     Language.PureScript.CoreImp.Optimizer.Inliner
                     Language.PureScript.CoreImp.Optimizer.MagicDo
                     Language.PureScript.CoreImp.Optimizer.TCO
                     Language.PureScript.CoreImp.Optimizer.Unused
                     Language.PureScript.Crash Language.PureScript.Docs.Convert.Single
                     Language.PureScript.Docs.RenderedCode
                     Language.PureScript.Docs.RenderedCode.RenderKind
                     Language.PureScript.Docs.RenderedCode.RenderType
                     Language.PureScript.Docs.RenderedCode.Types
                     Language.PureScript.Docs.Types
                     Language.PureScript.Docs.Utils.MonoidExtras
                     Language.PureScript.Environment Language.PureScript.Errors
                     Language.PureScript.Errors.JSON Language.PureScript.Externs
                     Language.PureScript.Ide.Error Language.PureScript.Ide.Externs
                     Language.PureScript.Ide.Logging Language.PureScript.Ide.Reexports
                     Language.PureScript.Ide.SourceFile Language.PureScript.Ide.Types
                     Language.PureScript.Ide.Util Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Linter
                     Language.PureScript.Linter.Exhaustive
                     Language.PureScript.Linter.Imports Language.PureScript.Make
                     Language.PureScript.Make.Actions Language.PureScript.Make.BuildPlan
                     Language.PureScript.Make.Monad
                     Language.PureScript.ModuleDependencies Language.PureScript.Names
                     Language.PureScript.Options Language.PureScript.PSString
                     Language.PureScript.Parser Language.PureScript.Parser.Common
                     Language.PureScript.Parser.Declarations
                     Language.PureScript.Parser.Kinds Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Parser.Types
                     Language.PureScript.Pretty Language.PureScript.Pretty.Common
                     Language.PureScript.Pretty.Kinds Language.PureScript.Pretty.Types
                     Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Renamer Language.PureScript.Sugar
                     Language.PureScript.Sugar.AdoNotation
                     Language.PureScript.Sugar.BindingGroups
                     Language.PureScript.Sugar.CaseDeclarations
                     Language.PureScript.Sugar.DoNotation
                     Language.PureScript.Sugar.LetPattern
                     Language.PureScript.Sugar.Names
                     Language.PureScript.Sugar.Names.Common
                     Language.PureScript.Sugar.Names.Env
                     Language.PureScript.Sugar.Names.Exports
                     Language.PureScript.Sugar.Names.Imports
                     Language.PureScript.Sugar.ObjectWildcards
                     Language.PureScript.Sugar.Operators
                     Language.PureScript.Sugar.Operators.Binders
                     Language.PureScript.Sugar.Operators.Common
                     Language.PureScript.Sugar.Operators.Expr
                     Language.PureScript.Sugar.Operators.Types
                     Language.PureScript.Sugar.TypeClasses
                     Language.PureScript.Sugar.TypeClasses.Deriving
                     Language.PureScript.Sugar.TypeDeclarations
                     Language.PureScript.Traversals Language.PureScript.TypeChecker
                     Language.PureScript.TypeChecker.Entailment
                     Language.PureScript.TypeChecker.Kinds
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeChecker.Subsumption
                     Language.PureScript.TypeChecker.Synonyms
                     Language.PureScript.TypeChecker.TypeSearch
                     Language.PureScript.TypeChecker.Types
                     Language.PureScript.TypeChecker.Unify
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript System.IO.UTF8
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      auto-update-0.1.4 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 bower-json-1.0.0.1 boxes-0.1.5
                      bytestring-0.10.8.2 clock-0.7.2 colour-2.3.4 conduit-1.3.0.3
                      conduit-extra-1.3.0 containers-0.5.11.0 data-ordlist-0.4.7.0
                      deepseq-1.4.3.0 directory-1.3.1.5 dlist-0.8.0.4 easy-file-0.2.2
                      exceptions-0.10.0 fast-logger-2.4.11 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 lifted-base-0.2.3.12 microlens-0.4.9.1
                      microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1
                      monad-control-1.0.2.3 monad-logger-0.3.28.5 monad-loops-0.4.3
                      mtl-2.2.2 old-locale-1.0.0.7 old-time-1.1.0.3 parallel-3.2.1.1
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 resourcet-1.2.1
                      safe-0.3.17 scientific-0.3.6.2 sourcemap-0.1.6 split-0.2.3.3
                      stm-2.4.5.0 stm-chans-3.0.0.4 stringsearch-0.3.6.6 syb-0.7
                      tagged-0.8.5 template-haskell-2.13.0.0 text-1.2.3.0
                      th-abstraction-0.2.8.0 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.5.0 transformers-base-0.4.5.2 unix-2.7.2.2
                      unix-time-0.3.8 unliftio-core-0.1.1.0 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: unix-time-0.3.8:Data.UnixTime.Diff
         syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         bower-json-1.0.0.1:Web.Bower.PackageMeta.Internal
                         clock-0.7.2:System.Clock
                         conduit-1.3.0.3:Data.Conduit.Internal.Conduit
                         conduit-1.3.0.3:Data.Conduit.Internal.Pipe
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         monad-logger-0.3.28.5:Control.Monad.Logger
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Logger
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Docs.RenderedCode.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Docs.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Reexports
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Make.Monad
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         resourcet-1.2.1:Control.Monad.Trans.Resource.Internal
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  async-2.2.1:Control.Concurrent.Async 459357253edd9936fe4b88fefb91a0c0
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Function 6e6aae9442025aeeb92a909c1bbc3fca
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Conc.Sync 0f06fc4d7792ea35160385e7175366ba
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  containers-0.5.11.0:Data.Map.Lazy 04768812a57695fe69782cd0014b0c7b
import  -/  deepseq-1.4.3.0:Control.DeepSeq 171f1f567c47ef82860df4ad686d11b1
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  microlens-0.4.9.1:Lens.Micro 962434009a31a5b07a9c325f04604c4d
import  -/  microlens-0.4.9.1:Lens.Micro.Internal 5d6464033dd2b487f83c604f394b1101
import  -/  microlens-mtl-0.1.11.1:Lens.Micro.Mtl 0b8886821fc976acf46035b23c9705b6
import  -/  microlens-platform-0.3.10:Lens.Micro.Platform 0a8b1a3c754e3254d224cc9602b42f64
import  -/  monad-logger-0.3.28.5:Control.Monad.Logger ae6f9fbc4451af5ecbeab48dfdfd01ee
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  Language.PureScript 4a24ccd892adbf021daf2410ebd61e22
  exports: 139dcaa90af8ddcee6aa0492159f351d
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  Declaration e92f6ee78a22c0eadc3566d7d1f48d5b
  Module 305128e30e200d34d712365aa2d509df
  Module 3342e00ee072addfd009ee61e87fb865
  TypeDeclaration 28394461dbd073cca9cdbd263dbb4335
  declName 346365fb28af384d04391dc396f98282
  declSourceAnn 5d4803f8f30e53025f1e80c48cd481b1
  getModuleName 7aa2ed3fa39338f5edb2f1938e29c924
  tydeclIdent c947d6d8aff56f68d1789e1833a9fcd2
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  SourceSpan 1e0cf2bd3ea18f97a2ff152297f09219
import  -/  Language.PureScript.Comments 1a682522a2f855328ca87bb68705794c
  Comment 2e827a5b834f92cc9beef533348585fa
import  -/  Language.PureScript.Docs.Convert.Single f999918640a4fd4d03e143bc691da9cc
  exports: 86077279760662a54c37b25c8d6f8653
  convertComments 73b9f703239cbbe3d6afd08543c85417
import  -/  Language.PureScript.Externs cf933be49760ec7d1e991d8ad7f6146f
  exports: caea0e8e36630f9e250d475ec2e68707
  EDInstance b505ded8eb9d4692ad56205d6f025319
  ExternsFile c010c09fe85776adf7c6787c7d79c898
  edInstanceChain a7fb565ada874d78b726c57090b05102
  edInstanceChainIndex a7fb565ada874d78b726c57090b05102
  edInstanceClassName a7fb565ada874d78b726c57090b05102
  edInstanceConstraints a7fb565ada874d78b726c57090b05102
  edInstanceName a7fb565ada874d78b726c57090b05102
  edInstanceTypes a7fb565ada874d78b726c57090b05102
  efDeclarations c010c09fe85776adf7c6787c7d79c898
  efModuleName c010c09fe85776adf7c6787c7d79c898
import  -/  Language.PureScript.Ide.Externs 01c33784015d1f3b34dbf4e8a565b308
  exports: 03734d94ad1c35346fdca69b71601090
  convertExterns 4fd90170e6df30f2d0127ff4b35d4b0e
import  -/  Language.PureScript.Ide.Logging 7a72afda66c50413f726f7fcff793207
  displayTimeSpec 5c7684646ff91cc182566a2e4c9574a1
  logPerf 0e0bef938e0140f679afbba754e2f391
  runLogger 59824604358c607560bbe67cfd41a713
import  -/  Language.PureScript.Ide.Reexports d5cc525b693f3dff317f0447e0c05c3f
  exports: b4bf3c898ef6fb170bdebb576e26ba35
  ReexportResult 50faffa175089c4d498aee15d818adb2
  prettyPrintReexportResult 78d87f217dd855f547c1cda5f32a827c
  reResolved 50faffa175089c4d498aee15d818adb2
  reexportHasFailures 3f2ee3848c926e8bb9d1beedf3a7bb0a
  resolveReexports dd19f375670ce11694af989ae6fa3665
import  -/  Language.PureScript.Ide.SourceFile c74d69ddf93a90292d74305bb762cfa1
  exports: e00d77246c86a899e3f8f790a1647fa1
  extractAstInformation 6d3086164192b85a28398de5c43773bd
import  -/  Language.PureScript.Ide.Types 4bb81e9de3788f7f63a68a23e190eb73
  exports: e5ee4d37ef25d4dfedd36ea1d435a17a
  AstData 8334bc72aee07fd4b71fcff5447babf5
  DefinitionSites c161e16528e3e8b1440d99e361f106f0
  Ide daf7e11ebbb1a4f28e92151bdfd877f7
  IdeDataConstructor 01cdb91182692ecc25b2dbdcc2f07c21
  IdeDeclDataConstructor 8fce6bf53fa94a19e0d601b21857c083
  IdeDeclKind eadccdfcdc773a4889209905550631de
  IdeDeclType bf6a01d2f64dd736d0c0838c335e1f4d
  IdeDeclTypeClass daec5de1fc0811383493f72c17859b3c
  IdeDeclTypeOperator 942a106238947e7cdd45b0c72cd2559c
  IdeDeclTypeSynonym f16924e305412463e9d0339a34821aa8
  IdeDeclValue cff86d395b09e6db0f9fde8980f34310
  IdeDeclValueOperator 30db1956e4e27b3074312970c743db17
  IdeDeclaration 0c91b1320f07da0ab07b77b49d64d462
  IdeDeclarationAnn 1d5bc37494f0e43867ff35908b352362
  IdeDeclarationAnn b02d1e3d0d65a3bc0459005430392eb1
  IdeFileState 62fbc4a75883d658e7e04f0a84ab2ee5
  IdeFileState 2923622c53c0f0fcf77bbfd3720beec1
  IdeInstance 8b7324c197e5332bb9b6535b724413fb
  IdeInstance 60c599d0289b3fc90de185766f47b756
  IdeNSKind 63c32c9e96311fb6e946631828a18da8
  IdeNSType 5ff5d8cffb71ed2b7340691cc23499b1
  IdeNSValue b1143d15c5f600d17f9f80fdbd679c78
  IdeNamespaced b530543e75a3b859e16ce1b8a5d60e4a
  IdeState 08b5f0405d44452524b8941687d080f4
  IdeVolatileState 68fe074032f47192703c00e51602a45d
  IdeVolatileState 534b3d7af0aa98600153a60583892e70
  ModuleMap 70319f3e75143277feb6984fb77be89b
  TypeAnnotations ccd1ccf94d43b6da534c378dbd72ecc7
  _IdeDeclDataConstructor 2a59d3a75e6ec43625d4ac73194fc132
  _IdeDeclType 5a85c0225b99d2057d2ce54ca7b67a42
  _IdeDeclTypeClass 1c5e11849eaa2f03b374ba2b50a55ccb
  _IdeDeclValue f69c0561e04acdd8727d69b166d26993
  _annDocumentation b02d1e3d0d65a3bc0459005430392eb1
  _annLocation b02d1e3d0d65a3bc0459005430392eb1
  _annTypeAnnotation b02d1e3d0d65a3bc0459005430392eb1
  anyOf 30b07c9f4bcb7d654ab6d8adfaab60ba
  confLogLevel 60599607aeaddfb6ebe1e4768bb3aec5
  emptyIdeState 2f7666798faf85c52ce67be061aebd45
  fsExterns 2923622c53c0f0fcf77bbfd3720beec1
  fsModules 2923622c53c0f0fcf77bbfd3720beec1
  idaDeclaration 52470585dda3a96f11d1deb064fffc24
  ideConfiguration ae7ebb9016daec3c320aa4779032899f
  ideDtorName f5cb16b133f56c5181009aa7f78d9703
  ideDtorType 39d15c8ff3b20d67ac734f8d16472e8c
  ideFileState 08b5f0405d44452524b8941687d080f4
  ideStateVar ae7ebb9016daec3c320aa4779032899f
  ideSynonymName dba058d7cc24bbf5f5716fc90da609d5
  ideTCInstances 5b59ca03b106fdeecf9e36acde0c63cd
  ideTCName 6707b0fb5bd9d8aacf896d456424bf01
  ideTypeDtors 4b9bddc6631c182d584f8530a50d7c85
  ideTypeKind 6702fd04c337d07b067bd4d1673884df
  ideTypeName 102b07c9135d8fc8731c934f05b32722
  ideTypeOpAlias 4596a313d73b37d761eb235ffabd911f
  ideTypeOpKind 4969765bdb09b7f55df33636901b3be4
  ideTypeOpName 08dd8715bd3877a439fc94b5ef8510e9
  ideValueIdent e8d6898aa2565d8b04f5faf56de63fbb
  ideValueOpAlias d487c1bd631455a3c89133bc647988eb
  ideValueOpName 2164408815ac127bc2a0c935191310ce
  ideValueOpType f95f376bb24018902771fd5b8a1e1ceb
  ideValueType 1bd8bbfe4d021fa85d0c2b7ac126a976
  ideVolatileState 08b5f0405d44452524b8941687d080f4
  vsAstData 534b3d7af0aa98600153a60583892e70
  vsCachedRebuild 534b3d7af0aa98600153a60583892e70
  vsDeclarations 534b3d7af0aa98600153a60583892e70
import  -/  Language.PureScript.Ide.Util 23feade20e7d884b8e398315c4ffa11e
  exports: b783a834cebd9a63a606ae4111317a86
  discardAnn dda9d4fafbbc8df2d6404b8b09ac7a49
  opNameT a168fd52f08b9cb2d567b1e880a7a253
  properNameT e4d3618214ff774dcbb219a8feb710a8
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  ClassName c5d98a635cb261f6a93bf01096d0c6ed
  Ident 71f167265716f619863a793fa311e198
  Ident bad3562aa6138b6192713ac281080869
  IdentName f85afb00b35a2b992fb8ad7cbb2f9711
  KiName 3648c75d7b729914a2a52509b0a9365e
  ModuleName 1b2ddf0c04464d2fa2588925f10c1966
  Name d04047edf96c18708b7b5f72cb565394
  ProperName f69d3801241fcb4773f1284cd28f2dee
  ProperName a7268334e0b909381550b9329cb80fcc
  Qualified b6e1bc9e7244a41d3c6149c9b5c2d6d8
  TyName 6bd149eabdb95c312f9b6bf9d9f06c67
  runIdent f4727e6f001b3b7d933fd4e8122af572
  runModuleName 58b788b37f600c0f34fa85241d7748ad
import  -/  stm-2.4.5.0:Control.Concurrent.STM 5ec97830246fb15a85b4d8cd8209f698
import  -/  stm-2.4.5.0:Control.Concurrent.STM.TVar a2518ded50e38dfa02555ea1dc90f6c2
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
7d667da0c4773153b028562f9ac8516a
  $s$fApplicativeLoggingT ::
    GHC.Base.Applicative (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fFunctorLoggingT
                  (\ @ a (x :: a) ->
                   let {
                     x1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, x #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x1)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*>
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, eta ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <c>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <c>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta2 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta2)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (eta1
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      eta2)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  (\ @ a
                     @ b
                     (eta1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (eta2 :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta3 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta1
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   case (eta2
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta3)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
cfab5f7ad68ea0262fa0ce3a4201f0b9
  $s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (loggerF :: Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b))
                   (loggerA :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (loggerF
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a -> b>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 case (loggerA
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO (a -> b)>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
4808164d9b55b3b71a82d20bdb97ca5b
  $s$fApplicativeLoggingT_$s$fFunctorLoggingT ::
    GHC.Base.Functor (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (eta1 :: Language.Haskell.TH.Syntax.Loc
                              -> Control.Monad.Logger.LogSource
                              -> Control.Monad.Logger.LogLevel
                              -> System.Log.FastLogger.LogStr.LogStr
                              -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          s of ds { (#,#) ipv ipv1 ->
                   (# ipv, x #) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <a>_N)) -}
91a5c6919b95b41b9537d5ae61491c26
  $s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap ::
    (a -> b)
    -> Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f1 :: a -> b)
                   (logger :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (loggerFn :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (logger
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         loggerFn)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 (# ipv, f1 ipv1 #) })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
4e260176d738f4127310c093aa93848c
  $s$fMonadIOLoggingT_$s$fMonadLoggingT ::
    GHC.Base.Monad (Control.Monad.Logger.LoggingT GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                  Language.PureScript.Ide.State.$s$fApplicativeLoggingT
                  (\ @ a
                     @ b
                     (ds :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                     (f1 :: a -> Control.Monad.Logger.LoggingT GHC.Types.IO b)
                     (r :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ())
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   ((f1 ipv1)
                      `cast`
                    (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                      r)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                   ->_R <a -> Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                   ->_R (<Language.Haskell.TH.Syntax.Loc
                          -> Control.Monad.Logger.LogSource
                          -> Control.Monad.Logger.LogLevel
                          -> System.Log.FastLogger.LogStr.LogStr
                          -> GHC.Types.IO ()>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                          <GHC.Types.IO>_R <b>_N))
                  Language.PureScript.Ide.State.$s$fMonadIOLoggingT_$s$fMonadLoggingT_$c>>
                  (\ @ a (eta :: a) ->
                   let {
                     x :: GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta #)
                   } in
                   (\ (ds :: Language.Haskell.TH.Syntax.Loc
                             -> Control.Monad.Logger.LogSource
                             -> Control.Monad.Logger.LogLevel
                             -> System.Log.FastLogger.LogStr.LogStr
                             -> GHC.Types.IO ()) ->
                    x)
                     `cast`
                   ((<Language.Haskell.TH.Syntax.Loc
                      -> Control.Monad.Logger.LogSource
                      -> Control.Monad.Logger.LogLevel
                      -> System.Log.FastLogger.LogStr.LogStr
                      -> GHC.Types.IO ()>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                      <GHC.Types.IO>_R <a>_N)))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO a)) -}
7218e5cfa51340461a0694864874c70b
  $s$fMonadIOLoggingT_$s$fMonadLoggingT_$c>> ::
    Control.Monad.Logger.LoggingT GHC.Types.IO a
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
    -> Control.Monad.Logger.LoggingT GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.LoggingT GHC.Types.IO a)
                   (k :: Control.Monad.Logger.LoggingT GHC.Types.IO b)
                   (r :: Language.Haskell.TH.Syntax.Loc
                         -> Control.Monad.Logger.LogSource
                         -> Control.Monad.Logger.LogLevel
                         -> System.Log.FastLogger.LogStr.LogStr
                         -> GHC.Types.IO ())
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <a>_N)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (k `cast`
                  (Control.Monad.Logger.N:LoggingT[0] <GHC.Types.IO>_R <b>_N)
                    r)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.LoggingT GHC.Types.IO a>_R
                 ->_R <Control.Monad.Logger.LoggingT GHC.Types.IO b>_R
                 ->_R (<Language.Haskell.TH.Syntax.Loc
                        -> Control.Monad.Logger.LogSource
                        -> Control.Monad.Logger.LogLevel
                        -> System.Log.FastLogger.LogStr.LogStr
                        -> GHC.Types.IO ()>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                        <GHC.Types.IO>_R <b>_N)) -}
8dc62a6393acfad635274250dbacdc6d
  $s$fMonadIOReaderT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Reader.ReaderT
         r (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r (Control.Monad.Logger.LoggingT GHC.Types.IO))
                  (Control.Monad.Trans.Reader.$fMonadReaderT
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Language.PureScript.Ide.State.$s$fMonadIOLoggingT_$s$fMonadLoggingT)
                  (\ @ a (x :: GHC.Types.IO a) ->
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Types.IO a
                       {- Arity: 1 -}
                     = \ (ds :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()) ->
                       x
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (Control.Monad.Logger.N:LoggingT[0]
                                   <GHC.Types.IO>_R
                                   <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                      <*>_N
                                                      <r>_R
                                                      <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                                                      <a>_N))) -}
c32f62908c8bd74bc81c1b57708c0ab1
  $s$fMonadLoggerReaderT ::
    Control.Monad.Logger.MonadLogger
      (Control.Monad.Trans.Reader.ReaderT
         r (Control.Monad.Logger.LoggingT GHC.Types.IO))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r (Control.Monad.Logger.LoggingT GHC.Types.IO))
                  (Control.Monad.Trans.Reader.$fMonadReaderT
                     @ (Control.Monad.Logger.LoggingT GHC.Types.IO)
                     @ r
                     Language.PureScript.Ide.State.$s$fMonadIOLoggingT_$s$fMonadLoggingT)
                  (\ @ msg
                     (eta :: System.Log.FastLogger.LogStr.ToLogStr msg)
                     (eta1 :: Language.Haskell.TH.Syntax.Loc)
                     (eta2 :: Control.Monad.Logger.LogSource)
                     (eta3 :: Control.Monad.Logger.LogLevel)
                     (eta4 :: msg) ->
                   let {
                     m1 :: (Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                           -> GHC.Types.IO ()
                       {- Arity: 1 -}
                     = \ (f1 :: Language.Haskell.TH.Syntax.Loc
                                -> Control.Monad.Logger.LogSource
                                -> Control.Monad.Logger.LogLevel
                                -> System.Log.FastLogger.LogStr.LogStr
                                -> GHC.Types.IO ()) ->
                       f1
                         eta1
                         eta2
                         eta3
                         (eta `cast` (System.Log.FastLogger.LogStr.N:ToLogStr[0] <msg>_N)
                            eta4)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (Control.Monad.Logger.N:LoggingT[0]
                                   <GHC.Types.IO>_R
                                   <()>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                       <*>_N
                                                       <r>_R
                                                       <Control.Monad.Logger.LoggingT
                                                          GHC.Types.IO>_R
                                                       <()>_N))) -}
b0471e1f6783e51b301e27631cdf92c7
  $s$fMonadLoggingT_$creturn ::
    a -> Control.Monad.Logger.LoggingT GHC.Types.IO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta :: a) ->
                 let {
                   x :: GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                     {- Arity: 1 -}
                   = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta #)
                 } in
                 (\ (ds :: Language.Haskell.TH.Syntax.Loc
                           -> Control.Monad.Logger.LogSource
                           -> Control.Monad.Logger.LogLevel
                           -> System.Log.FastLogger.LogStr.LogStr
                           -> GHC.Types.IO ()) ->
                  x)
                   `cast`
                 ((<Language.Haskell.TH.Syntax.Loc
                    -> Control.Monad.Logger.LogSource
                    -> Control.Monad.Logger.LogLevel
                    -> System.Log.FastLogger.LogStr.LogStr
                    -> GHC.Types.IO ()>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <a>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                    <GHC.Types.IO>_R <a>_N))) -}
90f46bb9709b59a1c443f4be82b93a18
  $sadjustWithKey_$sgo13 ::
    (Language.PureScript.Names.ModuleName -> a1 -> a1)
    -> Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><S,1*U><S,1*U> -}
4a303d57efc7465bc56a2dc6f33bc892
  $sidaDeclaration1 ::
    (Language.PureScript.Ide.Types.IdeDeclaration
     -> Data.Functor.Identity.Identity
          Language.PureScript.Ide.Types.IdeDeclaration)
    -> Language.PureScript.Ide.Types.IdeDeclarationAnn
    -> Data.Functor.Identity.Identity
         Language.PureScript.Ide.Types.IdeDeclarationAnn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (f15 :: Language.PureScript.Ide.Types.IdeDeclaration
                           -> Data.Functor.Identity.Identity
                                Language.PureScript.Ide.Types.IdeDeclaration)
                   (ds :: Language.PureScript.Ide.Types.IdeDeclarationAnn) ->
                 case ds of wild { Language.PureScript.Ide.Types.IdeDeclarationAnn x x1 ->
                 (Language.PureScript.Ide.Types.IdeDeclarationAnn
                    x
                    (f15 x1)
                      `cast`
                    (Data.Functor.Identity.N:Identity[0]
                         <Language.PureScript.Ide.Types.IdeDeclaration>_R))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.PureScript.Ide.Types.IdeDeclarationAnn>_R)) }) -}
303dc6b46152df7938f11a334c9a9565
  $sinsertWithKey_$s$sgo13 ::
    Data.Map.Internal.Map
      Language.PureScript.Names.Name
      [Language.PureScript.Comments.Comment]
    -> [Language.PureScript.Comments.Comment]
    -> Language.PureScript.Names.Name
    -> Data.Map.Internal.Map
         Language.PureScript.Names.Name
         [Language.PureScript.Comments.Comment]
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
b82fad1a9d8555651edca4054965dfd5
  $sinsert_$sgo13 ::
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Names.ModuleName
    -> a1
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
0f092d641544b461ae1715cf882676a1
  $slookup1 ::
    Language.PureScript.Names.Ident
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
cf8f3b4d530906f74abeb36f236cb169
  $slookup7 ::
    Language.PureScript.Names.Name
    -> Data.Map.Internal.Map Language.PureScript.Names.Name a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
13e541d4552a4b36e15003a6598a71f6
  $slookup9 ::
    Language.PureScript.Names.ModuleName
    -> Data.Map.Internal.Map Language.PureScript.Names.ModuleName a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
1bd17f5dfac56cec8e9fdc9ade5368a5
  $slookup_$spoly_go1 ::
    Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> GHC.Base.Maybe Data.Text.Internal.Text
    -> GHC.Integer.Type.Integer
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U> -}
5305ac3c0676abaa45e34c08133725b1
  $slookup_$spoly_go13 ::
    Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> GHC.Base.Maybe a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
964625b4b4945171a8bc72686c3f5838
  $slookup_$spoly_go2 ::
    Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> Data.Text.Internal.Text -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U,U)> -}
d7d137b1d4460f354988b9549dfe1c9e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Ide.State.$trModule3
                   Language.PureScript.Ide.State.$trModule1) -}
21173847df6992d466ff8ea1f877c0b0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.State.$trModule2) -}
1577529017808539cdd5d39023e79277
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.PureScript.Ide.State"#) -}
322792fe0ebb2dc9ed496ad54f9d4c7f
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.State.$trModule4) -}
55017efeb7e3ccb7031a61fef48e6dd0
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
a8c72c1a2d8486e65e23040ce776dc83
  $w$sgo13 ::
    (a1 -> a1 -> a1)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
         a1
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
         a1
  {- Arity: 6,
     Strictness: <L,1*C1(C1(U))><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
6517b6dad936c7b552483cec91b5652d
  $wgo13 ::
    Data.Map.Internal.Map
      Language.PureScript.Names.ModuleName
      (Language.PureScript.Ide.Reexports.ReexportResult
         [Language.PureScript.Ide.Types.IdeDeclarationAnn])
    -> (Language.Haskell.TH.Syntax.Loc
        -> Control.Monad.Logger.LogSource
        -> Control.Monad.Logger.LogLevel
        -> System.Log.FastLogger.LogStr.LogStr
        -> GHC.Types.IO ())
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Internal.Map Language.PureScript.Names.ModuleName () #)
  {- Arity: 3, Strictness: <S,1*U><L,C(C1(C1(C1(C1(U(U,U))))))><S,U>,
     Inline: [0] -}
1481ef9a8060549eb26b76860ef1bdf0
  $winsertExternsSTM ::
    GHC.Prim.TVar#
      GHC.Prim.RealWorld Language.PureScript.Ide.Types.IdeState
    -> Language.PureScript.Externs.ExternsFile
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><L,1*U(U,U,U,U,U,U,U,U)><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.TVar#
                            GHC.Prim.RealWorld Language.PureScript.Ide.Types.IdeState)
                   (w :: Language.PureScript.Externs.ExternsFile)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.readTVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Ide.Types.IdeState
                        ww
                        w1 of ds { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeTVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Ide.Types.IdeState
                        ww
                        (case ipv1 of wild { Language.PureScript.Ide.Types.IdeState ds1 ds2 ->
                         Language.PureScript.Ide.Types.IdeState
                           (case ds1 of wild1 { Language.PureScript.Ide.Types.IdeFileState ds3 ds4 ->
                            Language.PureScript.Ide.Types.IdeFileState
                              (case w of wild2 { Language.PureScript.Externs.ExternsFile ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                               Language.PureScript.Ide.State.$sinsert_$sgo13
                                 @ Language.PureScript.Externs.ExternsFile
                                 ds6
                                 ds6
                                 wild2
                                 ds3 })
                              ds4 })
                           ds2 })
                        ipv of s2# { DEFAULT ->
                 (# s2#, GHC.Tuple.() #) } }) -}
ed3423f70ba0d26119c568622e98c013
  $wlvl ::
    Language.PureScript.Names.ModuleName
    -> [Language.PureScript.Externs.ExternsDeclaration]
    -> [(Language.PureScript.Ide.Types.IdeInstance,
         Language.PureScript.Names.ModuleName,
         Language.PureScript.Names.ProperName
           'Language.PureScript.Names.ClassName)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Language.PureScript.Names.ModuleName)
                   (ww :: [Language.PureScript.Externs.ExternsDeclaration]) ->
                 Data.Maybe.mapMaybe
                   @ Language.PureScript.Externs.ExternsDeclaration
                   @ (Language.PureScript.Ide.Types.IdeInstance,
                      Language.PureScript.Names.ModuleName,
                      Language.PureScript.Names.ProperName
                        'Language.PureScript.Names.ClassName)
                   (\ (ds :: Language.PureScript.Externs.ExternsDeclaration) ->
                    case ds of wild {
                      DEFAULT
                      -> GHC.Base.Nothing
                           @ (Language.PureScript.Ide.Types.IdeInstance,
                              Language.PureScript.Names.ModuleName,
                              Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ClassName)
                      Language.PureScript.Externs.EDInstance ds1 ds2 ds3 ds4 ds5 ds6
                      -> case ds1 of wild1 { Language.PureScript.Names.Qualified ds7 className ->
                         case ds7 of wild2 {
                           GHC.Base.Nothing
                           -> GHC.Base.Nothing
                                @ (Language.PureScript.Ide.Types.IdeInstance,
                                   Language.PureScript.Names.ModuleName,
                                   Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.ClassName)
                           GHC.Base.Just classModule
                           -> GHC.Base.Just
                                @ (Language.PureScript.Ide.Types.IdeInstance,
                                   Language.PureScript.Names.ModuleName,
                                   Language.PureScript.Names.ProperName
                                     'Language.PureScript.Names.ClassName)
                                (Language.PureScript.Ide.Types.IdeInstance w ds2 ds3 ds4,
                                 classModule, className) } } })
                   ww) -}
0d6993a68e8cf41b2c1af9337e9e4e19
  $wpoly_go1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
         a
    -> GHC.Base.Maybe a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
1e5cc1f0be2f998cb633d5d351e87a00
  $wpoly_go13 ::
    Language.PureScript.Ide.Types.IdeNamespace
    -> Data.Text.Internal.Text
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U(U,U,U)><S,1*U>,
     Inline: [0] -}
6b50e4c9d422500a0a4a8a85bcaa8ea4
  $wpopulateVolatileState ::
    Language.PureScript.Ide.Types.Ide m =>
    m (Control.Concurrent.Async.Async ())
  {- Arity: 1,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(A,1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))>,
     Inline: [0],
     Unfolding: (\ @ m :: * -> *
                   (w :: Language.PureScript.Ide.Types.Ide m) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       w
                 } in
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   @ Language.PureScript.Ide.Types.IdeEnvironment
                   @ (Control.Concurrent.Async.Async ())
                   (Control.Monad.Reader.Class.ask
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ m
                      (GHC.Classes.$p2(%,%)
                         @ (Control.Monad.IO.Class.MonadIO m)
                         @ (Control.Monad.Reader.Class.MonadReader
                              Language.PureScript.Ide.Types.IdeEnvironment m)
                         w))
                   (\ (env :: Language.PureScript.Ide.Types.IdeEnvironment) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ (Control.Concurrent.Async.Async ())
                      (Control.Concurrent.Async.async2
                         @ ()
                         Control.Concurrent.Async.rawForkIO
                         (Language.PureScript.Ide.Logging.$wrunLogger
                            @ GHC.Types.IO
                            @ ()
                            (case env of wild { Language.PureScript.Ide.Types.IdeEnvironment ds1 ds2 ->
                             case ds2 of wild1 { Language.PureScript.Ide.Types.IdeConfiguration ds4 ds5 ds3 ds6 ->
                             ds5 } })
                            (\ (r :: Language.Haskell.TH.Syntax.Loc
                                     -> Control.Monad.Logger.LogSource
                                     -> Control.Monad.Logger.LogLevel
                                     -> System.Log.FastLogger.LogStr.LogStr
                                     -> GHC.Types.IO ())[OneShot]
                               (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                             Language.PureScript.Ide.State.populateVolatileState1
                               (Language.PureScript.Ide.Types.ideStateVar env)
                               env
                               r
                               s)
                              `cast`
                            ((<Language.Haskell.TH.Syntax.Loc
                               -> Control.Monad.Logger.LogSource
                               -> Control.Monad.Logger.LogLevel
                               -> System.Log.FastLogger.LogStr.LogStr
                               -> GHC.Types.IO ()>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <()>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                <GHC.Types.IO>_R <()>_N))))
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <Control.Concurrent.Async.Async ()>_R)))) -}
b20746dd34df1f86300a665315b8f730
  $wpopulateVolatileStateSTM ::
    GHC.Prim.TVar#
      GHC.Prim.RealWorld Language.PureScript.Ide.Types.IdeState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Language.PureScript.Ide.Types.ModuleMap
            (Language.PureScript.Ide.Reexports.ReexportResult
               [Language.PureScript.Ide.Types.IdeDeclarationAnn]) #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
8d026b55fae9c4a986facc5e8d233807
  cacheRebuild ::
    Language.PureScript.Ide.Types.Ide m =>
    Language.PureScript.Externs.ExternsFile -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))><L,U(U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m)
                   (eta :: Language.PureScript.Externs.ExternsFile) ->
                 let {
                   lvl13 :: Language.PureScript.Names.ModuleName
                   = case eta of wild { Language.PureScript.Externs.ExternsFile ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     ds2 }
                 } in
                 let {
                   lvl14 :: (Language.PureScript.Names.ModuleName,
                             Language.PureScript.Externs.ExternsFile)
                   = (lvl13, eta)
                 } in
                 let {
                   lvl15 :: GHC.Base.Maybe
                              (Language.PureScript.Names.ModuleName,
                               Language.PureScript.Externs.ExternsFile)
                   = GHC.Base.Just
                       @ (Language.PureScript.Names.ModuleName,
                          Language.PureScript.Externs.ExternsFile)
                       lvl14
                 } in
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ ()
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (st :: GHC.Conc.Sync.TVar
                               Language.PureScript.Ide.Types.IdeState) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ ()
                      (GHC.Prim.atomically#
                         @ ()
                         (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case st of wild { GHC.Conc.Sync.TVar tvar# ->
                          case GHC.Prim.readTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 s of ds { (#,#) ipv ipv1 ->
                          case GHC.Prim.writeTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 (case ipv1 of wild1 { Language.PureScript.Ide.Types.IdeState ds1 ds2 ->
                                  Language.PureScript.Ide.Types.IdeState
                                    ds1
                                    (case ds2 of wild2 { Language.PureScript.Ide.Types.IdeVolatileState ds3 ds4 ds5 ->
                                     Language.PureScript.Ide.Types.IdeVolatileState
                                       ds3
                                       ds4
                                       lvl15 }) })
                                 ipv of s2# { DEFAULT ->
                          (# s2#, GHC.Tuple.() #) } } }))
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <()>_R)))) -}
cbc6e7a5059a9d6d8e596e3a25edf9cf
  cachedRebuild ::
    Language.PureScript.Ide.Types.Ide m =>
    m (GHC.Base.Maybe
         (Language.PureScript.Names.ModuleName,
          Language.PureScript.Externs.ExternsFile))
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(S(C(C(S))L)LLLLL)LLLL)L)L),U(U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,A,A),C(U)),U(A,U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.IO.Class.$p1MonadIO
                            @ m
                            (GHC.Classes.$p1(%,%)
                               @ (Control.Monad.IO.Class.MonadIO m)
                               @ (Control.Monad.Reader.Class.MonadReader
                                    Language.PureScript.Ide.Types.IdeEnvironment m)
                               $d(%,%)))))
                   @ Language.PureScript.Ide.Types.IdeVolatileState
                   @ (GHC.Base.Maybe
                        (Language.PureScript.Names.ModuleName,
                         Language.PureScript.Externs.ExternsFile))
                   Language.PureScript.Ide.Types.vsCachedRebuild
                   (Language.PureScript.Ide.State.getVolatileState @ m $d(%,%))) -}
8127e3ed0115c3eb5d5fb04aec2ad4e2
  getAllModules ::
    Language.PureScript.Ide.Types.Ide m =>
    GHC.Base.Maybe Language.PureScript.Names.ModuleName
    -> m (Language.PureScript.Ide.Types.ModuleMap
            [Language.PureScript.Ide.Types.IdeDeclarationAnn])
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(U(U(U(U(C(C1(U)),A),C(U),A,A,A,A),C(C1(U)),A,A,A),C(U)),U(A,U,A,A))><L,U> -}
7b074820b990a95f0824c75debf70a69
  getExternFiles ::
    Language.PureScript.Ide.Types.Ide m =>
    m (Language.PureScript.Ide.Types.ModuleMap
         Language.PureScript.Externs.ExternsFile)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(S(C(C(S))L)LLLLL)LLLL)L)L),U(U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,A,A),C(U)),U(A,U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.IO.Class.$p1MonadIO
                            @ m
                            (GHC.Classes.$p1(%,%)
                               @ (Control.Monad.IO.Class.MonadIO m)
                               @ (Control.Monad.Reader.Class.MonadReader
                                    Language.PureScript.Ide.Types.IdeEnvironment m)
                               $d(%,%)))))
                   @ Language.PureScript.Ide.Types.IdeFileState
                   @ (Language.PureScript.Ide.Types.ModuleMap
                        Language.PureScript.Externs.ExternsFile)
                   Language.PureScript.Ide.Types.fsExterns
                   (Language.PureScript.Ide.State.getFileState @ m $d(%,%))) -}
26891732e23e221f5df596cfa1dd1c42
  getFileState ::
    Language.PureScript.Ide.Types.Ide m =>
    m Language.PureScript.Ide.Types.IdeFileState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(C(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   $dFunctor :: GHC.Base.Functor m
                   = GHC.Base.$p1Applicative @ m $dApplicative
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ Language.PureScript.Ide.Types.IdeFileState
                   (GHC.Base.fmap
                      @ m
                      $dFunctor
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (st :: GHC.Conc.Sync.TVar
                               Language.PureScript.Ide.Types.IdeState) ->
                    GHC.Base.fmap
                      @ m
                      $dFunctor
                      @ Language.PureScript.Ide.Types.IdeState
                      @ Language.PureScript.Ide.Types.IdeFileState
                      Language.PureScript.Ide.Types.ideFileState
                      (Control.Monad.IO.Class.liftIO
                         @ m
                         $dMonadIO
                         @ Language.PureScript.Ide.Types.IdeState
                         (GHC.Conc.Sync.readTVarIO1
                            @ Language.PureScript.Ide.Types.IdeState
                            st)
                           `cast`
                         (Sym (GHC.Types.N:IO[0]
                                   <Language.PureScript.Ide.Types.IdeState>_R))))) -}
67cb9bb96892bed2f2077adca5620635
  getLoadedModulenames ::
    Language.PureScript.Ide.Types.Ide m =>
    m [Language.PureScript.Names.ModuleName]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(S(S(C(C(S))L)LLLLL)LLLL)L)L),U(U(U(U(U(C(C1(U)),A),A,A,A,A,A),C(C1(U)),A,A,A),C(U)),U(A,U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative
                      @ m
                      (GHC.Base.$p1Monad
                         @ m
                         (Control.Monad.IO.Class.$p1MonadIO
                            @ m
                            (GHC.Classes.$p1(%,%)
                               @ (Control.Monad.IO.Class.MonadIO m)
                               @ (Control.Monad.Reader.Class.MonadReader
                                    Language.PureScript.Ide.Types.IdeEnvironment m)
                               $d(%,%)))))
                   @ (Data.Map.Internal.Map
                        Language.PureScript.Names.ModuleName
                        Language.PureScript.Externs.ExternsFile)
                   @ [Language.PureScript.Names.ModuleName]
                   (Data.Map.Internal.keys
                      @ Language.PureScript.Names.ModuleName
                      @ Language.PureScript.Externs.ExternsFile)
                   (Language.PureScript.Ide.State.getExternFiles @ m $d(%,%))) -}
91cb4d95f50103884790d10eb5c7be30
  getVolatileState ::
    Language.PureScript.Ide.Types.Ide m =>
    m Language.PureScript.Ide.Types.IdeVolatileState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ Language.PureScript.Ide.Types.IdeVolatileState
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (st :: GHC.Conc.Sync.TVar
                               Language.PureScript.Ide.Types.IdeState) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ Language.PureScript.Ide.Types.IdeVolatileState
                      (GHC.Prim.atomically#
                         @ Language.PureScript.Ide.Types.IdeVolatileState
                         (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case st of wild { GHC.Conc.Sync.TVar tvar# ->
                          case GHC.Prim.readTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 eta of ds { (#,#) ipv ipv1 ->
                          (# ipv,
                             Language.PureScript.Ide.Types.ideVolatileState ipv1 #) } }))
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <Language.PureScript.Ide.Types.IdeVolatileState>_R)))) -}
017ce8f07520bcf23e97e215fc9a4bd3
  insertExterns ::
    Language.PureScript.Ide.Types.Ide m =>
    Language.PureScript.Externs.ExternsFile -> m ()
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))><L,U(U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m)
                   (eta :: Language.PureScript.Externs.ExternsFile) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ ()
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (st :: GHC.Conc.Sync.TVar
                               Language.PureScript.Ide.Types.IdeState) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ ()
                      (GHC.Prim.atomically#
                         @ ()
                         (Language.PureScript.Ide.State.insertExterns1 st eta))
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <()>_R)))) -}
c41eac01b0710adafc1e64ddad9a0274
  insertExterns1 ::
    GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState
    -> Language.PureScript.Externs.ExternsFile
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><L,1*U(U,U,U,U,U,U,U,U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   (w1 :: Language.PureScript.Externs.ExternsFile)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Conc.Sync.TVar ww1 ->
                 Language.PureScript.Ide.State.$winsertExternsSTM ww1 w1 w2 }) -}
5c28472f1fe881ee3cd58649bd55455d
  insertExternsSTM ::
    GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState
    -> Language.PureScript.Externs.ExternsFile -> GHC.Conc.Sync.STM ()
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><L,1*U(U,U,U,U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Ide.State.insertExterns1
                  `cast`
                (<GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState>_R
                 ->_R <Language.PureScript.Externs.ExternsFile>_R
                 ->_R Sym (GHC.Conc.Sync.N:STM[0] <()>_R)) -}
66795f39a6ec8c2285ea26ffbc233e0d
  insertModule ::
    Language.PureScript.Ide.Types.Ide m =>
    (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
    -> m ()
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))><L,U(U,U(U,U,U,U,U))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m)
                   (eta :: (GHC.IO.FilePath,
                            Language.PureScript.AST.Declarations.Module)) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ ()
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (stateVar :: GHC.Conc.Sync.TVar
                                     Language.PureScript.Ide.Types.IdeState) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ ()
                      (GHC.Prim.atomically#
                         @ ()
                         (case eta of wild { (,) fp module' ->
                          \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case stateVar of wild1 { GHC.Conc.Sync.TVar tvar# ->
                          case GHC.Prim.readTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 s of ds { (#,#) ipv ipv1 ->
                          case GHC.Prim.writeTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 (case ipv1 of wild2 { Language.PureScript.Ide.Types.IdeState ds1 ds2 ->
                                  Language.PureScript.Ide.Types.IdeState
                                    (case ds1 of wild3 { Language.PureScript.Ide.Types.IdeFileState ds3 ds4 ->
                                     Language.PureScript.Ide.Types.IdeFileState
                                       ds3
                                       (case module' of wild4 { Language.PureScript.AST.Declarations.Module ds5 ds6 name ds7 ds8 ->
                                        Language.PureScript.Ide.State.$sinsert_$sgo13
                                          @ (Language.PureScript.AST.Declarations.Module,
                                             GHC.IO.FilePath)
                                          name
                                          name
                                          (wild4, fp)
                                          ds4 }) })
                                    ds2 })
                                 ipv of s2# { DEFAULT ->
                          (# s2#, GHC.Tuple.() #) } } } }))
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <()>_R)))) -}
9a1e82d6fe6e465c5f95071acff86867
  populateVolatileState ::
    (Language.PureScript.Ide.Types.Ide m,
     Control.Monad.Logger.MonadLogger m) =>
    m (Control.Concurrent.Async.Async ())
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(U(U(A,C(C1(U)),A,A,A),C(U)),U(A,U,A,A))><L,A>,
     Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ @ m :: * -> *
                   (w :: Language.PureScript.Ide.Types.Ide m)
                   (w1 :: Control.Monad.Logger.MonadLogger m) ->
                 Language.PureScript.Ide.State.$wpopulateVolatileState @ m w) -}
064f23e562ee619771a634f74cee160a
  populateVolatileState1 ::
    GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState
    -> Language.PureScript.Ide.Types.IdeEnvironment
    -> (Language.Haskell.TH.Syntax.Loc
        -> Control.Monad.Logger.LogSource
        -> Control.Monad.Logger.LogLevel
        -> System.Log.FastLogger.LogStr.LogStr
        -> GHC.Types.IO ())
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U(U)><L,U><L,U><S,U>,
     Unfolding: (\ (st :: GHC.Conc.Sync.TVar
                            Language.PureScript.Ide.Types.IdeState)
                   (eta :: Language.PureScript.Ide.Types.IdeEnvironment)
                   (eta1 :: Language.Haskell.TH.Syntax.Loc
                            -> Control.Monad.Logger.LogSource
                            -> Control.Monad.Logger.LogLevel
                            -> System.Log.FastLogger.LogStr.LogStr
                            -> GHC.Types.IO ())
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   lvl13 :: GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                  Language.PureScript.Ide.Types.ModuleMap
                                    (Language.PureScript.Ide.Reexports.ReexportResult
                                       [Language.PureScript.Ide.Types.IdeDeclarationAnn]) #)
                     {- Arity: 1 -}
                   = Language.PureScript.Ide.State.populateVolatileState4 st
                 } in
                 case (((Language.PureScript.Ide.Logging.logPerf
                           @ (Control.Monad.Trans.Reader.ReaderT
                                Language.PureScript.Ide.Types.IdeEnvironment
                                (Control.Monad.Logger.LoggingT GHC.Types.IO))
                           @ (Language.PureScript.Ide.Types.ModuleMap
                                (Language.PureScript.Ide.Reexports.ReexportResult
                                   [Language.PureScript.Ide.Types.IdeDeclarationAnn]))
                           (Language.PureScript.Ide.State.$s$fMonadIOReaderT
                              @ Language.PureScript.Ide.Types.IdeEnvironment)
                           (Language.PureScript.Ide.State.$s$fMonadLoggerReaderT
                              @ Language.PureScript.Ide.Types.IdeEnvironment)
                           Language.PureScript.Ide.State.populateVolatileState3
                           (\ (r1 :: Language.PureScript.Ide.Types.IdeEnvironment)
                              (eta3 :: Language.Haskell.TH.Syntax.Loc
                                       -> Control.Monad.Logger.LogSource
                                       -> Control.Monad.Logger.LogLevel
                                       -> System.Log.FastLogger.LogStr.LogStr
                                       -> GHC.Types.IO ())
                              (eta4 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case GHC.Prim.atomically#
                                   @ (Language.PureScript.Ide.Types.ModuleMap
                                        (Language.PureScript.Ide.Reexports.ReexportResult
                                           [Language.PureScript.Ide.Types.IdeDeclarationAnn]))
                                   lvl13
                                   eta4 of ds1 { (#,#) ipv ipv1 ->
                            case ipv1 of r { DEFAULT -> ds1 } })
                             `cast`
                           ((<Language.PureScript.Ide.Types.IdeEnvironment>_R
                             ->_R (<Language.Haskell.TH.Syntax.Loc
                                    -> Control.Monad.Logger.LogSource
                                    -> Control.Monad.Logger.LogLevel
                                    -> System.Log.FastLogger.LogStr.LogStr
                                    -> GHC.Types.IO ()>_R
                                   ->_R Sym (GHC.Types.N:IO[0]
                                                 <Language.PureScript.Ide.Types.ModuleMap
                                                    (Language.PureScript.Ide.Reexports.ReexportResult
                                                       [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_R)) ; Sym (Control.Monad.Logger.N:LoggingT[0]
                                                                                                                          <GHC.Types.IO>_R
                                                                                                                          <Language.PureScript.Ide.Types.ModuleMap
                                                                                                                             (Language.PureScript.Ide.Reexports.ReexportResult
                                                                                                                                [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                                                   <*>_N
                                                                                                                                                                                                   <Language.PureScript.Ide.Types.IdeEnvironment>_R
                                                                                                                                                                                                   <Control.Monad.Logger.LoggingT
                                                                                                                                                                                                      GHC.Types.IO>_R
                                                                                                                                                                                                   <Language.PureScript.Ide.Types.ModuleMap
                                                                                                                                                                                                      (Language.PureScript.Ide.Reexports.ReexportResult
                                                                                                                                                                                                         [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_N)))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Language.PureScript.Ide.Types.IdeEnvironment>_R
                             <Control.Monad.Logger.LoggingT GHC.Types.IO>_R
                             <Language.PureScript.Ide.Types.ModuleMap
                                (Language.PureScript.Ide.Reexports.ReexportResult
                                   [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_N)
                          eta)
                         `cast`
                       (Control.Monad.Logger.N:LoggingT[0]
                            <GHC.Types.IO>_R
                            <Language.PureScript.Ide.Types.ModuleMap
                               (Language.PureScript.Ide.Reexports.ReexportResult
                                  [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_N)
                         eta1)
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Language.PureScript.Ide.Types.ModuleMap
                              (Language.PureScript.Ide.Reexports.ReexportResult
                                 [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_R)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 case Language.PureScript.Ide.State.$wgo13
                        (Data.Map.Internal.filterWithKey
                           @ Language.PureScript.Names.ModuleName
                           @ (Language.PureScript.Ide.Reexports.ReexportResult
                                [Language.PureScript.Ide.Types.IdeDeclarationAnn])
                           Language.PureScript.Ide.State.populateVolatileState2
                           ipv1)
                        eta1
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 (# ipv2, GHC.Tuple.() #) } }) -}
e00ec78900cf0c8485fd804040c3fa7e
  populateVolatileState2 ::
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Ide.Reexports.ReexportResult
         [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Language.PureScript.Names.ModuleName)
                   (x :: Language.PureScript.Ide.Reexports.ReexportResult
                           [Language.PureScript.Ide.Types.IdeDeclarationAnn])[OneShot] ->
                 Language.PureScript.Ide.Reexports.reexportHasFailures
                   @ [Language.PureScript.Ide.Types.IdeDeclarationAnn]
                   x) -}
6e8466f58f5f5923bb6c82192a2dd5cc
  populateVolatileState3 ::
    System.Clock.TimeSpec -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <L,1*U(U,U)> -}
61e9753aa20164cfdf7566080cfa8b3a
  populateVolatileState4 ::
    GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Language.PureScript.Ide.Types.ModuleMap
            (Language.PureScript.Ide.Reexports.ReexportResult
               [Language.PureScript.Ide.Types.IdeDeclarationAnn]) #)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Conc.Sync.TVar ww1 ->
                 Language.PureScript.Ide.State.$wpopulateVolatileStateSTM
                   ww1
                   w1 }) -}
031031dfac46ad8776d5846f35cbbec4
  populateVolatileStateSTM ::
    GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState
    -> GHC.Conc.Sync.STM
         (Language.PureScript.Ide.Types.ModuleMap
            (Language.PureScript.Ide.Reexports.ReexportResult
               [Language.PureScript.Ide.Types.IdeDeclarationAnn]))
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Ide.State.populateVolatileState4
                  `cast`
                (<GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState>_R
                 ->_R Sym (GHC.Conc.Sync.N:STM[0]
                               <Language.PureScript.Ide.Types.ModuleMap
                                  (Language.PureScript.Ide.Reexports.ReexportResult
                                     [Language.PureScript.Ide.Types.IdeDeclarationAnn])>_R)) -}
1a19f10e64a783104721de6274628d72
  populateVolatileStateSync ::
    (Language.PureScript.Ide.Types.Ide m,
     Control.Monad.Logger.MonadLogger m) =>
    m ()
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(U(U(1*U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),A,A),C(U)),1*U(A,1*U,A,A))><L,U(A,C(C1(C1(C1(C(U))))))> -}
8c893e933af7ee06904ac9e5f58b28ad
  resetIdeState :: Language.PureScript.Ide.Types.Ide m => m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLL)L)L),U(1*U(1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),1*C1(C1(U)),A,A,A),C(U)),1*U(A,1*U,A,A))>,
     Unfolding: (\ @ m :: * -> *
                   ($d(%,%) :: Language.PureScript.Ide.Types.Ide m) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = GHC.Classes.$p1(%,%)
                       @ (Control.Monad.IO.Class.MonadIO m)
                       @ (Control.Monad.Reader.Class.MonadReader
                            Language.PureScript.Ide.Types.IdeEnvironment m)
                       $d(%,%)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                   @ ()
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                      @ Language.PureScript.Ide.Types.IdeEnvironment
                      @ (GHC.Conc.Sync.TVar Language.PureScript.Ide.Types.IdeState)
                      Language.PureScript.Ide.Types.ideStateVar
                      (Control.Monad.Reader.Class.ask
                         @ Language.PureScript.Ide.Types.IdeEnvironment
                         @ m
                         (GHC.Classes.$p2(%,%)
                            @ (Control.Monad.IO.Class.MonadIO m)
                            @ (Control.Monad.Reader.Class.MonadReader
                                 Language.PureScript.Ide.Types.IdeEnvironment m)
                            $d(%,%))))
                   (\ (ideVar :: GHC.Conc.Sync.TVar
                                   Language.PureScript.Ide.Types.IdeState) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ ()
                      (GHC.Prim.atomically#
                         @ ()
                         (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case ideVar of wild { GHC.Conc.Sync.TVar tvar# ->
                          case GHC.Prim.writeTVar#
                                 @ GHC.Prim.RealWorld
                                 @ Language.PureScript.Ide.Types.IdeState
                                 tvar#
                                 Language.PureScript.Ide.Types.emptyIdeState
                                 eta of s2# { DEFAULT ->
                          (# s2#, GHC.Tuple.() #) } }))
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <()>_R)))) -}
6a05368cf82b6f9e83f2216e4002694c
  resolveDataConstructorsForModule ::
    [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> [Language.PureScript.Ide.Types.IdeDeclarationAnn]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (decls :: [Language.PureScript.Ide.Types.IdeDeclarationAnn]) ->
                 let {
                   dtors :: Data.Map.Internal.Map
                              (Language.PureScript.Names.ProperName
                                 'Language.PureScript.Names.TypeName)
                              [(Language.PureScript.Names.ProperName
                                  'Language.PureScript.Names.ConstructorName,
                                Language.PureScript.Types.SourceType)]
                   = Language.PureScript.Ide.State.resolveDataConstructorsForModule_go
                       decls
                 } in
                 GHC.Base.map
                   @ Language.PureScript.Ide.Types.IdeDeclarationAnn
                   @ Language.PureScript.Ide.Types.IdeDeclarationAnn
                   (Language.PureScript.Ide.State.$sidaDeclaration1
                      (\ (decl :: Language.PureScript.Ide.Types.IdeDeclaration) ->
                       case decl of wild {
                         DEFAULT -> wild
                         Language.PureScript.Ide.Types.IdeDeclType ty
                         -> Language.PureScript.Ide.Types.IdeDeclType
                              (case ty of wild1 { Language.PureScript.Ide.Types.IdeType x x1 x2 ->
                               Language.PureScript.Ide.Types.IdeType
                                 x
                                 x1
                                 (case x `cast`
                                       (Language.PureScript.Names.N:ProperName[0]
                                            <'Language.PureScript.Names.TypeName>_P) of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                                  case Language.PureScript.Ide.State.$wpoly_go1
                                         @ [(Language.PureScript.Names.ProperName
                                               'Language.PureScript.Names.ConstructorName,
                                             Language.PureScript.Types.SourceType)]
                                         ww1
                                         ww2
                                         ww3
                                         dtors of wild2 {
                                    GHC.Base.Nothing
                                    -> GHC.Types.[]
                                         @ (Language.PureScript.Names.ProperName
                                              'Language.PureScript.Names.ConstructorName,
                                            Language.PureScript.Types.SourceType)
                                    GHC.Base.Just v -> v } }) }) })
                        `cast`
                      (<Language.PureScript.Ide.Types.IdeDeclaration>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <Language.PureScript.Ide.Types.IdeDeclaration>_R)))
                     `cast`
                   (<Language.PureScript.Ide.Types.IdeDeclarationAnn>_R
                    ->_R Data.Functor.Identity.N:Identity[0]
                             <Language.PureScript.Ide.Types.IdeDeclarationAnn>_R)
                   decls) -}
6b781176178c10016d7aa80419000393
  resolveDataConstructorsForModule_go ::
    [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> Data.Map.Internal.Map
         (Language.PureScript.Names.ProperName
            'Language.PureScript.Names.TypeName)
         [(Language.PureScript.Names.ProperName
             'Language.PureScript.Names.ConstructorName,
           Language.PureScript.Types.SourceType)]
  {- Arity: 1, Strictness: <S,1*U> -}
edc90703fbb2e1967c08728162291956
  resolveInstances ::
    Language.PureScript.Ide.Types.ModuleMap
      Language.PureScript.Externs.ExternsFile
    -> Language.PureScript.Ide.Types.ModuleMap
         [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> Language.PureScript.Ide.Types.ModuleMap
         [Language.PureScript.Ide.Types.IdeDeclarationAnn]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (externs :: Language.PureScript.Ide.Types.ModuleMap
                                 Language.PureScript.Externs.ExternsFile)
                   (declarations :: Language.PureScript.Ide.Types.ModuleMap
                                      [Language.PureScript.Ide.Types.IdeDeclarationAnn]) ->
                 Language.PureScript.Ide.State.resolveInstances_go13
                   declarations
                   (Data.Map.Internal.mapWithKey
                      @ Language.PureScript.Names.ModuleName
                      @ Language.PureScript.Externs.ExternsFile
                      @ [(Language.PureScript.Ide.Types.IdeInstance,
                          Language.PureScript.Names.ModuleName,
                          Language.PureScript.Names.ProperName
                            'Language.PureScript.Names.ClassName)]
                      Language.PureScript.Ide.State.resolveInstances1
                      externs)) -}
b638d3e181a09563165817fd13b69415
  resolveInstances1 ::
    Language.PureScript.Names.ModuleName
    -> Language.PureScript.Externs.ExternsFile
    -> [(Language.PureScript.Ide.Types.IdeInstance,
         Language.PureScript.Names.ModuleName,
         Language.PureScript.Names.ProperName
           'Language.PureScript.Names.ClassName)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U,A)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.PureScript.Names.ModuleName)
                   (w1 :: Language.PureScript.Externs.ExternsFile) ->
                 case w1 of ww { Language.PureScript.Externs.ExternsFile ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Language.PureScript.Ide.State.$wlvl w ww7 }) -}
e6da49fb08ca5751552838ddd50f4104
  resolveInstances_go13 ::
    Language.PureScript.Ide.Types.ModuleMap
      [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> Data.Map.Internal.Map
         Language.PureScript.Names.ModuleName
         [(Language.PureScript.Ide.Types.IdeInstance,
           Language.PureScript.Names.ModuleName,
           Language.PureScript.Names.ProperName
             'Language.PureScript.Names.ClassName)]
    -> Language.PureScript.Ide.Types.ModuleMap
         [Language.PureScript.Ide.Types.IdeDeclarationAnn]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
9551f5b8103f3cd6dbea74940ab7cd58
  resolveOperatorsForModule ::
    Language.PureScript.Ide.Types.ModuleMap
      [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> [Language.PureScript.Ide.Types.IdeDeclarationAnn]
    -> [Language.PureScript.Ide.Types.IdeDeclarationAnn]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
"SC:poly_go130" forall @ a
                       (sc :: Data.Map.Internal.Map Language.PureScript.Names.Ident a)
                       (sc1 :: Data.Text.Internal.Text)
  Language.PureScript.Ide.State.$slookup1 @ a
                                          (Language.PureScript.Names.Ident sc1)
                                          sc
  = Language.PureScript.Ide.State.$slookup_$spoly_go2 @ a sc sc1
"SC:poly_go131" forall @ a
                       (sc :: Data.Map.Internal.Map Language.PureScript.Names.Ident a)
                       (sc1 :: GHC.Base.Maybe Data.Text.Internal.Text)
                       (sc2 :: GHC.Integer.Type.Integer)
  Language.PureScript.Ide.State.$slookup1 @ a
                                          (Language.PureScript.Names.GenIdent sc1 sc2)
                                          sc
  = Language.PureScript.Ide.State.$slookup_$spoly_go1 @ a sc sc1 sc2
"SC:poly_go132" forall @ a
                       (sc :: Data.Map.Internal.Map Language.PureScript.Names.Ident a)
  Language.PureScript.Ide.State.$slookup1 @ a
                                          Language.PureScript.Names.UnusedIdent
                                          sc
  = Language.PureScript.Ide.State.$slookup_$spoly_go13 @ a sc
"SPEC/Language.PureScript.Ide.State $fApplicativeLoggingT @ IO" [orphan] forall (v :: GHC.Base.Applicative
                                                                                        GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.State.$s$fApplicativeLoggingT
"SPEC/Language.PureScript.Ide.State $fApplicativeLoggingT_$c<*> @ IO" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                          GHC.Types.IO)
  Control.Monad.Logger.$fApplicativeLoggingT_$c<*> @ GHC.Types.IO
                                                   $dApplicative
  = Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fApplicativeLoggingT_$c<*>
"SPEC/Language.PureScript.Ide.State $fFunctorLoggingT @ IO" [orphan] forall (v :: GHC.Base.Functor
                                                                                    GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fFunctorLoggingT
"SPEC/Language.PureScript.Ide.State $fFunctorLoggingT_$cfmap @ IO" [orphan] forall ($dFunctor :: GHC.Base.Functor
                                                                                                   GHC.Types.IO)
  Control.Monad.Logger.$fFunctorLoggingT_$cfmap @ GHC.Types.IO
                                                $dFunctor
  = Language.PureScript.Ide.State.$s$fApplicativeLoggingT_$s$fFunctorLoggingT_$cfmap
"SPEC/Language.PureScript.Ide.State $fMonadIOReaderT @ (LoggingT
                                                         IO) _" [orphan] forall @ r
                                                                                                                                                 (v :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                         (Control.Monad.Logger.LoggingT
                                                                                                                                                            GHC.Types.IO))
  Control.Monad.Trans.Reader.$fMonadIOReaderT @ (Control.Monad.Logger.LoggingT
                                                   GHC.Types.IO)
                                              @ r
                                              v
  = Language.PureScript.Ide.State.$s$fMonadIOReaderT @ r
"SPEC/Language.PureScript.Ide.State $fMonadLoggerReaderT @ (LoggingT
                                                             IO) _" [orphan] forall @ r
                                                                                                                                                         (v :: Control.Monad.Logger.MonadLogger
                                                                                                                                                                 (Control.Monad.Logger.LoggingT
                                                                                                                                                                    GHC.Types.IO))
  Control.Monad.Logger.$fMonadLoggerReaderT @ (Control.Monad.Logger.LoggingT
                                                 GHC.Types.IO)
                                            @ r
                                            v
  = Language.PureScript.Ide.State.$s$fMonadLoggerReaderT @ r
"SPEC/Language.PureScript.Ide.State $fMonadLoggingT @ IO" [orphan] forall (v :: GHC.Base.Monad
                                                                                  GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT @ GHC.Types.IO v
  = Language.PureScript.Ide.State.$s$fMonadIOLoggingT_$s$fMonadLoggingT
"SPEC/Language.PureScript.Ide.State $fMonadLoggingT_$c>> @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$c>> @ GHC.Types.IO $dMonad
  = Language.PureScript.Ide.State.$s$fMonadIOLoggingT_$s$fMonadLoggingT_$c>>
"SPEC/Language.PureScript.Ide.State $fMonadLoggingT_$creturn @ IO" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                 GHC.Types.IO)
  Control.Monad.Logger.$fMonadLoggingT_$creturn @ GHC.Types.IO
                                                $dMonad
  = Language.PureScript.Ide.State.$s$fMonadLoggingT_$creturn
"SPEC/Language.PureScript.Ide.State idaDeclaration @ Identity" [orphan] forall ($dFunctor :: GHC.Base.Functor
                                                                                               Data.Functor.Identity.Identity)
  Language.PureScript.Ide.Types.idaDeclaration @ Data.Functor.Identity.Identity
                                               $dFunctor
  = Language.PureScript.Ide.State.$sidaDeclaration1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

