
==================== FINAL INTERFACE ====================
2018-11-30 20:47:30.614548 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeChecker.TypeSearch 8043
  interface hash: c7bda86b670869ec78707dab835dec1d
  ABI hash: 971bd6990ae7d5d0f8c0450a6d97386f
  export-list hash: e1d70b4784f1127a637cd9219c285f66
  orphan hash: 94202ce45ae7f6afcb30e3de9dd88ac5
  flag hash: 16532b0f9807287e7d68a156c2412cf2
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.TypeSearch.typeSearch
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeChecker.Entailment
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeChecker.Subsumption
                     Language.PureScript.TypeChecker.Synonyms
                     Language.PureScript.TypeChecker.Unify
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 boxes-0.1.5 bytestring-0.10.8.2 colour-2.3.4
                      containers-0.5.11.0 data-ordlist-0.4.7.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 mtl-2.2.2 parsec-3.1.13.0
                      pattern-arrows-0.0.2 pretty-1.1.3.6 primitive-0.6.3.0
                      protolude-0.2.2 random-1.1 scientific-0.3.6.2 sourcemap-0.1.6
                      split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Declarations
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Operators
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.SourcePos
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Environment
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Kinds
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Label
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Names
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Bifunctor a977586bad544f929bb5bc7f139aaa1c
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer b86905dc6b5d4d3a09dfa93d3ac3bb98
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  Control.Monad.Supply a9e15eeca39e18ec2ace0537b1dcfc3b
  exports: 33181f9f2f157b80f20fe5bc34a62230
  SupplyT a33fc23ef2131a2ed4dfdd2f28dff7f5
  evalSupplyT 0eec7b049b5a1acfcf48e5b194c10980
import  -/  Language.PureScript.AST 7ed0e74bfed5b6489b8a5eabab5c0241
  exports: 0d53d92339536cd6d8d7dcfcad8e7c7e
import  -/  Language.PureScript.AST.Declarations 568e046fbf27b243bfc96f09017d4782
  Expr b31d94d0c7b90700d40f9ba6ec420e41
  Var 0202d242cce06e67fa6944b3c05a8982
import  -/  Language.PureScript.AST.SourcePos b3f67f807f2dce79528bbb15bd9c7104
  nullSourceSpan 24686a17cbb8e08b60ddb2b502e97316
import  -/  Language.PureScript.AST.Traversals a3d1a9b4309f1aa3055f23e3fb101c5e
  overTypes abfbcc4ac387d3565fd77fe0109b088c
import  -/  Language.PureScript.Environment 31667499b7017b19998bb405474fbe93
  exports: 56b1ef0ac6132b4c113ce26a807dcfb6
  Environment c291d940fae22a3f1400d8c90f26bdd4
  dataConstructors c291d940fae22a3f1400d8c90f26bdd4
  names c291d940fae22a3f1400d8c90f26bdd4
  tyFunction 9783ce0b37378c763c53f9a28f7311d6
  tyRecord fcace11d48da9699cb692901edeeb943
import  -/  Language.PureScript.Errors 15d6eb6b2d4d480750061a0585d4e64c
  exports: 142ea650dec62642d1cff09ef1eee74e
  MultipleErrors ad1de73a1d5a6b0ccd9657dedebc94f3
import  -/  Language.PureScript.Label ac3bc484eb8b3b2ccf228cc34cdb537c
  exports: 62e65d694c1e96c81750d9cacc93e898
  Label 61523a5f4fc28a2f2f6f00cce17ce1bb
import  -/  Language.PureScript.Names b3bf151840f3e8f2eb61eff186432886
  exports: f7f3503d20957194bda83c16bb5f1288
  Ident 0ccd7f2221de64569e50634367691253
  Ident ab98a56ffa88760dad1380079e8ee35a
  Qualified d600a7f01c8203cf5504999de99c923c
  Qualified 5a70062bbdf29e6dc659ad8bf5326b50
  runIdent bc5cc3d3ba9d105c169eb6038c65d1a8
  runProperName 29f101e190cc99df85623423972e606f
import  -/  Language.PureScript.Pretty.Types 55abc63b15198d7c72c92dad86c3e447
  exports: b40ff76265cae147b2217367d81cb585
  prettyPrintLabel 71e2d247b7c00b68530ecf063e33557c
import  -/  Language.PureScript.TypeChecker.Entailment eb87eb512eb19a11b2861f2572464863
  exports: f1282b4b4aaf0007ce1148430891b83d
  InstanceContext 772fb157afb03c9650f31f199333ba1b
  SolverOptions 694b52cc954a9c29d336d110e12c03fc
  entails 87ac940646bf8506d5a2b1a3dc57f4b9
  replaceTypeClassDictionaries f9df72a17332b37a407ba207b48420ad
  solverDeferErrors 703525f42f7a430a406f959ec858e06b
  solverShouldGeneralize 703525f42f7a430a406f959ec858e06b
import  -/  Language.PureScript.TypeChecker.Monad 36a86b5cfef989dae17621bbace19db6
  exports: 9d9d275b045efb93172c1bb44957da47
  CheckState 5c23016b2e80baec4bdda0c92644cfa1
  checkEnv 5c23016b2e80baec4bdda0c92644cfa1
  checkSubstitution 5c23016b2e80baec4bdda0c92644cfa1
  runCheck' f8873ffc1b9f3cb742376b7e71bf802e
import  -/  Language.PureScript.TypeChecker.Skolems f177d1401fc0e1a8b89ef83cdae40ba1
  exports: 96cf1a567f2e8b0e83ff8cd880c3e6bb
  introduceSkolemScope 80e9b7ccd3f749b385f0a6b18602483d
import  -/  Language.PureScript.TypeChecker.Subsumption 32783e5a2ab496371fc65df0d10c4c0f
  exports: e74c627ee87f849c4b9c2a42e591b46e
  subsumes 0e109a7eb67e5bf86f5c17cf2e9f77d7
import  -/  Language.PureScript.TypeChecker.Synonyms 37e3cc0c7ba99bff75cbf7234c3426aa
  exports: 94023ae96d0e0cb3ccde1f6c60d6e8aa
  replaceAllTypeSynonyms 3a24aee19c293628846c3a52d88ec9df
import  -/  Language.PureScript.TypeChecker.Unify 8691f08fe31a36c2d93443f4bddc13e8
  exports: d8da060597f9e4fdf658eaa278b38c79
  freshType a5c186ce5fbab18def6677e2fd12efbe
  replaceTypeWildcards 39dae1f35751cd68b64a065a9bb27fd3
  substituteType 790e5acc35abed1f12851a447c85f713
import  -/  Language.PureScript.Types 74562e642f5297557b3a23aac7819ad1
  exports: ae97bc75fcebc59f59c970736847a827
  Constraint 93223f8afa90d0facc05a03f863dc72d
  Type 93223f8afa90d0facc05a03f863dc72d
  TypeApp 8aa2c93426facb8054d5caf77ff9d922
  mapConstraintArgs 4c5821e8c0e3a903ec8fe07d5d289eaf
  rowToList 9d77c0b5f0cca3b051e88fcf65501542
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Writer.Lazy 932eb57f5933138df24d28686f218b40
422a672a40b94b4d681f9a2fa46162da
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ c
                     (Data.Either.$fApplicativeEither_$cfmap
                        @ e
                        @ a
                        @ (b -> c)
                        f1
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> c>_N)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ a
                     (Control.Monad.Trans.Except.$fApplicativeExceptT1
                        @ a
                        @ b
                        @ e
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> a>_N))) -}
85c9fa55470db0821e3280888c058123
  $s$fApplicativeExceptT_$c<* ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ Data.Functor.Identity.Identity
                   @ e
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ b
                   @ a
                   (Control.Monad.Trans.Except.$fApplicativeExceptT1
                      @ a
                      @ b
                      @ e
                      x `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <Data.Either.Either
                                e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <e>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <b -> a>_N))) -}
0e9be5db5504e7edae508c704bd8f82c
  $s$fApplicativeExceptT_$c<*>_$s$w$c<*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ e
                   @ a
                   @ b
                   (w1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity (a -> b))
                   (w2 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a) ->
                 case w1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e (a -> b)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <e>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <b>_N))
                   Data.Either.Right k
                   -> case w2
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N
                                <Data.Functor.Identity.Identity>_R
                                <a>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e a>_R) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left @ e @ b e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N))
                        Data.Either.Right x
                        -> (Data.Either.Right @ e @ b (k x))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N)) } }) -}
5b7e88392e13fe27fa6c93830ca1c674
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either e b>_R))
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <Data.Functor.Identity.Identity>_R <b>_N) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
d6ddfb872de6274c37e084cde550f7b8
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                Data.Either.Right
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <a>_N)) -}
967991e744257c62afadcb78079601bb
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity) -}
efcead040881074da163a681fb35ae76
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <c>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*>
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT1
                     @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
232cb241737361c430b6e5d00ab50412
  $s$fApplicativeStateT_$s$fApplicativeStateT1 ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> s
    -> Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ s
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           a)
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             s
                             (Control.Monad.Supply.SupplyT
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors)))
                             b)
                   (eta1 :: s) ->
                 let {
                   m1 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = x `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       eta1
                 } in
                 (\ (s1 :: GHC.Integer.Type.Integer) ->
                  case (m1
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s1)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left x1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((a, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          x1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right y
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case y of wild1 { (,) a1 w1 -> a1 }
                       } in
                       let {
                         ds1 :: (a, s) = case ds of wild1 { (,) a1 s' -> a1 }
                       } in
                       case ((eta
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds1 of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((a, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((a, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((a,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((a,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> let {
                              ds2 :: ((b, s), GHC.Integer.Type.Integer)
                              = case x1 of wild2 { (,) a1 w2 -> a1 }
                            } in
                            (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((a, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (((case ds1 of wild2 { (,) a1 s' -> a1 },
                                  case ds2 of wild2 { (,) a1 s' ->
                                  case a1 of wild3 { (,) x2 s'' -> s'' } }),
                                 case ds2 of wild2 { (,) a1 s' -> s' }),
                                (GHC.Base.build
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case y of wild2 { (,) a1 w1 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      (case x1 of wild3 { (,) a2 w2 ->
                                       GHC.Base.foldr
                                         @ Language.PureScript.AST.Declarations.ErrorMessage
                                         @ b1
                                         c
                                         n
                                         w2
                                           `cast`
                                         (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                      w1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((a, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((a,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((a,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(a,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                    s)>_N)) -}
9b3ac5006079b3ff84ce14bb6523eef7
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       case ((k `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' ->
                                 case a1 of wild2 { (,) a2 s'1 -> s'1 } }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
8ca24f5480eecd4d5fb1dd5ad69259ef
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s
                             (Control.Monad.Supply.SupplyT
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors)))
                             a)
                   (s1 :: s) ->
                 let {
                   m1 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a -> b, s)
                   = ds
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a -> b>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m1
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a
                                                                                                                 -> b,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a
                                                                                                                               -> b,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a -> b, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a -> b, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a
                                                                                                                              -> b,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds2 :: ((a -> b, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       let {
                         ds3 :: (a -> b, s) = case ds2 of wild1 { (,) a1 s' -> a1 }
                       } in
                       case ((ds1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <a>_N)
                                (case ds3 of wild1 { (,) f s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(a,
                                                                                                                                    s)>_N)
                               (case ds2 of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((a, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((a, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((a,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> let {
                              ds4 :: ((a, s), GHC.Integer.Type.Integer)
                              = case x1 of wild2 { (,) a1 w2 -> a1 }
                            } in
                            let {
                              ds5 :: (a, s) = case ds4 of wild2 { (,) a1 s' -> a1 }
                            } in
                            (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (((case ds3 of wild2 { (,) f s' ->
                                  f (case ds5 of wild3 { (,) x2 s'' -> x2 }) },
                                  case ds5 of wild2 { (,) x2 s'' -> s'' }),
                                 case ds4 of wild2 { (,) a1 s' -> s' }),
                                (GHC.Base.build
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      (case x1 of wild3 { (,) a2 w1 ->
                                       GHC.Base.foldr
                                         @ Language.PureScript.AST.Declarations.ErrorMessage
                                         @ b1
                                         c
                                         n
                                         w1
                                           `cast`
                                         (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
bae7cbbd814ed4310cebab9d5b99f3ed
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) (s1 :: s) ->
                 let {
                   eta :: (a, s) = (a1, s1)
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ (((a, s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <(a,
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)) -}
7f4fb02ae39f9fd928783b974be702ed
  $s$fApplicativeStateT_$s$fApplicativeSupplyT ::
    GHC.Base.Applicative
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((eta, eta1),
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (Control.Monad.Supply.$fApplicativeSupplyT4
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a
                                                                                                                -> b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                a)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta3 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
                        @ Language.PureScript.Errors.MultipleErrors)
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
                     @ a
                     @ b
                     @ c
                     eta
                     eta1
                     eta2
                     eta3)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <c>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((a, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((a,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left e1
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((b, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           e1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((b, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((b,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(b,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right x
                     -> case (eta1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <GHC.Integer.Type.Integer>_N
                                   <Control.Monad.Trans.Writer.Lazy.WriterT
                                      Language.PureScript.Errors.MultipleErrors
                                      (Control.Monad.Trans.Except.Except
                                         Language.PureScript.Errors.MultipleErrors)>_R
                                   <b>_N)
                                (case x of wild1 { (,) a1 w2 ->
                                 case a1 of wild2 { (,) a2 s' -> s' } }))
                               `cast`
                             (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Trans.Except.ExceptT
                                     Language.PureScript.Errors.MultipleErrors
                                     Data.Functor.Identity.Identity>_R
                                  <(b,
                                    GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                        <Data.Functor.Identity.Identity>_R
                                                                        <((b,
                                                                           GHC.Integer.Type.Integer),
                                                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                              <Data.Either.Either
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 ((b,
                                                                                                                                   GHC.Integer.Type.Integer),
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                          Data.Either.Left e1
                          -> (Data.Either.Left
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((b, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                e1)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((b, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((b,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(b,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N)))
                          Data.Either.Right x1
                          -> (Data.Either.Right
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((b, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                (case x1 of wild2 { (,) b1 w' -> b1 },
                                 (GHC.Base.augment
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    (\ @ b1
                                       (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                             -> b1 -> b1)[OneShot]
                                       (n :: b1)[OneShot] ->
                                     case x of wild2 { (,) a1 w2 ->
                                     GHC.Base.foldr
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       @ b1
                                       c
                                       n
                                       w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                    (case x1 of wild2 { (,) b1 w' ->
                                     w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                   `cast`
                                 (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((b, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((b,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(b,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((a, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((a,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left x
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           x)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right y
                     -> let {
                          ds :: (a, GHC.Integer.Type.Integer)
                          = case y of wild1 { (,) a1 w1 -> a1 }
                        } in
                        case (eta1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <GHC.Integer.Type.Integer>_N
                                   <Control.Monad.Trans.Writer.Lazy.WriterT
                                      Language.PureScript.Errors.MultipleErrors
                                      (Control.Monad.Trans.Except.Except
                                         Language.PureScript.Errors.MultipleErrors)>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Trans.Except.ExceptT
                                     Language.PureScript.Errors.MultipleErrors
                                     Data.Functor.Identity.Identity>_R
                                  <(b,
                                    GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                        <Data.Functor.Identity.Identity>_R
                                                                        <((b,
                                                                           GHC.Integer.Type.Integer),
                                                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                              <Data.Either.Either
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 ((b,
                                                                                                                                   GHC.Integer.Type.Integer),
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                          Data.Either.Left e1
                          -> (Data.Either.Left
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((a, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                e1)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N)))
                          Data.Either.Right x
                          -> (Data.Either.Right
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((a, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                ((case ds of wild2 { (,) a1 s' -> a1 },
                                  case x of wild2 { (,) a1 w2 ->
                                  case a1 of wild3 { (,) x1 s'' -> s'' } }),
                                 (GHC.Base.build
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    (\ @ b1
                                       (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                             -> b1 -> b1)[OneShot]
                                       (n :: b1)[OneShot] ->
                                     case y of wild2 { (,) a1 w1 ->
                                     GHC.Base.foldr
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       @ b1
                                       c
                                       (case x of wild3 { (,) a2 w2 ->
                                        GHC.Base.foldr
                                          @ Language.PureScript.AST.Declarations.ErrorMessage
                                          @ b1
                                          c
                                          n
                                          w2
                                            `cast`
                                          (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                       w1
                                         `cast`
                                       (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                   `cast`
                                 (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
dbfd33c6c6f3075fcfad9fdd3bbfb93a
  $s$fApplicativeStateT_$s$fApplicativeWriterT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
                     @ Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cliftA2
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     Language.PureScript.Errors.$fMonoidMultipleErrors
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
                        @ Language.PureScript.Errors.MultipleErrors))
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     Language.PureScript.Errors.$fMonoidMultipleErrors
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
                        @ Language.PureScript.Errors.MultipleErrors))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.Writer.Lazy.WriterT
                      Language.PureScript.Errors.MultipleErrors
                      (Control.Monad.Trans.Except.ExceptT
                         Language.PureScript.Errors.MultipleErrors
                         Data.Functor.Identity.Identity)
                      a>_R
                   ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           b>_R
                   ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <b>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity)
                               a) ->
                   Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                     @ b
                     @ a
                     (case eta
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(a,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (a,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                        Data.Either.Left x
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                              x)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b -> a,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <(b
                                                                                                      -> a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <b
                                                                                                                                                                 -> a>_N)))
                        Data.Either.Right y
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                              (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                                 @ a
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ b
                                 y))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b -> a,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <(b
                                                                                                      -> a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <b
                                                                                                                                                                 -> a>_N))) })) -}
0ed3c65a13b51b2d1c6065a4adcb7007
  $s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           (a -> b))
                   (v :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Errors.MultipleErrors
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ (a, Language.PureScript.Errors.MultipleErrors)
                   @ (b, Language.PureScript.Errors.MultipleErrors)
                   (case f `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <a -> b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <(a -> b,
                                                  Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                      <Data.Either.Either
                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                         (a
                                                                                                          -> b,
                                                                                                          Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ ((a, Language.PureScript.Errors.MultipleErrors)
                               -> (b, Language.PureScript.Errors.MultipleErrors))
                            x)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      ((a, Language.PureScript.Errors.MultipleErrors)
                                       -> (b,
                                           Language.PureScript.Errors.MultipleErrors))>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(a,
                                                                                                        Language.PureScript.Errors.MultipleErrors)
                                                                                                       -> (b,
                                                                                                           Language.PureScript.Errors.MultipleErrors)>_N))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ ((a, Language.PureScript.Errors.MultipleErrors)
                               -> (b, Language.PureScript.Errors.MultipleErrors))
                            (\ (ds1 :: (a, Language.PureScript.Errors.MultipleErrors)) ->
                             (case y of wild1 { (,) a1 w1 ->
                              a1 (case ds1 of wild2 { (,) b1 w' -> b1 }) },
                              (GHC.Base.augment
                                 @ Language.PureScript.AST.Declarations.ErrorMessage
                                 (\ @ b1
                                    (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                          -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  case y of wild1 { (,) a1 w1 ->
                                  GHC.Base.foldr
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    @ b1
                                    c
                                    n
                                    w1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                 (case ds1 of wild1 { (,) b1 w' ->
                                  w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                `cast`
                              (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      ((a, Language.PureScript.Errors.MultipleErrors)
                                       -> (b,
                                           Language.PureScript.Errors.MultipleErrors))>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(a,
                                                                                                        Language.PureScript.Errors.MultipleErrors)
                                                                                                       -> (b,
                                                                                                           Language.PureScript.Errors.MultipleErrors)>_N)) })
                   v `cast`
                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                        <Language.PureScript.Errors.MultipleErrors>_N
                        <Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           Data.Functor.Identity.Identity>_R
                        <a>_N))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         Language.PureScript.Errors.MultipleErrors
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            Data.Functor.Identity.Identity)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
18db66fb43f460ce09f9cb68ff6f836f
  $s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (a1 :: a) ->
                 Data.Either.Right
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (a, Language.PureScript.Errors.MultipleErrors)
                   (a1,
                    (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                      `cast`
                    (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  Language.PureScript.Errors.MultipleErrors
                                  (a,
                                   Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(a,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                          <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                             Data.Functor.Identity.Identity>_R
                                                                                                                                                          <a>_N))) -}
b82b1b59a16d76741c3788341a048a8b
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s
                               (Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors)))
                               b)
                     (eta1 :: s) ->
                   let {
                     m1 :: Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))
                             (b, s)
                     = eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <b>_N)
                         eta1
                   } in
                   (\ (s1 :: GHC.Integer.Type.Integer) ->
                    case (m1
                            `cast`
                          (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                Language.PureScript.Errors.MultipleErrors
                                                                (Control.Monad.Trans.Except.Except
                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                   s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                               <(b,
                                                                                                                                 s)>_N)
                            s1)
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <((b, s),
                                GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                    <Data.Functor.Identity.Identity>_R
                                                                    <(((b, s),
                                                                       GHC.Integer.Type.Integer),
                                                                      Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                          <Data.Either.Either
                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                             (((b,
                                                                                                                                s),
                                                                                                                               GHC.Integer.Type.Integer),
                                                                                                                              Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x1
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            x1)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N)))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            (let {
                               ds :: ((b, s), GHC.Integer.Type.Integer)
                               = case y of wild1 { (,) a1 w1 -> a1 }
                             } in
                             ((x,
                               case ds of wild1 { (,) a1 s' ->
                               case a1 of wild2 { (,) a2 s'1 -> s'1 } }),
                              case ds of wild1 { (,) a1 s' -> s' }),
                             case y of wild1 { (,) a1 w1 -> w1 }))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) })
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <GHC.Integer.Type.Integer>_N
                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors)>_R
                             <(a,
                               s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                   (Control.Monad.Trans.Except.Except
                                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                      s)>_N))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
c5c7f266ba49d03cdbdf0ef073fafa4b
  $s$fApplicativeStateT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left x
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         x)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right y
                   -> (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         (let {
                            ds :: (a, s) = case y of wild1 { (,) a1 w1 -> a1 }
                          } in
                          (f (case ds of wild1 { (,) a1 s' -> a1 }),
                           case ds of wild1 { (,) a1 s' -> s' }),
                          case y of wild1 { (,) a1 w1 -> w1 }))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N))) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
4aac70d83d398fc70e1a2365f4f5d44d
  $s$fApplicativeStateT_$s$fFunctorSupplyT ::
    GHC.Base.Functor
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               b)
                     (eta1 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <b>_N)
                           eta1)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(b,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((b, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((b,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left x1
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           x1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right y
                     -> (Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           ((x,
                             case y of wild1 { (,) a1 w1 ->
                             case a1 of wild2 { (,) a2 s' -> s' } }),
                            case y of wild1 { (,) a1 w1 -> w1 }))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N))) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
77250d0ed008a9ae7726626c626a9d9b
  $s$fApplicativeStateT_$s$fFunctorWriterT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ w.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       w
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap
                     @ w)
                  (\ @ a @ b (x :: a) ->
                   Control.Monad.Trans.Writer.Lazy.mapWriterT
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     @ b
                     @ w
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     @ a
                     @ w
                     (\ (x1 :: Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity
                                 (b, w)) ->
                      case x1
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Data.Functor.Identity.Identity>_R
                                <(b, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                 <Data.Either.Either
                                                    Language.PureScript.Errors.MultipleErrors
                                                    (b, w)>_R) of wild {
                        Data.Either.Left x2
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (a, w)
                              x2)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors (a, w)>_R))
                        Data.Either.Right y
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (a, w)
                              (x, case y of wild1 { (,) a1 w1 -> w1 }))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors (a, w)>_R)) })
                       `cast`
                     (<Control.Monad.Trans.Except.ExceptT
                         Language.PureScript.Errors.MultipleErrors
                         Data.Functor.Identity.Identity
                         (b, w)>_R
                      ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <Language.PureScript.Errors.MultipleErrors>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <(a, w)>_N))) -}
9762f192ff12e21991ac4abc1214433a
  $s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ a
                   @ w
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ b
                   @ w
                   (\ (ds1 :: Data.Either.Either
                                Language.PureScript.Errors.MultipleErrors (a, w)) ->
                    case ds1 of wild {
                      Data.Either.Left x
                      -> Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ (b, w)
                           x
                      Data.Either.Right y
                      -> Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ (b, w)
                           (f (case y of wild1 { (,) a1 w1 -> a1 }),
                            case y of wild1 { (,) a1 w1 -> w1 }) })
                     `cast`
                   ((Sym (Data.Functor.Identity.N:Identity[0]
                              <Data.Either.Either
                                 Language.PureScript.Errors.MultipleErrors
                                 (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <(a, w)>_N))
                    ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     (b, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <(b, w)>_N))) -}
5b233e837579c6d1c3ed4d40efacd3bd
  $s$fApplicativeStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.Except
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right x
                   -> case (k `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N)
                              (case x of wild1 { (,) a1 w2 ->
                               case a1 of wild2 { (,) a2 s' -> s' } }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <(b, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((b, s),
                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           ((b,
                                                                                                             s),
                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N)))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N))) } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.Except
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
15e9e219e8a9a341f0021b8da45ddeae
  $s$fApplicativeStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.Except
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Trans.Writer.Lazy.WriterT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Trans.Except.Except
                   Language.PureScript.Errors.MultipleErrors))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right x
                   -> let {
                        ds :: (a, s) = case x of wild1 { (,) a1 w2 -> a1 }
                      } in
                      case ((k (case ds of wild1 { (,) a1 s' -> a1 }))
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N)
                              (case ds of wild1 { (,) a1 s' -> s' }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <(b, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((b, s),
                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           ((b,
                                                                                                             s),
                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N)))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N))) } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.Except
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
7746b59f09e2e21364a1ace32a372594
  $s$fApplicativeStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           ((a, s), Language.PureScript.Errors.MultipleErrors)))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R (<s>_R
                       ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Language.PureScript.Errors.MultipleErrors>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <((a, s),
                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                 <(a,
                                                                                                   s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <s>_N
                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                      <a>_N)) -}
cea349e5507ab8f1279078659c1d9dfe
  $s$fApplicativeStateT_$s$fMonadSupplyT ::
    GHC.Base.Monad
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeSupplyT
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                         Language.PureScript.Errors.MultipleErrors
                                                                         (Control.Monad.Trans.Except.Except
                                                                            Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((eta, eta1),
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
a5b3a4b97326c4137b7d036594b1493b
  $s$fApplicativeStateT_$s$fMonadWriterT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>=
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>
                  (\ @ a (eta :: a) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (a, Language.PureScript.Errors.MultipleErrors)
                     (eta,
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (a,
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <a>_N)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$cfail -}
74e42b57ff5973c24082d4c538e227c4
  $s$fApplicativeStateT_$s$fMonadWriterT_$c>> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a)
                   (k :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a,
                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                              <Data.Either.Either
                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                 (a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (b, Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (b,
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(b,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N))
                   Data.Either.Right x
                   -> case k `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(b,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (b,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         Language.PureScript.Errors.MultipleErrors
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            Data.Functor.Identity.Identity)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
44ead5b76727ae1743267c68fd1348f1
  $s$fApplicativeStateT_$s$fMonadWriterT_$c>>= ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> (a
        -> Control.Monad.Trans.Writer.Lazy.WriterT
             Language.PureScript.Errors.MultipleErrors
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                Data.Functor.Identity.Identity)
             b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity)
                              b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a,
                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                              <Data.Either.Either
                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                 (a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (b, Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (b,
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(b,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N))
                   Data.Either.Right x
                   -> case (k (case x of wild1 { (,) a1 w2 -> a1 }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(b,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (b,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            b>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
cc4f908f5b015ff5a07f2550eb2646c7
  $s$fApplicativeStateT_$s$fMonadWriterT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, Strictness: <B,U>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ a (msg :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           (a, Language.PureScript.Errors.MultipleErrors)))
                   msg)
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Data.Functor.Identity.Identity>_R
                               <(a,
                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                              Data.Functor.Identity.Identity>_R
                                                                                           <a>_N)) -}
d40497021332c203117b544fbd5cd47a
  $s$fApplicativeWriterT_$c<* ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity)
                             a) ->
                 Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                   @ b
                   @ a
                   (case eta
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <Language.PureScript.Errors.MultipleErrors>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <(a,
                                             Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                 <Data.Either.Either
                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                    (a,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                            x)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a,
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(b
                                                                                                    -> a,
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <b
                                                                                                                                                               -> a>_N)))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                            (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                               @ a
                               @ Language.PureScript.Errors.MultipleErrors
                               @ b
                               y))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a,
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(b
                                                                                                    -> a,
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <b
                                                                                                                                                               -> a>_N))) })) -}
bf89fc9d1c8046b773708d21e8fb594a
  $s$fFunctorWriterT_$c<$ ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ w @ a @ b (x :: a) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ b
                   @ w
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ a
                   @ w
                   (\ (x1 :: Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity
                               (b, w)) ->
                    case x1
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Data.Functor.Identity.Identity>_R
                              <(b, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Language.PureScript.Errors.MultipleErrors
                                                  (b, w)>_R) of wild {
                      Data.Either.Left x2
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (a, w)
                            x2)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors (a, w)>_R))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (a, w)
                            (x, case y of wild1 { (,) a1 w1 -> w1 }))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors (a, w)>_R)) })
                     `cast`
                   (<Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity
                       (b, w)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <(a, w)>_N))) -}
400474bd3b0a2734b2d7c01b3d387afc
  $s$fMonadErroreStateT0 ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ @ a
                     (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Left
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((a, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     eta)
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                (((a, s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <(((a,
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <((a,
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <(a,
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <a>_N))
                  (\ @ a
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s
                               (Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors)))
                               a)
                     (eta1 :: Language.PureScript.Errors.MultipleErrors
                              -> Control.Monad.Trans.State.Lazy.StateT
                                   s
                                   (Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors)))
                                   a)
                     (eta2 :: s) ->
                   let {
                     eta4 :: Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               (a, s)
                     = eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <a>_N)
                         eta2
                   } in
                   (\ (eta5 :: GHC.Integer.Type.Integer) ->
                    case (eta4
                            `cast`
                          (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                Language.PureScript.Errors.MultipleErrors
                                                                (Control.Monad.Trans.Except.Except
                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                   s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                               <(a,
                                                                                                                                 s)>_N)
                            eta5)
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <((a, s),
                                GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                    <Data.Functor.Identity.Identity>_R
                                                                    <(((a, s),
                                                                       GHC.Integer.Type.Integer),
                                                                      Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                          <Data.Either.Either
                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                             (((a,
                                                                                                                                s),
                                                                                                                               GHC.Integer.Type.Integer),
                                                                                                                              Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left l
                      -> ((eta1 l)
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)
                            eta2)
                           `cast`
                         (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                               Language.PureScript.Errors.MultipleErrors
                                                               (Control.Monad.Trans.Except.Except
                                                                  Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                  s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                              <GHC.Integer.Type.Integer>_N
                                                                                                                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 (Control.Monad.Trans.Except.Except
                                                                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                              <(a,
                                                                                                                                s)>_N)
                           eta5
                      Data.Either.Right r
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            r)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) })
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <GHC.Integer.Type.Integer>_N
                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors)>_R
                             <(a,
                               s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                   (Control.Monad.Trans.Except.Except
                                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                      s)>_N))
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R <Language.PureScript.Errors.MultipleErrors
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Supply.SupplyT
                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)))
                              a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
9c9f90b56b26be953b5243b6936bfbf4
  $s$fMonadErroreStateT0_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>=
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>
                     @ s)
                  (\ @ a (eta :: a) (eta1 :: s) ->
                   let {
                     eta2 :: (a, s) = (eta, eta1)
                   } in
                   (\ (eta3 :: GHC.Integer.Type.Integer) ->
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ (((a, s), GHC.Integer.Type.Integer),
                         Language.PureScript.Errors.MultipleErrors)
                      ((eta2, eta3),
                       (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                     `cast`
                   ((<GHC.Integer.Type.Integer>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                            <(a,
                                                                                                                                                                                                              s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                     s)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail
                     @ s) -}
cba592d1046a3317763ee737d84c3d4f
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       case ((k `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' ->
                                 case a1 of wild2 { (,) a2 s'1 -> s'1 } }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
a04883a02e586549812e8dde7d531cdb
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Supply.SupplyT
                (Control.Monad.Trans.Writer.Lazy.WriterT
                   Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Trans.Except.Except
                      Language.PureScript.Errors.MultipleErrors)))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Supply.SupplyT
                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)))
                              b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       let {
                         ds1 :: (a, s) = case ds of wild1 { (,) a1 s' -> a1 }
                       } in
                       case (((k (case ds1 of wild1 { (,) a1 s' -> a1 }))
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds1 of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
5897144e524e705593787f1a47af7679
  $s$fMonadErroreStateT0_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 3, Strictness: <B,U><B,A><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s
                   @ a
                   (str :: GHC.Base.String)
                   (ds :: s)
                   (ds1 :: GHC.Integer.Type.Integer) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           (((a, s), GHC.Integer.Type.Integer),
                            Language.PureScript.Errors.MultipleErrors)))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R (<s>_R
                       ->_R (<GHC.Integer.Type.Integer>_R
                             ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <Language.PureScript.Errors.MultipleErrors>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <(((a, s), GHC.Integer.Type.Integer),
                                             Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Control.Monad.Trans.Except.ExceptT
                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                          Data.Functor.Identity.Identity>_R
                                                                                                       <((a,
                                                                                                          s),
                                                                                                         GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                                                                                    <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                    <(a,
                                                                                                                                                      s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                             s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                <s>_N
                                                                                                                                                                                                                                                                                <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                <a>_N)) -}
4aea3d2bb04871f9554419377759ab6a
  $s$fMonadStatesStateT0 ::
    Control.Monad.State.Class.MonadState
      s
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ s
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ (x :: s) ->
                   let {
                     eta :: (s, s) = (x, x)
                   } in
                   (\ (eta1 :: GHC.Integer.Type.Integer) ->
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ (((s, s), GHC.Integer.Type.Integer),
                         Language.PureScript.Errors.MultipleErrors)
                      ((eta, eta1),
                       (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                     `cast`
                   ((<GHC.Integer.Type.Integer>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((s, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((s,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((s,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                            <(s,
                                                                                                                                                                                                              s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N <(s,
                                                                                                                                                                                                                                                                                                                     s)>_N)))
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <s>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sput
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sstate
                     @ s) -}
27a19595ba0ba3c6d9fd1d13b0b11c16
  $s$fMonadStatesStateT0_$sput ::
    s
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         ()
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s (s1 :: s) (x :: s) ->
                 let {
                   eta :: ((), s) = (GHC.Tuple.(), s1)
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ ((((), s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    ((((), s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <((((),
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <(((),
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <((),
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <((),
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N).
                 <s>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <()>_N)) -}
0bdc04e8c980657ddadc11ceb6ae1731
  $s$fMonadStatesStateT0_$sstate ::
    (s -> (a, s))
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (f :: s -> (a, s)) (x :: s) ->
                 let {
                   eta :: (a, s) = f x
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ (((a, s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <(a,
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <s -> (a, s)>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)) -}
0c78d8743bbefa1ae05ff794e4f4e0c5
  $s$fMonadSupplyStateT ::
    Control.Monad.Supply.Class.MonadSupply
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ (eta :: s) (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((GHC.Integer.Type.Integer, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((s1, eta),
                       GHC.Integer.Type.plusInteger
                         s1
                         Control.Monad.Supply.Class.$fMonadSupplySupplyT2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          n))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  ((<s>_R
                    ->_R (<GHC.Integer.Type.Integer>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           (((GHC.Integer.Type.Integer, s),
                                             GHC.Integer.Type.Integer),
                                            Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Data.Functor.Identity.Identity>_R
                                                                                                       <(((GHC.Integer.Type.Integer,
                                                                                                           s),
                                                                                                          GHC.Integer.Type.Integer),
                                                                                                         Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                      Data.Functor.Identity.Identity>_R
                                                                                                                                                                   <((GHC.Integer.Type.Integer,
                                                                                                                                                                      s),
                                                                                                                                                                     GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                 <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                   s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_N <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                                                                                                                          s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                             <s>_N
                                                                                                                                                                                                                                                                                                                                             <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                             <GHC.Integer.Type.Integer>_N))
                  (\ (eta :: s) (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((GHC.Integer.Type.Integer, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((s1, eta), s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          n))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  ((<s>_R
                    ->_R (<GHC.Integer.Type.Integer>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           (((GHC.Integer.Type.Integer, s),
                                             GHC.Integer.Type.Integer),
                                            Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Data.Functor.Identity.Identity>_R
                                                                                                       <(((GHC.Integer.Type.Integer,
                                                                                                           s),
                                                                                                          GHC.Integer.Type.Integer),
                                                                                                         Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                      Data.Functor.Identity.Identity>_R
                                                                                                                                                                   <((GHC.Integer.Type.Integer,
                                                                                                                                                                      s),
                                                                                                                                                                     GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                 <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                   s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_N <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                                                                                                                          s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                             <s>_N
                                                                                                                                                                                                                                                                                                                                             <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                             <GHC.Integer.Type.Integer>_N)) -}
04b0715cd506797cc71df298beb9aafc
  $s$fMonadWriterSupplyT ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT
                  (\ @ a
                     (eta :: (a, Language.PureScript.Errors.MultipleErrors))
                     (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((case eta of wild { (,) a1 w2 -> a1 }, s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          case eta of wild { (,) a1 w2 ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((GHC.Tuple.(), s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            eta `cast` (Language.PureScript.Errors.N:MultipleErrors[0])))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          (((), GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(((),
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <((),
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <()>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <()>_N))
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <(a,
                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                 -> Language.PureScript.Errors.MultipleErrors)>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
c283c9f03bc694b0ddeaf92d2189de3d
  $s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0 ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
                  (\ @ a ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (a, Language.PureScript.Errors.MultipleErrors))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (a,
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <a>_N)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$stell
                     @ Language.PureScript.Errors.MultipleErrors)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$slisten
                     @ Language.PureScript.Errors.MultipleErrors)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$spass
                     @ Language.PureScript.Errors.MultipleErrors) -}
19af061661c25caca4c999eebf8b8e8f
  $s$fMonadWriterSupplyT_$slisten ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      w
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         (a, w)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w
                   @ a
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            w
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                         <Data.Either.Either
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (a, w)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((a, w), w)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((a, w), w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <((a, w), w)>_N))
                   Data.Either.Right x
                   -> let {
                        w1 :: w = case x of wild1 { (,) a1 w2 -> w2 }
                      } in
                      (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((a, w), w)
                         ((case x of wild1 { (,) a1 w2 -> a1 }, w1), w1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((a, w), w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <((a, w), w)>_N)) })
                  `cast`
                (forall (w :: <*>_N) (a :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    w
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <w>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <(a, w)>_N)) -}
ba9b4ac97b434df5c354a3e87676bf46
  $s$fMonadWriterSupplyT_$spass ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      w
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      (a, w -> w)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w
                   @ a
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            w
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            (a, w -> w)) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, w -> w)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((a, w -> w),
                                                    w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                <Data.Either.Either
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   ((a, w -> w), w)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (a, w)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(a, w)>_N))
                   Data.Either.Right x
                   -> let {
                        ds1 :: (a, w -> w, w)
                        = case x of wild1 { (,) ds2 w1 ->
                          case ds2 of wild2 { (,) a1 f -> (a1, f, w1) } }
                      } in
                      (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (a, w)
                         (case ds1 of ds2 { (,,) a1 f w1 -> a1 },
                          case ds1 of ds2 { (,,) a1 f w1 -> f w1 }))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(a, w)>_N)) })
                  `cast`
                (forall (w :: <*>_N) (a :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    w
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    (a, w -> w)>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <w>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <a>_N)) -}
11a362800f068d54bbfb2b987d5c01e0
  $s$fMonadWriterSupplyT_$stell ::
    w
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         ()
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w (w1 :: w) ->
                 Data.Either.Right
                   @ Language.PureScript.Errors.MultipleErrors
                   @ ((), w)
                   (GHC.Tuple.(), w1))
                  `cast`
                (forall (w :: <*>_N).
                 <w>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  Language.PureScript.Errors.MultipleErrors
                                  ((), w)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <((),
                                                            w)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                              <w>_N
                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 Data.Functor.Identity.Identity>_R
                                                                              <()>_N))) -}
2fa7e2b0b5fe359ce33fca9182bec1f2
  $s$fMonadWriterwStateT0 ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ @ a
                     (eta :: (a, Language.PureScript.Errors.MultipleErrors))
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((a, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((case eta of wild { (,) a1 w2 -> a1 }, s1), s2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          case eta of wild { (,) a1 w2 ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                (((a, s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <(((a,
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <((a,
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <(a,
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <a>_N))
                  (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((((), s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((GHC.Tuple.(), s1), s2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            eta `cast` (Language.PureScript.Errors.N:MultipleErrors[0])))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                ((((), s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <((((),
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <(((),
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <((),
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <((),
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <()>_N))
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <(a, Language.PureScript.Errors.MultipleErrors)>_N))
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      (a,
                       Language.PureScript.Errors.MultipleErrors
                       -> Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
9c1ca8898768f713816f116e23e6e94a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.TypeSearch.$trModule3
                   Language.PureScript.TypeChecker.TypeSearch.$trModule1) -}
844a9cf4f211da1b8511530af0eb515b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.TypeSearch.$trModule2) -}
5586e9829b367bc9411e619db6f0bb3c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.TypeSearch"#) -}
894bb6159c27183a798ca8539b8f875d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.TypeSearch.$trModule4) -}
b2ddb6aeacc026b81d153376d2fcb912
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
1c9e21ea68ac31f3af9a69ebddc9dd16
  $wtypeSearch ::
    GHC.Base.Maybe
      [(Language.PureScript.Names.Ident,
        Language.PureScript.TypeChecker.Entailment.InstanceContext,
        Language.PureScript.Types.Constraint)]
    -> Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Types.Type
    -> (# [(Language.PureScript.Names.Qualified
              Data.Text.Internal.Text,
            Language.PureScript.Types.Type)],
          GHC.Base.Maybe
            [(Language.PureScript.Label.Label,
              Language.PureScript.Types.Type)] #)
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U)><L,U(A,U,U,U,U,U,U,U)><L,U>,
     Inline: [0] -}
745853681efe5bdc5b3138ac87b4ee23
  typeSearch ::
    GHC.Base.Maybe
      [(Language.PureScript.Names.Ident,
        Language.PureScript.TypeChecker.Entailment.InstanceContext,
        Language.PureScript.Types.Constraint)]
    -> Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Types.Type
    -> ([(Language.PureScript.Names.Qualified Data.Text.Internal.Text,
          Language.PureScript.Types.Type)],
        GHC.Base.Maybe
          [(Language.PureScript.Label.Label,
            Language.PureScript.Types.Type)])
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U)><L,U(A,U,U,U,U,U,U,U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Base.Maybe
                           [(Language.PureScript.Names.Ident,
                             Language.PureScript.TypeChecker.Entailment.InstanceContext,
                             Language.PureScript.Types.Constraint)])
                   (w1 :: Language.PureScript.Environment.Environment)
                   (w2 :: Language.PureScript.TypeChecker.Monad.CheckState)
                   (w3 :: Language.PureScript.Types.Type) ->
                 case Language.PureScript.TypeChecker.TypeSearch.$wtypeSearch
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT @ Identity _" [orphan] forall @ e
                                                                                                    (v1 :: GHC.Base.Monad
                                                                                                             Data.Functor.Identity.Identity)
                                                                                                    (v :: GHC.Base.Functor
                                                                                                            Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ Data.Functor.Identity.Identity
                                                  @ e
                                                  v
                                                  v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$c*> @ Identity _" [orphan] forall @ e
                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                       Data.Functor.Identity.Identity)
                                                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                                                         Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$c<* @ Identity _" [orphan] forall @ e
                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                       Data.Functor.Identity.Identity)
                                                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                                                         Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c<* @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$c<*
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$cpure @ Identity _" [orphan] forall @ e
                                                                                                           ($dMonad :: GHC.Base.Monad
                                                                                                                         Data.Functor.Identity.Identity)
                                                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                                                           Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ Data.Functor.Identity.Identity
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ (Control.Monad.Supply.SupplyT
                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors)))
                                                     @ s
                                                     v
                                                     v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT1 @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT1 @ (Control.Monad.Supply.SupplyT
                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)))
                                                      @ s
                                                      $dFunctor
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT1
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$c*> @ (SupplyT
                                                                              (WriterT
                                                                                 MultipleErrors
                                                                                 (Except
                                                                                    MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*> @ (Control.Monad.Supply.SupplyT
                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                  Language.PureScript.Errors.MultipleErrors
                                                                  (Control.Monad.Trans.Except.Except
                                                                     Language.PureScript.Errors.MultipleErrors)))
                                                          @ s
                                                          $dFunctor
                                                          $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$c<*> @ (SupplyT
                                                                               (WriterT
                                                                                  MultipleErrors
                                                                                  (Except
                                                                                     MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ (Control.Monad.Supply.SupplyT
                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)))
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$cpure @ (SupplyT
                                                                                (WriterT
                                                                                   MultipleErrors
                                                                                   (Except
                                                                                      MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ (Control.Monad.Supply.SupplyT
                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    (Control.Monad.Trans.Except.Except
                                                                       Language.PureScript.Errors.MultipleErrors)))
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeSupplyT @ (WriterT
                                                                          MultipleErrors
                                                                          (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fApplicativeSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                 Language.PureScript.Errors.MultipleErrors
                                                 (Control.Monad.Trans.Except.Except
                                                    Language.PureScript.Errors.MultipleErrors))
                                            v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT @ MultipleErrors @ (ExceptT
                                                                                           MultipleErrors
                                                                                           Identity)" [orphan] forall (v1 :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                              Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                  (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT @ Language.PureScript.Errors.MultipleErrors
                                                       @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            Data.Functor.Identity.Identity)
                                                       v
                                                       v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$c<* @ MultipleErrors @ (ExceptT
                                                                                                MultipleErrors
                                                                                                Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                        Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                 ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<* @ Language.PureScript.Errors.MultipleErrors
                                                            @ (Control.Monad.Trans.Except.ExceptT
                                                                 Language.PureScript.Errors.MultipleErrors
                                                                 Data.Functor.Identity.Identity)
                                                            $dMonoid
                                                            $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeWriterT_$c<*
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$c<*> @ MultipleErrors @ (ExceptT
                                                                                                 MultipleErrors
                                                                                                 Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                           Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                    ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<*> @ Language.PureScript.Errors.MultipleErrors
                                                             @ (Control.Monad.Trans.Except.ExceptT
                                                                  Language.PureScript.Errors.MultipleErrors
                                                                  Data.Functor.Identity.Identity)
                                                             $dMonoid
                                                             $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$cpure @ MultipleErrors @ (ExceptT
                                                                                                  MultipleErrors
                                                                                                  Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                              Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                       ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cpure @ Language.PureScript.Errors.MultipleErrors
                                                              @ (Control.Monad.Trans.Except.ExceptT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   Data.Functor.Identity.Identity)
                                                              $dMonoid
                                                              $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorExceptT @ Identity _" [orphan] forall @ e
                                                                                                (v :: GHC.Base.Functor
                                                                                                        Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fFunctorExceptT @ Data.Functor.Identity.Identity
                                              @ e
                                              v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorStateT @ (SupplyT
                                                                     (WriterT
                                                                        MultipleErrors
                                                                        (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                      (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorStateT_$cfmap @ (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors))
                                                        @ s
                                                        $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorSupplyT @ (WriterT
                                                                      MultipleErrors
                                                                      (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fFunctorSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                             Language.PureScript.Errors.MultipleErrors
                                             (Control.Monad.Trans.Except.Except
                                                Language.PureScript.Errors.MultipleErrors))
                                        v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT @ (ExceptT
                                                                      MultipleErrors Identity) _" [orphan] forall @ w
                                                                                                                                                                                               (v :: GHC.Base.Functor
                                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                          Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        Data.Functor.Identity.Identity)
                                                   @ w
                                                   v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT_$c<$ @ (ExceptT
                                                                           MultipleErrors
                                                                           Identity) _" [orphan] forall @ w
                                                                                                                                                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                       Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             Data.Functor.Identity.Identity)
                                                        @ w
                                                        $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fFunctorWriterT_$c<$
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT_$cfmap @ (ExceptT
                                                                             MultipleErrors
                                                                             Identity) _" [orphan] forall @ w
                                                                                                                                                                                                                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                             Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                               Language.PureScript.Errors.MultipleErrors
                                                               Data.Functor.Identity.Identity)
                                                          @ w
                                                          $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadErroreStateT0 @ MultipleErrors @ (SupplyT
                                                                                           (WriterT
                                                                                              MultipleErrors
                                                                                              (Except
                                                                                                 MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (v :: Control.Monad.Error.Class.MonadError
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Error.Class.$fMonadErroreStateT0 @ Language.PureScript.Errors.MultipleErrors
                                                 @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT @ (SupplyT
                                                                   (WriterT
                                                                      MultipleErrors
                                                                      (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                              (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ (Control.Monad.Supply.SupplyT
                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Trans.Except.Except
                                                          Language.PureScript.Errors.MultipleErrors)))
                                               @ s
                                               v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>> @ (SupplyT
                                                                        (WriterT
                                                                           MultipleErrors
                                                                           (Except
                                                                              MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Supply.SupplyT
                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Trans.Except.Except
                                                               Language.PureScript.Errors.MultipleErrors)))
                                                    @ s
                                                    $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>> @ (WriterT
                                                                        MultipleErrors
                                                                        (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors))
                                                    @ s
                                                    $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>>= @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Supply.SupplyT
                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors)))
                                                     @ s
                                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>=
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>>= @ (WriterT
                                                                         MultipleErrors
                                                                         (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                             ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                          Language.PureScript.Errors.MultipleErrors
                                                          (Control.Monad.Trans.Except.Except
                                                             Language.PureScript.Errors.MultipleErrors))
                                                     @ s
                                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>=
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$cfail @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Supply.SupplyT
                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)))
                                                      @ s
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$cfail @ (WriterT
                                                                          MultipleErrors
                                                                          (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           (Control.Monad.Trans.Except.Except
                                                              Language.PureScript.Errors.MultipleErrors))
                                                      @ s
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$cfail
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStatesStateT0 @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.State.Class.$fMonadStatesStateT0 @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadSupplyStateT @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v :: Control.Monad.Supply.Class.MonadSupply
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Supply.Class.$fMonadSupplyStateT @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadSupplyStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadSupplyT @ (WriterT
                                                                    MultipleErrors
                                                                    (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fMonadSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                           Language.PureScript.Errors.MultipleErrors
                                           (Control.Monad.Trans.Except.Except
                                              Language.PureScript.Errors.MultipleErrors))
                                      v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterSupplyT @ MultipleErrors @ (WriterT
                                                                                           MultipleErrors
                                                                                           (Except
                                                                                              MultipleErrors))" [orphan] forall (v :: Control.Monad.Writer.Class.MonadWriter
                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fMonadWriterSupplyT @ Language.PureScript.Errors.MultipleErrors
                                            @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                 Language.PureScript.Errors.MultipleErrors
                                                 (Control.Monad.Trans.Except.Except
                                                    Language.PureScript.Errors.MultipleErrors))
                                            v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT @ MultipleErrors @ (ExceptT
                                                                                     MultipleErrors
                                                                                     Identity)" [orphan] forall (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                            Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT @ Language.PureScript.Errors.MultipleErrors
                                                 @ (Control.Monad.Trans.Except.ExceptT
                                                      Language.PureScript.Errors.MultipleErrors
                                                      Data.Functor.Identity.Identity)
                                                 v
                                                 v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$c>> @ MultipleErrors @ (ExceptT
                                                                                          MultipleErrors
                                                                                          Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                               ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>> @ Language.PureScript.Errors.MultipleErrors
                                                      @ (Control.Monad.Trans.Except.ExceptT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           Data.Functor.Identity.Identity)
                                                      $dMonoid
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$c>>= @ MultipleErrors @ (ExceptT
                                                                                           MultipleErrors
                                                                                           Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                  ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>>= @ Language.PureScript.Errors.MultipleErrors
                                                       @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            Data.Functor.Identity.Identity)
                                                       $dMonoid
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>=
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$cfail @ MultipleErrors @ (ExceptT
                                                                                            MultipleErrors
                                                                                            Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                      Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                     ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$cfail @ Language.PureScript.Errors.MultipleErrors
                                                        @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             Data.Functor.Identity.Identity)
                                                        $dMonoid
                                                        $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$cfail
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterwStateT0 @ MultipleErrors @ (SupplyT
                                                                                            (WriterT
                                                                                               MultipleErrors
                                                                                               (Except
                                                                                                  MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (v :: Control.Monad.Writer.Class.MonadWriter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Writer.Class.$fMonadWriterwStateT0 @ Language.PureScript.Errors.MultipleErrors
                                                   @ (Control.Monad.Supply.SupplyT
                                                        (Control.Monad.Trans.Writer.Lazy.WriterT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           (Control.Monad.Trans.Except.Except
                                                              Language.PureScript.Errors.MultipleErrors)))
                                                   @ s
                                                   v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterwStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterwWriterT0 @ MultipleErrors @ (ExceptT
                                                                                             MultipleErrors
                                                                                             Identity)" [orphan] forall (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                    Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                        (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Writer.Class.$fMonadWriterwWriterT0 @ Language.PureScript.Errors.MultipleErrors
                                                    @ (Control.Monad.Trans.Except.ExceptT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         Data.Functor.Identity.Identity)
                                                    v
                                                    v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
"SPEC/Language.PureScript.TypeChecker.TypeSearch $w$c<*> @ Identity _" [orphan] [0] forall @ e
                                                                                           (w :: GHC.Base.Monad
                                                                                                   Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$w$c<*> @ Data.Functor.Identity.Identity
                                     @ e
                                     w
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$c<*>_$s$w$c<*>
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch listen @ (ExceptT
                                                            MultipleErrors Identity) _ _" [orphan] forall @ w
                                                                                                                                                                             @ a
                                                                                                                                                                             ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                              Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.listen @ (Control.Monad.Trans.Except.ExceptT
                                              Language.PureScript.Errors.MultipleErrors
                                              Data.Functor.Identity.Identity)
                                         @ w
                                         @ a
                                         $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$slisten
      @ w
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch pass @ (ExceptT
                                                          MultipleErrors Identity) _ _" [orphan] forall @ w
                                                                                                                                                                         @ a
                                                                                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                          Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.pass @ (Control.Monad.Trans.Except.ExceptT
                                            Language.PureScript.Errors.MultipleErrors
                                            Data.Functor.Identity.Identity)
                                       @ w
                                       @ a
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$spass
      @ w
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch put @ (SupplyT
                                                         (WriterT
                                                            MultipleErrors
                                                            (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                      ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.put @ (Control.Monad.Supply.SupplyT
                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                             Language.PureScript.Errors.MultipleErrors
                                             (Control.Monad.Trans.Except.Except
                                                Language.PureScript.Errors.MultipleErrors)))
                                     @ s
                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sput
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch state @ (SupplyT
                                                           (WriterT
                                                              MultipleErrors
                                                              (Except MultipleErrors))) _ _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                @ a
                                                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.state @ (Control.Monad.Supply.SupplyT
                                            (Control.Monad.Trans.Writer.Lazy.WriterT
                                               Language.PureScript.Errors.MultipleErrors
                                               (Control.Monad.Trans.Except.Except
                                                  Language.PureScript.Errors.MultipleErrors)))
                                       @ s
                                       @ a
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sstate
      @ s
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch tell @ (ExceptT
                                                          MultipleErrors Identity) _" [orphan] forall @ w
                                                                                                                                                                       ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                        Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.tell @ (Control.Monad.Trans.Except.ExceptT
                                            Language.PureScript.Errors.MultipleErrors
                                            Data.Functor.Identity.Identity)
                                       @ w
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$stell
      @ w
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

