
==================== FINAL INTERFACE ====================
2019-01-24 14:15:39.688155 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeChecker.TypeSearch 8043
  interface hash: c0f532ccbbf16cf7ffa8aedaf83c9879
  ABI hash: dfdef2d27a65b14ffb5af177be7da1d4
  export-list hash: c1dfe9f5b7959def7547769a1d3224ea
  orphan hash: d84f0045a0df770c54e85beb408a0986
  flag hash: 16532b0f9807287e7d68a156c2412cf2
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.TypeSearch.typeSearch
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeChecker.Entailment
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeChecker.Subsumption
                     Language.PureScript.TypeChecker.Synonyms
                     Language.PureScript.TypeChecker.Unify
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0 boxes-0.1.5
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.5.11.0
                      data-ordlist-0.4.7.0 deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 microlens-0.4.9.1 microlens-ghc-0.4.9
                      microlens-mtl-0.1.11.1 microlens-platform-0.3.10
                      microlens-th-0.4.2.1 mtl-2.2.2 parsec-3.1.13.0 pattern-arrows-0.0.2
                      pretty-1.1.3.6 primitive-0.6.3.0 protolude-0.2.2 random-1.1
                      scientific-0.3.6.2 sourcemap-0.1.6 split-0.2.3.3 stm-2.4.5.0
                      syb-0.7 tagged-0.8.5 template-haskell-2.13.0.0 text-1.2.3.0
                      th-abstraction-0.2.8.0 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.5.0 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Bifunctor a977586bad544f929bb5bc7f139aaa1c
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  mtl-2.2.2:Control.Monad.Writer b86905dc6b5d4d3a09dfa93d3ac3bb98
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  Control.Monad.Supply 95e15bedaf79f313b09bccb6a9122994
  exports: 15e005f374fb6992e116699e0e7b7c5f
  SupplyT bb1f4fa577226d92c4e387a7717c5df6
  evalSupplyT 324b9183ea553a363af9ce46190d7c70
import  -/  Language.PureScript.AST e89b59f8e201961eafd3ff905a683659
  exports: be73d3bb7d4ebe5df082453f6d572075
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  Expr e92f6ee78a22c0eadc3566d7d1f48d5b
  Var 5fd1e80d993ab2f76a4e002bbbfc9990
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  nullSourceSpan d3ce9e45794cd4f5ddfad4b02b318f51
import  -/  Language.PureScript.AST.Traversals f5adaf844c5e9d0f0678a8b574a32aa6
  overTypes c5ba43021920ffb02d62737e1c4527b2
import  -/  Language.PureScript.Environment 467b25d81b890e1aaabe28d0f09d192d
  exports: a0cb6cb8c78c56365f58c9f88d1fe000
  Environment 7eb61fe78108d98d82e39145869b2402
  dataConstructors 7eb61fe78108d98d82e39145869b2402
  names 7eb61fe78108d98d82e39145869b2402
  tyFunction 72bada10fd7f408ce623a31c14e8cefb
  tyRecord 50710499a0d6346d3284449c5e15992d
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  exports: 8e61484c4664eceb943d9fc4820c721b
  MultipleErrors e1ef6a17348ccfe3ef65185d3c5f9026
import  -/  Language.PureScript.Label 366bbe6039761c79dbc09aaf87b5753e
  exports: 0a72b1b943ee66379d53382d0212ef7e
  Label 1525a534169f6ccc5a25699c70351352
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  exports: ad7ae34f85124c68e8ba1c90fb2e732f
  Ident 71f167265716f619863a793fa311e198
  Ident bad3562aa6138b6192713ac281080869
  Qualified b6e1bc9e7244a41d3c6149c9b5c2d6d8
  Qualified 1b2ddf0c04464d2fa2588925f10c1966
  runIdent f4727e6f001b3b7d933fd4e8122af572
  runProperName a7268334e0b909381550b9329cb80fcc
import  -/  Language.PureScript.Pretty.Types 1303ea05006a6ec61edb2f109218248a
  exports: f7263952ce0ec10cb0b028bbb35f097c
  prettyPrintLabel 11a28b259161844f1d8d17a50499925b
import  -/  Language.PureScript.TypeChecker.Entailment cf121bfd8417e41be69559141345422d
  exports: 82bae92274a2ba154fef9ef60f091144
  InstanceContext c4475a18c9787347337fbabbb7f9d9d2
  SolverOptions 5f6bd14b61d08eeb2fe5745b733eab63
  entails e1f201eb9d51a7359d5d2ac38c1eaa0f
  replaceTypeClassDictionaries 5a61c57edd6d00dad5d55b214e946b57
  solverDeferErrors 3a0adde338d0fc50c3fc9ced661cc57b
  solverShouldGeneralize 3a0adde338d0fc50c3fc9ced661cc57b
import  -/  Language.PureScript.TypeChecker.Monad 5c6d6cca9d9f5acb98ab527615b54d6d
  exports: 64079f93a7ca5d81f53055abc7f8ac53
  CheckState 9cc3cef00c43c0c2ac24a31e9b521e29
  checkEnv 9cc3cef00c43c0c2ac24a31e9b521e29
  checkSubstitution 9cc3cef00c43c0c2ac24a31e9b521e29
  runCheck' a85aa9a51f9f809c972072c9aa714394
import  -/  Language.PureScript.TypeChecker.Skolems d6f507247d13250d325e185be25fccdf
  exports: 301c96fa595b923bfcf06694e88d029f
  introduceSkolemScope cbd26872f4b44871d4fb8d52b6845a3d
import  -/  Language.PureScript.TypeChecker.Subsumption 2763e6a22d4c985afcfbfcfd12ea7e99
  exports: c2176d67b40e83c01935fbebc66fe7a2
  subsumes 54cca14cc8968576e00d5e38068baa54
import  -/  Language.PureScript.TypeChecker.Synonyms 9fc45204d5072944969c53bc432a94f7
  exports: 7d14e10157c623eaf1b349bf4fa32925
  replaceAllTypeSynonyms de486072b313a4c7c1540540e0726c4f
import  -/  Language.PureScript.TypeChecker.Unify f1e03e30856471f44252b03f30788ea2
  exports: 85c9b2e7abdd78234543aea834d2a6f2
  freshType 527baf8b1affd32c2669a112140804d8
  replaceTypeWildcards e6f96d995c50d5ea91c10ec9b8abc834
  substituteType 84a2cb6a429d91c98237ddbf8b2c5705
import  -/  Language.PureScript.Types 80a51f62cb3e6c71f024289b88f07b7f
  exports: 229bb7528146da886cffbefad5822e19
  RowListItem 0e3231b388d844db12bae63a4b5c2cc0
  SourceConstraint b73f205dd83ce498c3119d8c9316f0c6
  SourceType 0ac818517c14fedd280ef5885ae0cdc3
  mapConstraintArgs 271f74f3dadd31332938099ff1d312ff
  rowToList 7eaee27c2477428659ea7da98530a691
  srcTypeApp 12cd55eb1b1b79c16fa2d346fb7f9cdb
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Writer.Lazy 932eb57f5933138df24d28686f218b40
83ce9f68a45d44e2beb574cccfcdde98
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fFunctorExceptT
                     @ e)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ c
                     (Data.Either.$fApplicativeEither_$cfmap
                        @ e
                        @ a
                        @ (b -> c)
                        f1
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> c)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> c>_N)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
                     @ e)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.Except.ExceptT
                             e Data.Functor.Identity.Identity a) ->
                   Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ b
                     @ a
                     (Control.Monad.Trans.Except.$fApplicativeExceptT1
                        @ a
                        @ b
                        @ e
                        x `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <e>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either e a>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                            <e>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <b -> a>_N))) -}
5f6f362c33ae436d5544330a083aa236
  $s$fApplicativeExceptT_$c<* ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ Data.Functor.Identity.Identity
                   @ e
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ b
                   @ a
                   (Control.Monad.Trans.Except.$fApplicativeExceptT1
                      @ a
                      @ b
                      @ e
                      x `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <Data.Either.Either
                                e (b -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <e>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <b -> a>_N))) -}
bf58691eee8d9ccde771aefd5afc3cb1
  $s$fApplicativeExceptT_$c<*>_$s$w$c<*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ e
                   @ a
                   @ b
                   (w1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity (a -> b))
                   (w2 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a) ->
                 case w1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e (a -> b)>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                      <e>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <b>_N))
                   Data.Either.Right k
                   -> case w2
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <e>_N
                                <Data.Functor.Identity.Identity>_R
                                <a>_N ; Data.Functor.Identity.N:Identity[0]
                                            <Data.Either.Either e a>_R) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left @ e @ b e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N))
                        Data.Either.Right x
                        -> (Data.Either.Right @ e @ b (k x))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        e b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <e>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <b>_N)) } }) -}
139b8405d1a882a93a99e708557cf648
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*> ::
    Control.Monad.Trans.Except.ExceptT
      e Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.Except.ExceptT
                           e Data.Functor.Identity.Identity b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either e a>_R) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left @ e @ b e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either e b>_R))
                   Data.Either.Right x
                   -> k `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <Data.Functor.Identity.Identity>_R <b>_N) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    e Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT
                         e Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
c958a4ed2e147edc1f1a5aba8da6203e
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                Data.Either.Right
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  e a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <e>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <a>_N)) -}
4fd5afc7bddc82829ff32b6772668773
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ Data.Functor.Identity.Identity
                     @ e
                     Data.Functor.Identity.$fFunctorIdentity) -}
73e70da889d589eaee450afffae5f2c7
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <c>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*>
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT1
                     @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
d42fece0330a3312411f178f6f06867e
  $s$fApplicativeStateT_$s$fApplicativeStateT1 ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> s
    -> Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ s
                   @ a
                   @ b
                   (x :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           a)
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             s
                             (Control.Monad.Supply.SupplyT
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors)))
                             b)
                   (eta1 :: s) ->
                 let {
                   m1 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = x `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       eta1
                 } in
                 (\ (s1 :: GHC.Integer.Type.Integer) ->
                  case (m1
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s1)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left x1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((a, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          x1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right y
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case y of wild1 { (,) a1 w1 -> a1 }
                       } in
                       let {
                         ds1 :: (a, s) = case ds of wild1 { (,) a1 s' -> a1 }
                       } in
                       case ((eta
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds1 of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((a, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((a, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((a,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((a,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> let {
                              ds2 :: ((b, s), GHC.Integer.Type.Integer)
                              = case x1 of wild2 { (,) a1 w2 -> a1 }
                            } in
                            (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((a, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (((case ds1 of wild2 { (,) a1 s' -> a1 },
                                  case ds2 of wild2 { (,) a1 s' ->
                                  case a1 of wild3 { (,) x2 s'' -> s'' } }),
                                 case ds2 of wild2 { (,) a1 s' -> s' }),
                                (GHC.Base.build
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case y of wild2 { (,) a1 w1 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      (case x1 of wild3 { (,) a2 w2 ->
                                       GHC.Base.foldr
                                         @ Language.PureScript.AST.Declarations.ErrorMessage
                                         @ b1
                                         c
                                         n
                                         w2
                                           `cast`
                                         (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                      w1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((a, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((a,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((a,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(a,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                    s)>_N)) -}
68c0abbf0eacaa58f8410842b9596131
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       case ((k `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' ->
                                 case a1 of wild2 { (,) a2 s'1 -> s'1 } }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
33b1825c6e60cae3f952eafc860d5bb1
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s
                             (Control.Monad.Supply.SupplyT
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors)))
                             a)
                   (s1 :: s) ->
                 let {
                   m1 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a -> b, s)
                   = ds
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a -> b>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m1
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a
                                                                                                                 -> b,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a
                                                                                                                               -> b,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a -> b, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a -> b, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a
                                                                                                                              -> b,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds2 :: ((a -> b, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       let {
                         ds3 :: (a -> b, s) = case ds2 of wild1 { (,) a1 s' -> a1 }
                       } in
                       case ((ds1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <a>_N)
                                (case ds3 of wild1 { (,) f s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(a,
                                                                                                                                    s)>_N)
                               (case ds2 of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((a, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((a, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((a,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> let {
                              ds4 :: ((a, s), GHC.Integer.Type.Integer)
                              = case x1 of wild2 { (,) a1 w2 -> a1 }
                            } in
                            let {
                              ds5 :: (a, s) = case ds4 of wild2 { (,) a1 s' -> a1 }
                            } in
                            (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (((case ds3 of wild2 { (,) f s' ->
                                  f (case ds5 of wild3 { (,) x2 s'' -> x2 }) },
                                  case ds5 of wild2 { (,) x2 s'' -> s'' }),
                                 case ds4 of wild2 { (,) a1 s' -> s' }),
                                (GHC.Base.build
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      (case x1 of wild3 { (,) a2 w1 ->
                                       GHC.Base.foldr
                                         @ Language.PureScript.AST.Declarations.ErrorMessage
                                         @ b1
                                         c
                                         n
                                         w1
                                           `cast`
                                         (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
660eadf8cf0e3fc7ec266aa00c0f19e5
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) (s1 :: s) ->
                 let {
                   eta :: (a, s) = (a1, s1)
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ (((a, s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <(a,
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)) -}
ae4d93c60f73e98255ec1e0956bac613
  $s$fApplicativeStateT_$s$fApplicativeSupplyT ::
    GHC.Base.Applicative
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((eta, eta1),
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (Control.Monad.Supply.$fApplicativeSupplyT4
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a
                                                                                                                -> b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     @ c
                     (eta :: a -> b -> c)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                a)
                     (eta2 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta3 :: GHC.Integer.Type.Integer) ->
                   Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
                        @ Language.PureScript.Errors.MultipleErrors)
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
                     @ a
                     @ b
                     @ c
                     eta
                     eta1
                     eta2
                     eta3)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <c>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <c>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((a, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((a,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left e1
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((b, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           e1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((b, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((b,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(b,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right x
                     -> case (eta1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <GHC.Integer.Type.Integer>_N
                                   <Control.Monad.Trans.Writer.Lazy.WriterT
                                      Language.PureScript.Errors.MultipleErrors
                                      (Control.Monad.Trans.Except.Except
                                         Language.PureScript.Errors.MultipleErrors)>_R
                                   <b>_N)
                                (case x of wild1 { (,) a1 w2 ->
                                 case a1 of wild2 { (,) a2 s' -> s' } }))
                               `cast`
                             (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Trans.Except.ExceptT
                                     Language.PureScript.Errors.MultipleErrors
                                     Data.Functor.Identity.Identity>_R
                                  <(b,
                                    GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                        <Data.Functor.Identity.Identity>_R
                                                                        <((b,
                                                                           GHC.Integer.Type.Integer),
                                                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                              <Data.Either.Either
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 ((b,
                                                                                                                                   GHC.Integer.Type.Integer),
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                          Data.Either.Left e1
                          -> (Data.Either.Left
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((b, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                e1)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((b, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((b,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(b,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N)))
                          Data.Either.Right x1
                          -> (Data.Either.Right
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((b, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                (case x1 of wild2 { (,) b1 w' -> b1 },
                                 (GHC.Base.augment
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    (\ @ b1
                                       (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                             -> b1 -> b1)[OneShot]
                                       (n :: b1)[OneShot] ->
                                     case x of wild2 { (,) a1 w2 ->
                                     GHC.Base.foldr
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       @ b1
                                       c
                                       n
                                       w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                    (case x1 of wild2 { (,) b1 w' ->
                                     w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                   `cast`
                                 (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((b, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((b,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(b,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               a)
                     (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                                GHC.Integer.Type.Integer
                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Trans.Except.Except
                                      Language.PureScript.Errors.MultipleErrors))
                                b)
                     (eta2 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(a,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((a, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((a,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left x
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           x)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right y
                     -> let {
                          ds :: (a, GHC.Integer.Type.Integer)
                          = case y of wild1 { (,) a1 w1 -> a1 }
                        } in
                        case (eta1
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <GHC.Integer.Type.Integer>_N
                                   <Control.Monad.Trans.Writer.Lazy.WriterT
                                      Language.PureScript.Errors.MultipleErrors
                                      (Control.Monad.Trans.Except.Except
                                         Language.PureScript.Errors.MultipleErrors)>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Trans.Except.ExceptT
                                     Language.PureScript.Errors.MultipleErrors
                                     Data.Functor.Identity.Identity>_R
                                  <(b,
                                    GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                        <Data.Functor.Identity.Identity>_R
                                                                        <((b,
                                                                           GHC.Integer.Type.Integer),
                                                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                              <Data.Either.Either
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 ((b,
                                                                                                                                   GHC.Integer.Type.Integer),
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                          Data.Either.Left e1
                          -> (Data.Either.Left
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((a, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                e1)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N)))
                          Data.Either.Right x
                          -> (Data.Either.Right
                                @ Language.PureScript.Errors.MultipleErrors
                                @ ((a, GHC.Integer.Type.Integer),
                                   Language.PureScript.Errors.MultipleErrors)
                                ((case ds of wild2 { (,) a1 s' -> a1 },
                                  case x of wild2 { (,) a1 w2 ->
                                  case a1 of wild3 { (,) x1 s'' -> s'' } }),
                                 (GHC.Base.build
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    (\ @ b1
                                       (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                             -> b1 -> b1)[OneShot]
                                       (n :: b1)[OneShot] ->
                                     case y of wild2 { (,) a1 w1 ->
                                     GHC.Base.foldr
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       @ b1
                                       c
                                       (case x of wild3 { (,) a2 w2 ->
                                        GHC.Base.foldr
                                          @ Language.PureScript.AST.Declarations.ErrorMessage
                                          @ b1
                                          c
                                          n
                                          w2
                                            `cast`
                                          (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                       w1
                                         `cast`
                                       (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                   `cast`
                                 (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
dddc5eff9af32fed63c4e4ffcb6ad999
  $s$fApplicativeStateT_$s$fApplicativeWriterT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
                     @ Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cliftA2
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     Language.PureScript.Errors.$fMonoidMultipleErrors
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
                        @ Language.PureScript.Errors.MultipleErrors))
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     Language.PureScript.Errors.$fMonoidMultipleErrors
                     (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
                        @ Language.PureScript.Errors.MultipleErrors))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.Writer.Lazy.WriterT
                      Language.PureScript.Errors.MultipleErrors
                      (Control.Monad.Trans.Except.ExceptT
                         Language.PureScript.Errors.MultipleErrors
                         Data.Functor.Identity.Identity)
                      a>_R
                   ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           b>_R
                   ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <b>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity)
                               a) ->
                   Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                     @ b
                     @ a
                     (case eta
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(a,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (a,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                        Data.Either.Left x
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                              x)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b -> a,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <(b
                                                                                                      -> a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <b
                                                                                                                                                                 -> a>_N)))
                        Data.Either.Right y
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                              (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                                 @ a
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ b
                                 y))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b -> a,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <(b
                                                                                                      -> a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <b
                                                                                                                                                                 -> a>_N))) })) -}
a2858926ce4b03337630097af49e48d1
  $s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           (a -> b))
                   (v :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           a) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Errors.MultipleErrors
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ (a, Language.PureScript.Errors.MultipleErrors)
                   @ (b, Language.PureScript.Errors.MultipleErrors)
                   (case f `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <a -> b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <(a -> b,
                                                  Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                      <Data.Either.Either
                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                         (a
                                                                                                          -> b,
                                                                                                          Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ ((a, Language.PureScript.Errors.MultipleErrors)
                               -> (b, Language.PureScript.Errors.MultipleErrors))
                            x)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      ((a, Language.PureScript.Errors.MultipleErrors)
                                       -> (b,
                                           Language.PureScript.Errors.MultipleErrors))>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(a,
                                                                                                        Language.PureScript.Errors.MultipleErrors)
                                                                                                       -> (b,
                                                                                                           Language.PureScript.Errors.MultipleErrors)>_N))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ ((a, Language.PureScript.Errors.MultipleErrors)
                               -> (b, Language.PureScript.Errors.MultipleErrors))
                            (\ (ds1 :: (a, Language.PureScript.Errors.MultipleErrors)) ->
                             (case y of wild1 { (,) a1 w1 ->
                              a1 (case ds1 of wild2 { (,) b1 w' -> b1 }) },
                              (GHC.Base.augment
                                 @ Language.PureScript.AST.Declarations.ErrorMessage
                                 (\ @ b1
                                    (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                          -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  case y of wild1 { (,) a1 w1 ->
                                  GHC.Base.foldr
                                    @ Language.PureScript.AST.Declarations.ErrorMessage
                                    @ b1
                                    c
                                    n
                                    w1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                 (case ds1 of wild1 { (,) b1 w' ->
                                  w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                `cast`
                              (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      ((a, Language.PureScript.Errors.MultipleErrors)
                                       -> (b,
                                           Language.PureScript.Errors.MultipleErrors))>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(a,
                                                                                                        Language.PureScript.Errors.MultipleErrors)
                                                                                                       -> (b,
                                                                                                           Language.PureScript.Errors.MultipleErrors)>_N)) })
                   v `cast`
                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                        <Language.PureScript.Errors.MultipleErrors>_N
                        <Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           Data.Functor.Identity.Identity>_R
                        <a>_N))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         Language.PureScript.Errors.MultipleErrors
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            Data.Functor.Identity.Identity)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
f6e7d95e9323118ca2ac91a97bb9cef9
  $s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (a1 :: a) ->
                 Data.Either.Right
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (a, Language.PureScript.Errors.MultipleErrors)
                   (a1,
                    (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                      `cast`
                    (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  Language.PureScript.Errors.MultipleErrors
                                  (a,
                                   Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(a,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                          <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                             Data.Functor.Identity.Identity>_R
                                                                                                                                                          <a>_N))) -}
0fedf93defdec8d2fdd6c4e73af2421e
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s
                               (Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors)))
                               b)
                     (eta1 :: s) ->
                   let {
                     m1 :: Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))
                             (b, s)
                     = eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <b>_N)
                         eta1
                   } in
                   (\ (s1 :: GHC.Integer.Type.Integer) ->
                    case (m1
                            `cast`
                          (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                Language.PureScript.Errors.MultipleErrors
                                                                (Control.Monad.Trans.Except.Except
                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                   s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                               <(b,
                                                                                                                                 s)>_N)
                            s1)
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <((b, s),
                                GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                    <Data.Functor.Identity.Identity>_R
                                                                    <(((b, s),
                                                                       GHC.Integer.Type.Integer),
                                                                      Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                          <Data.Either.Either
                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                             (((b,
                                                                                                                                s),
                                                                                                                               GHC.Integer.Type.Integer),
                                                                                                                              Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x1
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            x1)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N)))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            (let {
                               ds :: ((b, s), GHC.Integer.Type.Integer)
                               = case y of wild1 { (,) a1 w1 -> a1 }
                             } in
                             ((x,
                               case ds of wild1 { (,) a1 s' ->
                               case a1 of wild2 { (,) a2 s'1 -> s'1 } }),
                              case ds of wild1 { (,) a1 s' -> s' }),
                             case y of wild1 { (,) a1 w1 -> w1 }))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) })
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <GHC.Integer.Type.Integer>_N
                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors)>_R
                             <(a,
                               s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                   (Control.Monad.Trans.Except.Except
                                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                      s)>_N))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
7d41c1b392b7b221628b75fe8a1a00bf
  $s$fApplicativeStateT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left x
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         x)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right y
                   -> (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         (let {
                            ds :: (a, s) = case y of wild1 { (,) a1 w1 -> a1 }
                          } in
                          (f (case ds of wild1 { (,) a1 s' -> a1 }),
                           case ds of wild1 { (,) a1 s' -> s' }),
                          case y of wild1 { (,) a1 w1 -> w1 }))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N))) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
f1de5501393943926df560189cf91a49
  $s$fApplicativeStateT_$s$fFunctorSupplyT ::
    GHC.Base.Functor
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               GHC.Integer.Type.Integer
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               b)
                     (eta1 :: GHC.Integer.Type.Integer) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <GHC.Integer.Type.Integer>_N
                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <b>_N)
                           eta1)
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity>_R
                             <(b,
                               GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <((b, GHC.Integer.Type.Integer),
                                                                     Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                         <Data.Either.Either
                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                            ((b,
                                                                                                                              GHC.Integer.Type.Integer),
                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                     Data.Either.Left x1
                     -> (Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           x1)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N)))
                     Data.Either.Right y
                     -> (Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ ((a, GHC.Integer.Type.Integer),
                              Language.PureScript.Errors.MultipleErrors)
                           ((x,
                             case y of wild1 { (,) a1 w1 ->
                             case a1 of wild2 { (,) a2 s' -> s' } }),
                            case y of wild1 { (,) a1 w1 -> w1 }))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     ((a, GHC.Integer.Type.Integer),
                                      Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                                 <((a,
                                                                                                    GHC.Integer.Type.Integer),
                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                Data.Functor.Identity.Identity>_R
                                                                                                                                                             <(a,
                                                                                                                                                               GHC.Integer.Type.Integer)>_N))) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
5013746f4348ac72b43bc37360ffac89
  $s$fApplicativeStateT_$s$fFunctorWriterT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ w.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       w
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap
                     @ w)
                  (\ @ a @ b (x :: a) ->
                   Control.Monad.Trans.Writer.Lazy.mapWriterT
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     @ b
                     @ w
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity)
                     @ a
                     @ w
                     (\ (x1 :: Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity
                                 (b, w)) ->
                      case x1
                             `cast`
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Data.Functor.Identity.Identity>_R
                                <(b, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                 <Data.Either.Either
                                                    Language.PureScript.Errors.MultipleErrors
                                                    (b, w)>_R) of wild {
                        Data.Either.Left x2
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (a, w)
                              x2)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors (a, w)>_R))
                        Data.Either.Right y
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (a, w)
                              (x, case y of wild1 { (,) a1 w1 -> w1 }))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors (a, w)>_R)) })
                       `cast`
                     (<Control.Monad.Trans.Except.ExceptT
                         Language.PureScript.Errors.MultipleErrors
                         Data.Functor.Identity.Identity
                         (b, w)>_R
                      ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <Language.PureScript.Errors.MultipleErrors>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <(a, w)>_N))) -}
0ac6f08a3dcc06f4481222ecd80ca8f9
  $s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ a
                   @ w
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ b
                   @ w
                   (\ (ds1 :: Data.Either.Either
                                Language.PureScript.Errors.MultipleErrors (a, w)) ->
                    case ds1 of wild {
                      Data.Either.Left x
                      -> Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ (b, w)
                           x
                      Data.Either.Right y
                      -> Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ (b, w)
                           (f (case y of wild1 { (,) a1 w1 -> a1 }),
                            case y of wild1 { (,) a1 w1 -> w1 }) })
                     `cast`
                   ((Sym (Data.Functor.Identity.N:Identity[0]
                              <Data.Either.Either
                                 Language.PureScript.Errors.MultipleErrors
                                 (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <(a, w)>_N))
                    ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     (b, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                           <Data.Functor.Identity.Identity>_R
                                                           <(b, w)>_N))) -}
8ff64290ff24a52881fc7bd8df89a34c
  $s$fApplicativeStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.Except
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right x
                   -> case (k `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N)
                              (case x of wild1 { (,) a1 w2 ->
                               case a1 of wild2 { (,) a2 s' -> s' } }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <(b, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((b, s),
                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           ((b,
                                                                                                             s),
                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N)))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N))) } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.Except
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
95af38792d5359c747b0092a744efeea
  $s$fApplicativeStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.Except
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Trans.Writer.Lazy.WriterT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Trans.Except.Except
                   Language.PureScript.Errors.MultipleErrors))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (s1 :: s) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)>_R
                            <a>_N)
                         s1)
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <((a, s),
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      ((a,
                                                                                                        s),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((b, s),
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                               <Language.PureScript.Errors.MultipleErrors>_N
                                                                                               <Data.Functor.Identity.Identity>_R
                                                                                               <((b,
                                                                                                  s),
                                                                                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                                                           <(b,
                                                                                                                                                             s)>_N)))
                   Data.Either.Right x
                   -> let {
                        ds :: (a, s) = case x of wild1 { (,) a1 w2 -> a1 }
                      } in
                      case ((k (case ds of wild1 { (,) a1 s' -> a1 }))
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <b>_N)
                              (case ds of wild1 { (,) a1 s' -> s' }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <(b, s)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((b, s),
                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           ((b,
                                                                                                             s),
                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N)))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ ((b, s), Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        ((b, s),
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                                    <((b,
                                                                                                       s),
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                                                <(b,
                                                                                                                                                                  s)>_N))) } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.Except
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
ae7207bdc6c4f22bd83688208754d606
  $s$fApplicativeStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           ((a, s), Language.PureScript.Errors.MultipleErrors)))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R (<s>_R
                       ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Language.PureScript.Errors.MultipleErrors>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <((a, s),
                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                 <(a,
                                                                                                   s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <s>_N
                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                      <a>_N)) -}
63af23f8224962a1a92fbc470f84ee77
  $s$fApplicativeStateT_$s$fMonadSupplyT ::
    GHC.Base.Monad
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeSupplyT
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>=
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                         Language.PureScript.Errors.MultipleErrors
                                                                         (Control.Monad.Trans.Except.Except
                                                                            Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <b>_N)
                  (\ @ a (eta :: a) (eta1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((eta, eta1),
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$cfail
                     @ GHC.Integer.Type.Integer)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
69b3f4d05679a57167c9481528baf9e4
  $s$fApplicativeStateT_$s$fMonadWriterT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>=
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>
                  (\ @ a (eta :: a) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (a, Language.PureScript.Errors.MultipleErrors)
                     (eta,
                      (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (a,
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <a>_N)))
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$cfail -}
eb7f85cc80adcc87218a56b836418bc5
  $s$fApplicativeStateT_$s$fMonadWriterT_$c>> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a)
                   (k :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity)
                           b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a,
                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                              <Data.Either.Either
                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                 (a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (b, Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (b,
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(b,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N))
                   Data.Either.Right x
                   -> case k `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(b,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (b,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         Language.PureScript.Errors.MultipleErrors
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            Data.Functor.Identity.Identity)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
1b24e371785f71bff818e1aae73594fc
  $s$fApplicativeStateT_$s$fMonadWriterT_$c>>= ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> (a
        -> Control.Monad.Trans.Writer.Lazy.WriterT
             Language.PureScript.Errors.MultipleErrors
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                Data.Functor.Identity.Identity)
             b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity)
                              b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <Language.PureScript.Errors.MultipleErrors>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a,
                                          Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                              <Data.Either.Either
                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                 (a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (b, Language.PureScript.Errors.MultipleErrors)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (b,
                                    Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(b,
                                                                                                Language.PureScript.Errors.MultipleErrors)>_N))
                   Data.Either.Right x
                   -> case (k (case x of wild1 { (,) a1 w2 -> a1 }))
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Language.PureScript.Errors.MultipleErrors>_N
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   Data.Functor.Identity.Identity>_R
                                <b>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                             <Language.PureScript.Errors.MultipleErrors>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <(b,
                                               Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                   <Data.Either.Either
                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                      (b,
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                        Data.Either.Left e1
                        -> (Data.Either.Left
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              e1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N))
                        Data.Either.Right x1
                        -> (Data.Either.Right
                              @ Language.PureScript.Errors.MultipleErrors
                              @ (b, Language.PureScript.Errors.MultipleErrors)
                              (case x1 of wild2 { (,) b1 w' -> b1 },
                               (GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b1
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b1 -> b1)[OneShot]
                                     (n :: b1)[OneShot] ->
                                   case x of wild2 { (,) a1 w2 ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b1
                                     c
                                     n
                                     w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                  (case x1 of wild2 { (,) b1 w' ->
                                   w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Language.PureScript.Errors.MultipleErrors
                                        (b,
                                         Language.PureScript.Errors.MultipleErrors)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(b,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    Language.PureScript.Errors.MultipleErrors
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            b>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
1f46736c229d7391ae43515e3f13ca0c
  $s$fApplicativeStateT_$s$fMonadWriterT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, Strictness: <B,U>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ a (msg :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           (a, Language.PureScript.Errors.MultipleErrors)))
                   msg)
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Data.Functor.Identity.Identity>_R
                               <(a,
                                 Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                              Data.Functor.Identity.Identity>_R
                                                                                           <a>_N)) -}
da9ec807aefde5cc3c0d3bb92d1360d8
  $s$fApplicativeWriterT_$c<* ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                Data.Functor.Identity.Identity)
                             a) ->
                 Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
                   @ b
                   @ a
                   (case eta
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <Language.PureScript.Errors.MultipleErrors>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <(a,
                                             Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                 <Data.Either.Either
                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                    (a,
                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left x
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                            x)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a,
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(b
                                                                                                    -> a,
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <b
                                                                                                                                                               -> a>_N)))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (b -> a, Language.PureScript.Errors.MultipleErrors)
                            (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                               @ a
                               @ Language.PureScript.Errors.MultipleErrors
                               @ b
                               y))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a,
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(b
                                                                                                    -> a,
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <b
                                                                                                                                                               -> a>_N))) })) -}
678fad10597b8b82894f42d42116d4e3
  $s$fFunctorWriterT_$c<$ ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ w @ a @ b (x :: a) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ b
                   @ w
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        Data.Functor.Identity.Identity)
                   @ a
                   @ w
                   (\ (x1 :: Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity
                               (b, w)) ->
                    case x1
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Data.Functor.Identity.Identity>_R
                              <(b, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Language.PureScript.Errors.MultipleErrors
                                                  (b, w)>_R) of wild {
                      Data.Either.Left x2
                      -> (Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (a, w)
                            x2)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors (a, w)>_R))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (a, w)
                            (x, case y of wild1 { (,) a1 w1 -> w1 }))
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors (a, w)>_R)) })
                     `cast`
                   (<Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity
                       (b, w)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <(a, w)>_N))) -}
953b439f73831e9eececddbf3c7c0373
  $s$fMonadErroreStateT0 ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ @ a
                     (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Left
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((a, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     eta)
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                (((a, s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <(((a,
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <((a,
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <(a,
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <a>_N))
                  (\ @ a
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s
                               (Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors)))
                               a)
                     (eta1 :: Language.PureScript.Errors.MultipleErrors
                              -> Control.Monad.Trans.State.Lazy.StateT
                                   s
                                   (Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors)))
                                   a)
                     (eta2 :: s) ->
                   let {
                     eta4 :: Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))
                               (a, s)
                     = eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <a>_N)
                         eta2
                   } in
                   (\ (eta5 :: GHC.Integer.Type.Integer) ->
                    case (eta4
                            `cast`
                          (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                Language.PureScript.Errors.MultipleErrors
                                                                (Control.Monad.Trans.Except.Except
                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                   s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                               <GHC.Integer.Type.Integer>_N
                                                                                                                               <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                               <(a,
                                                                                                                                 s)>_N)
                            eta5)
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 Data.Functor.Identity.Identity>_R
                              <((a, s),
                                GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_N
                                                                    <Data.Functor.Identity.Identity>_R
                                                                    <(((a, s),
                                                                       GHC.Integer.Type.Integer),
                                                                      Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                          <Data.Either.Either
                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                             (((a,
                                                                                                                                s),
                                                                                                                               GHC.Integer.Type.Integer),
                                                                                                                              Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                      Data.Either.Left l
                      -> ((eta1 l)
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)
                            eta2)
                           `cast`
                         (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                               Language.PureScript.Errors.MultipleErrors
                                                               (Control.Monad.Trans.Except.Except
                                                                  Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                  s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                              <GHC.Integer.Type.Integer>_N
                                                                                                                              <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                 (Control.Monad.Trans.Except.Except
                                                                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                              <(a,
                                                                                                                                s)>_N)
                           eta5
                      Data.Either.Right r
                      -> (Data.Either.Right
                            @ Language.PureScript.Errors.MultipleErrors
                            @ (((a, s), GHC.Integer.Type.Integer),
                               Language.PureScript.Errors.MultipleErrors)
                            r)
                           `cast`
                         (Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) })
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <GHC.Integer.Type.Integer>_N
                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors)>_R
                             <(a,
                               s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                   (Control.Monad.Trans.Except.Except
                                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                      s)>_N))
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R <Language.PureScript.Errors.MultipleErrors
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Supply.SupplyT
                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)))
                              a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
7362e02db3b0486581f71e4a970e186e
  $s$fMonadErroreStateT0_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>=
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>
                     @ s)
                  (\ @ a (eta :: a) (eta1 :: s) ->
                   let {
                     eta2 :: (a, s) = (eta, eta1)
                   } in
                   (\ (eta3 :: GHC.Integer.Type.Integer) ->
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ (((a, s), GHC.Integer.Type.Integer),
                         Language.PureScript.Errors.MultipleErrors)
                      ((eta2, eta3),
                       (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                     `cast`
                   ((<GHC.Integer.Type.Integer>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((a, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((a,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((a,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                            <(a,
                                                                                                                                                                                                              s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                     s)>_N)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail
                     @ s) -}
022bee78841460e71c871b65b16dda85
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s
                           (Control.Monad.Supply.SupplyT
                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Trans.Except.Except
                                    Language.PureScript.Errors.MultipleErrors)))
                           b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       case ((k `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds of wild1 { (,) a1 s' ->
                                 case a1 of wild2 { (,) a2 s'1 -> s'1 } }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s
                         (Control.Monad.Supply.SupplyT
                            (Control.Monad.Trans.Writer.Lazy.WriterT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Trans.Except.Except
                                  Language.PureScript.Errors.MultipleErrors)))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
594dc48c3c312936610d7603281aea8a
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
      a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s
             (Control.Monad.Supply.SupplyT
                (Control.Monad.Trans.Writer.Lazy.WriterT
                   Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Trans.Except.Except
                      Language.PureScript.Errors.MultipleErrors)))
             b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s
                              (Control.Monad.Supply.SupplyT
                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)))
                              b)
                   (s1 :: s) ->
                 let {
                   m2 :: Control.Monad.Supply.SupplyT
                           (Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors))
                           (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N
                          <Control.Monad.Supply.SupplyT
                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Trans.Except.Except
                                   Language.PureScript.Errors.MultipleErrors))>_R
                          <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  case (m2
                          `cast`
                        (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                             <GHC.Integer.Type.Integer>_N
                                                                                                                             <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                             <(a,
                                                                                                                               s)>_N)
                          s2)
                         `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity>_R
                            <((a, s),
                              GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                  <Data.Functor.Identity.Identity>_R
                                                                  <(((a, s),
                                                                     GHC.Integer.Type.Integer),
                                                                    Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                        <Data.Either.Either
                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                           (((a,
                                                                                                                              s),
                                                                                                                             GHC.Integer.Type.Integer),
                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R)) of wild {
                    Data.Either.Left e1
                    -> (Data.Either.Left
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (((b, s), GHC.Integer.Type.Integer),
                             Language.PureScript.Errors.MultipleErrors)
                          e1)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((b, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((b,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((b,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N)))
                    Data.Either.Right x
                    -> let {
                         ds :: ((a, s), GHC.Integer.Type.Integer)
                         = case x of wild1 { (,) a1 w2 -> a1 }
                       } in
                       let {
                         ds1 :: (a, s) = case ds of wild1 { (,) a1 s' -> a1 }
                       } in
                       case (((k (case ds1 of wild1 { (,) a1 s' -> a1 }))
                                `cast`
                              (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <s>_N
                                   <Control.Monad.Supply.SupplyT
                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Trans.Except.Except
                                            Language.PureScript.Errors.MultipleErrors))>_R
                                   <b>_N)
                                (case ds1 of wild1 { (,) a1 s' -> s' }))
                               `cast`
                             (Control.Monad.Supply.N:SupplyT[0] <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                      s)>_N ; Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                  <GHC.Integer.Type.Integer>_N
                                                                                                                                  <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                  <(b,
                                                                                                                                    s)>_N)
                               (case ds of wild1 { (,) a1 s' -> s' }))
                              `cast`
                            (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    Data.Functor.Identity.Identity>_R
                                 <((b, s),
                                   GHC.Integer.Type.Integer)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <(((b, s),
                                                                          GHC.Integer.Type.Integer),
                                                                         Language.PureScript.Errors.MultipleErrors)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                                                                             <Data.Either.Either
                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                (((b,
                                                                                                                                   s),
                                                                                                                                  GHC.Integer.Type.Integer),
                                                                                                                                 Language.PureScript.Errors.MultipleErrors)>_R)) of wild1 {
                         Data.Either.Left e1
                         -> (Data.Either.Left
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               e1)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N)))
                         Data.Either.Right x1
                         -> (Data.Either.Right
                               @ Language.PureScript.Errors.MultipleErrors
                               @ (((b, s), GHC.Integer.Type.Integer),
                                  Language.PureScript.Errors.MultipleErrors)
                               (case x1 of wild2 { (,) b1 w' -> b1 },
                                (GHC.Base.augment
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   (\ @ b1
                                      (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                            -> b1 -> b1)[OneShot]
                                      (n :: b1)[OneShot] ->
                                    case x of wild2 { (,) a1 w2 ->
                                    GHC.Base.foldr
                                      @ Language.PureScript.AST.Declarations.ErrorMessage
                                      @ b1
                                      c
                                      n
                                      w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) })
                                   (case x1 of wild2 { (,) b1 w' ->
                                    w' `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                                  `cast`
                                (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Language.PureScript.Errors.MultipleErrors
                                         (((b, s), GHC.Integer.Type.Integer),
                                          Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                                     <(((b,
                                                                                                         s),
                                                                                                        GHC.Integer.Type.Integer),
                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                 <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                                                                 <((b,
                                                                                                                                                                    s),
                                                                                                                                                                   GHC.Integer.Type.Integer)>_N))) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Integer.Type.Integer>_N
                           <Control.Monad.Trans.Writer.Lazy.WriterT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Trans.Except.Except
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <(b,
                             s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Trans.Except.Except
                                                                                    Language.PureScript.Errors.MultipleErrors)>_N <(b,
                                                                                                                                    s)>_N))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s
                    (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s
                            (Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors)))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <b>_N)) -}
94e457aabed44cf4a7f08ceb6c4375cb
  $s$fMonadErroreStateT0_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 3, Strictness: <B,U><B,A><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s
                   @ a
                   (str :: GHC.Base.String)
                   (ds :: s)
                   (ds1 :: GHC.Integer.Type.Integer) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Functor.Identity.Identity
                        (Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors
                           (((a, s), GHC.Integer.Type.Integer),
                            Language.PureScript.Errors.MultipleErrors)))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R (<s>_R
                       ->_R (<GHC.Integer.Type.Integer>_R
                             ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <Language.PureScript.Errors.MultipleErrors>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <(((a, s), GHC.Integer.Type.Integer),
                                             Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Control.Monad.Trans.Except.ExceptT
                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                          Data.Functor.Identity.Identity>_R
                                                                                                       <((a,
                                                                                                          s),
                                                                                                         GHC.Integer.Type.Integer)>_N)) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                                                                                    <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                    <(a,
                                                                                                                                                      s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                             s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                <s>_N
                                                                                                                                                                                                                                                                                <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                <a>_N)) -}
d126a8e31cf74c65e25f6b8e77eabd4f
  $s$fMonadStatesStateT0 ::
    Control.Monad.State.Class.MonadState
      s
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ s
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ (x :: s) ->
                   let {
                     eta :: (s, s) = (x, x)
                   } in
                   (\ (eta1 :: GHC.Integer.Type.Integer) ->
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ (((s, s), GHC.Integer.Type.Integer),
                         Language.PureScript.Errors.MultipleErrors)
                      ((eta, eta1),
                       (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                         `cast`
                       (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                     `cast`
                   ((<GHC.Integer.Type.Integer>_R
                     ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (((s, s), GHC.Integer.Type.Integer),
                                       Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                  <Data.Functor.Identity.Identity>_R
                                                                                                  <(((s,
                                                                                                      s),
                                                                                                     GHC.Integer.Type.Integer),
                                                                                                    Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                 Data.Functor.Identity.Identity>_R
                                                                                                                                                              <((s,
                                                                                                                                                                 s),
                                                                                                                                                                GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                            <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                            <(s,
                                                                                                                                                                                                              s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N <(s,
                                                                                                                                                                                                                                                                                                                     s)>_N)))
                    `cast`
                  (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N
                            <Control.Monad.Supply.SupplyT
                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Trans.Except.Except
                                     Language.PureScript.Errors.MultipleErrors))>_R
                            <s>_N))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sput
                     @ s)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sstate
                     @ s) -}
0531297c0398281087f67584652831d5
  $s$fMonadStatesStateT0_$sput ::
    s
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         ()
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s (s1 :: s) (x :: s) ->
                 let {
                   eta :: ((), s) = (GHC.Tuple.(), s1)
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ ((((), s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    ((((), s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <((((),
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <(((),
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <((),
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <((),
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N).
                 <s>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <()>_N)) -}
0acf3fa4bbde85d209c80dab2c6c78d9
  $s$fMonadStatesStateT0_$sstate ::
    (s -> (a, s))
    -> Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors)))
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (f :: s -> (a, s)) (x :: s) ->
                 let {
                   eta :: (a, s) = f x
                 } in
                 (\ (eta1 :: GHC.Integer.Type.Integer) ->
                  Data.Either.Right
                    @ Language.PureScript.Errors.MultipleErrors
                    @ (((a, s), GHC.Integer.Type.Integer),
                       Language.PureScript.Errors.MultipleErrors)
                    ((eta, eta1),
                     (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                       `cast`
                     (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                   `cast`
                 ((<GHC.Integer.Type.Integer>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (((a, s), GHC.Integer.Type.Integer),
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(((a,
                                                                                                    s),
                                                                                                   GHC.Integer.Type.Integer),
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <((a,
                                                                                                                                                               s),
                                                                                                                                                              GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                          <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                          <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                          <(a,
                                                                                                                                                                                                            s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                   s)>_N)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <s -> (a, s)>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N
                               <Control.Monad.Supply.SupplyT
                                  (Control.Monad.Trans.Writer.Lazy.WriterT
                                     Language.PureScript.Errors.MultipleErrors
                                     (Control.Monad.Trans.Except.Except
                                        Language.PureScript.Errors.MultipleErrors))>_R
                               <a>_N)) -}
dc2da9f08791dd1f0cca4b5c51db4c10
  $s$fMonadSupplyStateT ::
    Control.Monad.Supply.Class.MonadSupply
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ (eta :: s) (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((GHC.Integer.Type.Integer, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((s1, eta),
                       GHC.Integer.Type.plusInteger
                         s1
                         Control.Monad.Supply.Class.$fMonadSupplySupplyT2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          n))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  ((<s>_R
                    ->_R (<GHC.Integer.Type.Integer>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           (((GHC.Integer.Type.Integer, s),
                                             GHC.Integer.Type.Integer),
                                            Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Data.Functor.Identity.Identity>_R
                                                                                                       <(((GHC.Integer.Type.Integer,
                                                                                                           s),
                                                                                                          GHC.Integer.Type.Integer),
                                                                                                         Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                      Data.Functor.Identity.Identity>_R
                                                                                                                                                                   <((GHC.Integer.Type.Integer,
                                                                                                                                                                      s),
                                                                                                                                                                     GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                 <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                   s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_N <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                                                                                                                          s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                             <s>_N
                                                                                                                                                                                                                                                                                                                                             <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                             <GHC.Integer.Type.Integer>_N))
                  (\ (eta :: s) (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((GHC.Integer.Type.Integer, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((s1, eta), s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          n))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  ((<s>_R
                    ->_R (<GHC.Integer.Type.Integer>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           (((GHC.Integer.Type.Integer, s),
                                             GHC.Integer.Type.Integer),
                                            Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                       <Data.Functor.Identity.Identity>_R
                                                                                                       <(((GHC.Integer.Type.Integer,
                                                                                                           s),
                                                                                                          GHC.Integer.Type.Integer),
                                                                                                         Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                      Data.Functor.Identity.Identity>_R
                                                                                                                                                                   <((GHC.Integer.Type.Integer,
                                                                                                                                                                      s),
                                                                                                                                                                     GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                 <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                 <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                   s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)>_N <(GHC.Integer.Type.Integer,
                                                                                                                                                                                                                                                                                                                          s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                             <s>_N
                                                                                                                                                                                                                                                                                                                                             <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                             <GHC.Integer.Type.Integer>_N)) -}
517c07ddff73d2246ea616e927c91129
  $s$fMonadWriterSupplyT ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Supply.SupplyT
         (Control.Monad.Trans.Writer.Lazy.WriterT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Trans.Except.Except
               Language.PureScript.Errors.MultipleErrors)))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Supply.SupplyT
                       (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors)))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT
                  (\ @ a
                     (eta :: (a, Language.PureScript.Errors.MultipleErrors))
                     (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((a, GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((case eta of wild { (,) a1 w2 -> a1 }, s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          case eta of wild { (,) a1 w2 ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          ((a, GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <((a,
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <(a,
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors)>_N <a>_N))
                  (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     ((GHC.Tuple.(), s1),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            eta `cast` (Language.PureScript.Errors.N:MultipleErrors[0])))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<GHC.Integer.Type.Integer>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <Data.Either.Either
                                          Language.PureScript.Errors.MultipleErrors
                                          (((), GHC.Integer.Type.Integer),
                                           Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                                      <(((),
                                                                                                         GHC.Integer.Type.Integer),
                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                  <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                     Data.Functor.Identity.Identity>_R
                                                                                                                                                                  <((),
                                                                                                                                                                    GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                <()>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <()>_N))
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <a>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <(a,
                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                               (Control.Monad.Trans.Except.Except
                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N)
                  (\ @ a ->
                   Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Trans.Writer.Lazy.WriterT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Trans.Except.Except
                             Language.PureScript.Errors.MultipleErrors))
                     @ GHC.Integer.Type.Integer
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                 -> Language.PureScript.Errors.MultipleErrors)>_N
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <GHC.Integer.Type.Integer>_N
                                 <Control.Monad.Trans.Writer.Lazy.WriterT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Trans.Except.Except
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                     (Control.Monad.Trans.Except.Except
                                                                                        Language.PureScript.Errors.MultipleErrors)>_N <a>_N) -}
ddf9ecc94c0ad95903d70c5744b20086
  $s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0 ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.Writer.Lazy.WriterT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          Data.Functor.Identity.Identity))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
                  (\ @ a ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (a, Language.PureScript.Errors.MultipleErrors))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    (a,
                                     Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                <Data.Functor.Identity.Identity>_R
                                                                                                <(a,
                                                                                                  Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                                                                               Data.Functor.Identity.Identity>_R
                                                                                                                                                            <a>_N)))
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$stell
                     @ Language.PureScript.Errors.MultipleErrors)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$slisten
                     @ Language.PureScript.Errors.MultipleErrors)
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$spass
                     @ Language.PureScript.Errors.MultipleErrors) -}
65f3a9583f0a8d31b27ef6ef1121b0d0
  $s$fMonadWriterSupplyT_$slisten ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      w
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         (a, w)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w
                   @ a
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            w
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            a) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <a>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Language.PureScript.Errors.MultipleErrors>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <(a, w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                         <Data.Either.Either
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (a, w)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((a, w), w)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((a, w), w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <((a, w), w)>_N))
                   Data.Either.Right x
                   -> let {
                        w1 :: w = case x of wild1 { (,) a1 w2 -> w2 }
                      } in
                      (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ ((a, w), w)
                         ((case x of wild1 { (,) a1 w2 -> a1 }, w1), w1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   ((a, w), w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                              <Language.PureScript.Errors.MultipleErrors>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <((a, w), w)>_N)) })
                  `cast`
                (forall (w :: <*>_N) (a :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    w
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <w>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <(a, w)>_N)) -}
64ff6c90831b4ec474827815e7a7ff2d
  $s$fMonadWriterSupplyT_$spass ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      w
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         Data.Functor.Identity.Identity)
      (a, w -> w)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w
                   @ a
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            w
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               Data.Functor.Identity.Identity)
                            (a, w -> w)) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <w>_N
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              Data.Functor.Identity.Identity>_R
                           <(a, w -> w)>_N ; (Control.Monad.Trans.Except.N:ExceptT[0]
                                                  <Language.PureScript.Errors.MultipleErrors>_N
                                                  <Data.Functor.Identity.Identity>_R
                                                  <((a, w -> w),
                                                    w)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                <Data.Either.Either
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   ((a, w -> w), w)>_R)) of wild {
                   Data.Either.Left e1
                   -> (Data.Either.Left
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (a, w)
                         e1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(a, w)>_N))
                   Data.Either.Right x
                   -> let {
                        ds1 :: (a, w -> w, w)
                        = case x of wild1 { (,) ds2 w1 ->
                          case ds2 of wild2 { (,) a1 f -> (a1, f, w1) } }
                      } in
                      (Data.Either.Right
                         @ Language.PureScript.Errors.MultipleErrors
                         @ (a, w)
                         (case ds1 of ds2 { (,,) a1 f w1 -> a1 },
                          case ds1 of ds2 { (,,) a1 f w1 -> f w1 }))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Language.PureScript.Errors.MultipleErrors
                                   (a, w)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                         <Data.Functor.Identity.Identity>_R
                                                         <(a, w)>_N)) })
                  `cast`
                (forall (w :: <*>_N) (a :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    w
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       Data.Functor.Identity.Identity)
                    (a, w -> w)>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <w>_N
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  Data.Functor.Identity.Identity>_R
                               <a>_N)) -}
b088bf300774ab54c559f226e5c66547
  $s$fMonadWriterSupplyT_$stell ::
    w
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            Data.Functor.Identity.Identity)
         ()
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w (w1 :: w) ->
                 Data.Either.Right
                   @ Language.PureScript.Errors.MultipleErrors
                   @ ((), w)
                   (GHC.Tuple.(), w1))
                  `cast`
                (forall (w :: <*>_N).
                 <w>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either
                                  Language.PureScript.Errors.MultipleErrors
                                  ((), w)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <((),
                                                            w)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                              <w>_N
                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 Data.Functor.Identity.Identity>_R
                                                                              <()>_N))) -}
9821cf632143e44852830b378b9e14e9
  $s$fMonadWriterwStateT0 ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Trans.State.Lazy.StateT
         s
         (Control.Monad.Supply.SupplyT
            (Control.Monad.Trans.Writer.Lazy.WriterT
               Language.PureScript.Errors.MultipleErrors
               (Control.Monad.Trans.Except.Except
                  Language.PureScript.Errors.MultipleErrors))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s
                       (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors))))
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  (Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
                     @ s)
                  (\ @ a
                     (eta :: (a, Language.PureScript.Errors.MultipleErrors))
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (((a, s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((case eta of wild { (,) a1 w2 -> a1 }, s1), s2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          case eta of wild { (,) a1 w2 ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            w2 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]) }))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                (((a, s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <(((a,
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <((a,
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <(a,
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <(a,
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <a>_N))
                  (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                     (s1 :: s)
                     (s2 :: GHC.Integer.Type.Integer) ->
                   Data.Either.Right
                     @ Language.PureScript.Errors.MultipleErrors
                     @ ((((), s), GHC.Integer.Type.Integer),
                        Language.PureScript.Errors.MultipleErrors)
                     (((GHC.Tuple.(), s1), s2),
                      (GHC.Base.build
                         @ Language.PureScript.AST.Declarations.ErrorMessage
                         (\ @ b
                            (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                  -> b -> b)[OneShot]
                            (n :: b)[OneShot] ->
                          GHC.Base.foldr
                            @ Language.PureScript.AST.Declarations.ErrorMessage
                            @ b
                            c
                            n
                            eta `cast` (Language.PureScript.Errors.N:MultipleErrors[0])))
                        `cast`
                      (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))))
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<s>_R
                         ->_R (<GHC.Integer.Type.Integer>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                ((((), s), GHC.Integer.Type.Integer),
                                                 Language.PureScript.Errors.MultipleErrors)>_R) ; (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                            <Data.Functor.Identity.Identity>_R
                                                                                                            <((((),
                                                                                                                s),
                                                                                                               GHC.Integer.Type.Integer),
                                                                                                              Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                                                                                                                        <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                        <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                           Data.Functor.Identity.Identity>_R
                                                                                                                                                                        <(((),
                                                                                                                                                                           s),
                                                                                                                                                                          GHC.Integer.Type.Integer)>_N))) ; (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                      <GHC.Integer.Type.Integer>_N
                                                                                                                                                                                                                      <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                      <((),
                                                                                                                                                                                                                        s)>_N) ; Sym (Control.Monad.Supply.N:SupplyT[0]) <Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors)>_N <((),
                                                                                                                                                                                                                                                                                                                               s)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                                                                                                                                                                                                                                  <s>_N
                                                                                                                                                                                                                                                                                                                                                  <Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))>_R
                                                                                                                                                                                                                                                                                                                                                  <()>_N))
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT4
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <(a, Language.PureScript.Errors.MultipleErrors)>_N))
                  (Control.Monad.Writer.Class.$fMonadWriterwStateT3
                     @ Language.PureScript.Errors.MultipleErrors
                     @ (Control.Monad.Supply.SupplyT
                          (Control.Monad.Trans.Writer.Lazy.WriterT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Trans.Except.Except
                                Language.PureScript.Errors.MultipleErrors)))
                     @ s
                     Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s
                      (Control.Monad.Supply.SupplyT
                         (Control.Monad.Trans.Writer.Lazy.WriterT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Trans.Except.Except
                               Language.PureScript.Errors.MultipleErrors)))
                      (a,
                       Language.PureScript.Errors.MultipleErrors
                       -> Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N
                                 <Control.Monad.Supply.SupplyT
                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Trans.Except.Except
                                          Language.PureScript.Errors.MultipleErrors))>_R
                                 <a>_N)) -}
141346584c77ea92d1a52848aa498ce0
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.TypeSearch.$trModule3
                   Language.PureScript.TypeChecker.TypeSearch.$trModule1) -}
a1aa4d29b1bf8bcb6b7c7ec7e873e507
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.TypeSearch.$trModule2) -}
89cff6786632b04385a9f0038e9a9682
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.TypeSearch"#) -}
634c8cd717d66004978bc9b8dcbd89c6
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.TypeSearch.$trModule4) -}
009cc147f5e0ccb62d4a2f52ff56e634
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
06dc9b4faba9828bde515a4ed540c358
  $wtypeSearch ::
    GHC.Base.Maybe
      [(Language.PureScript.Names.Ident,
        Language.PureScript.TypeChecker.Entailment.InstanceContext,
        Language.PureScript.Types.SourceConstraint)]
    -> Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Types.SourceType
    -> (# [(Language.PureScript.Names.Qualified
              Data.Text.Internal.Text,
            Language.PureScript.Types.SourceType)],
          GHC.Base.Maybe
            [(Language.PureScript.Label.Label,
              Language.PureScript.Types.SourceType)] #)
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U)><L,U(A,U,U,U,U,U,U,U)><L,U>,
     Inline: [0] -}
5681f218a1d342cd6ce3132b5eb6412b
  typeSearch ::
    GHC.Base.Maybe
      [(Language.PureScript.Names.Ident,
        Language.PureScript.TypeChecker.Entailment.InstanceContext,
        Language.PureScript.Types.SourceConstraint)]
    -> Language.PureScript.Environment.Environment
    -> Language.PureScript.TypeChecker.Monad.CheckState
    -> Language.PureScript.Types.SourceType
    -> ([(Language.PureScript.Names.Qualified Data.Text.Internal.Text,
          Language.PureScript.Types.SourceType)],
        GHC.Base.Maybe
          [(Language.PureScript.Label.Label,
            Language.PureScript.Types.SourceType)])
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U)><L,U(A,U,U,U,U,U,U,U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Base.Maybe
                           [(Language.PureScript.Names.Ident,
                             Language.PureScript.TypeChecker.Entailment.InstanceContext,
                             Language.PureScript.Types.SourceConstraint)])
                   (w1 :: Language.PureScript.Environment.Environment)
                   (w2 :: Language.PureScript.TypeChecker.Monad.CheckState)
                   (w3 :: Language.PureScript.Types.SourceType) ->
                 case Language.PureScript.TypeChecker.TypeSearch.$wtypeSearch
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT @ Identity _" [orphan] forall @ e
                                                                                                    (v1 :: GHC.Base.Monad
                                                                                                             Data.Functor.Identity.Identity)
                                                                                                    (v :: GHC.Base.Functor
                                                                                                            Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ Data.Functor.Identity.Identity
                                                  @ e
                                                  v
                                                  v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$c*> @ Identity _" [orphan] forall @ e
                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                       Data.Functor.Identity.Identity)
                                                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                                                         Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c*> @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$c*>
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$c<* @ Identity _" [orphan] forall @ e
                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                       Data.Functor.Identity.Identity)
                                                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                                                         Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$c<* @ Data.Functor.Identity.Identity
                                                       @ e
                                                       $dFunctor
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$c<*
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeExceptT_$cpure @ Identity _" [orphan] forall @ e
                                                                                                           ($dMonad :: GHC.Base.Monad
                                                                                                                         Data.Functor.Identity.Identity)
                                                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                                                           Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ Data.Functor.Identity.Identity
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ (Control.Monad.Supply.SupplyT
                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors)))
                                                     @ s
                                                     v
                                                     v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT1 @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT1 @ (Control.Monad.Supply.SupplyT
                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)))
                                                      @ s
                                                      $dFunctor
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT1
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$c*> @ (SupplyT
                                                                              (WriterT
                                                                                 MultipleErrors
                                                                                 (Except
                                                                                    MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*> @ (Control.Monad.Supply.SupplyT
                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                  Language.PureScript.Errors.MultipleErrors
                                                                  (Control.Monad.Trans.Except.Except
                                                                     Language.PureScript.Errors.MultipleErrors)))
                                                          @ s
                                                          $dFunctor
                                                          $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$c<*> @ (SupplyT
                                                                               (WriterT
                                                                                  MultipleErrors
                                                                                  (Except
                                                                                     MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ (Control.Monad.Supply.SupplyT
                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (Control.Monad.Trans.Except.Except
                                                                      Language.PureScript.Errors.MultipleErrors)))
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeStateT_$cpure @ (SupplyT
                                                                                (WriterT
                                                                                   MultipleErrors
                                                                                   (Except
                                                                                      MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors))))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ (Control.Monad.Supply.SupplyT
                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    (Control.Monad.Trans.Except.Except
                                                                       Language.PureScript.Errors.MultipleErrors)))
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeSupplyT @ (WriterT
                                                                          MultipleErrors
                                                                          (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fApplicativeSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                 Language.PureScript.Errors.MultipleErrors
                                                 (Control.Monad.Trans.Except.Except
                                                    Language.PureScript.Errors.MultipleErrors))
                                            v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT @ MultipleErrors @ (ExceptT
                                                                                           MultipleErrors
                                                                                           Identity)" [orphan] forall (v1 :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                              Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                  (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT @ Language.PureScript.Errors.MultipleErrors
                                                       @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            Data.Functor.Identity.Identity)
                                                       v
                                                       v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$c<* @ MultipleErrors @ (ExceptT
                                                                                                MultipleErrors
                                                                                                Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                        Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                 ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<* @ Language.PureScript.Errors.MultipleErrors
                                                            @ (Control.Monad.Trans.Except.ExceptT
                                                                 Language.PureScript.Errors.MultipleErrors
                                                                 Data.Functor.Identity.Identity)
                                                            $dMonoid
                                                            $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeWriterT_$c<*
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$c<*> @ MultipleErrors @ (ExceptT
                                                                                                 MultipleErrors
                                                                                                 Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                           Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                    ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<*> @ Language.PureScript.Errors.MultipleErrors
                                                             @ (Control.Monad.Trans.Except.ExceptT
                                                                  Language.PureScript.Errors.MultipleErrors
                                                                  Data.Functor.Identity.Identity)
                                                             $dMonoid
                                                             $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$c<*>
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fApplicativeWriterT_$cpure @ MultipleErrors @ (ExceptT
                                                                                                  MultipleErrors
                                                                                                  Identity)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                              Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                                       ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cpure @ Language.PureScript.Errors.MultipleErrors
                                                              @ (Control.Monad.Trans.Except.ExceptT
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   Data.Functor.Identity.Identity)
                                                              $dMonoid
                                                              $dApplicative
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fApplicativeWriterT_$cpure
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorExceptT @ Identity _" [orphan] forall @ e
                                                                                                (v :: GHC.Base.Functor
                                                                                                        Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fFunctorExceptT @ Data.Functor.Identity.Identity
                                              @ e
                                              v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorStateT @ (SupplyT
                                                                     (WriterT
                                                                        MultipleErrors
                                                                        (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                      (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorStateT_$cfmap @ (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors))
                                                        @ s
                                                        $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorSupplyT @ (WriterT
                                                                      MultipleErrors
                                                                      (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fFunctorSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                             Language.PureScript.Errors.MultipleErrors
                                             (Control.Monad.Trans.Except.Except
                                                Language.PureScript.Errors.MultipleErrors))
                                        v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT @ (ExceptT
                                                                      MultipleErrors Identity) _" [orphan] forall @ w
                                                                                                                                                                                               (v :: GHC.Base.Functor
                                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                          Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        Data.Functor.Identity.Identity)
                                                   @ w
                                                   v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT_$c<$ @ (ExceptT
                                                                           MultipleErrors
                                                                           Identity) _" [orphan] forall @ w
                                                                                                                                                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                       Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             Data.Functor.Identity.Identity)
                                                        @ w
                                                        $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fFunctorWriterT_$c<$
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fFunctorWriterT_$cfmap @ (ExceptT
                                                                             MultipleErrors
                                                                             Identity) _" [orphan] forall @ w
                                                                                                                                                                                                                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                             Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                               Language.PureScript.Errors.MultipleErrors
                                                               Data.Functor.Identity.Identity)
                                                          @ w
                                                          $dFunctor
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fFunctorWriterT_$cfmap
      @ w
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadErroreStateT0 @ MultipleErrors @ (SupplyT
                                                                                           (WriterT
                                                                                              MultipleErrors
                                                                                              (Except
                                                                                                 MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (v :: Control.Monad.Error.Class.MonadError
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Error.Class.$fMonadErroreStateT0 @ Language.PureScript.Errors.MultipleErrors
                                                 @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT @ (SupplyT
                                                                   (WriterT
                                                                      MultipleErrors
                                                                      (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                              (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                               Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ (Control.Monad.Supply.SupplyT
                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Trans.Except.Except
                                                          Language.PureScript.Errors.MultipleErrors)))
                                               @ s
                                               v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>> @ (SupplyT
                                                                        (WriterT
                                                                           MultipleErrors
                                                                           (Except
                                                                              MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Supply.SupplyT
                                                         (Control.Monad.Trans.Writer.Lazy.WriterT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Trans.Except.Except
                                                               Language.PureScript.Errors.MultipleErrors)))
                                                    @ s
                                                    $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>> @ (WriterT
                                                                        MultipleErrors
                                                                        (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors))
                                                    @ s
                                                    $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>>= @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Supply.SupplyT
                                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Trans.Except.Except
                                                                Language.PureScript.Errors.MultipleErrors)))
                                                     @ s
                                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>=
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$c>>= @ (WriterT
                                                                         MultipleErrors
                                                                         (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                             ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                          Language.PureScript.Errors.MultipleErrors
                                                          (Control.Monad.Trans.Except.Except
                                                             Language.PureScript.Errors.MultipleErrors))
                                                     @ s
                                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$c>>=
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$cfail @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Supply.SupplyT
                                                           (Control.Monad.Trans.Writer.Lazy.WriterT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Trans.Except.Except
                                                                 Language.PureScript.Errors.MultipleErrors)))
                                                      @ s
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStateT_$cfail @ (WriterT
                                                                          MultipleErrors
                                                                          (Except MultipleErrors)) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                              (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           (Control.Monad.Trans.Except.Except
                                                              Language.PureScript.Errors.MultipleErrors))
                                                      @ s
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadStateT_$cfail
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadStatesStateT0 @ (SupplyT
                                                                          (WriterT
                                                                             MultipleErrors
                                                                             (Except
                                                                                MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.State.Class.$fMonadStatesStateT0 @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadSupplyStateT @ (SupplyT
                                                                         (WriterT
                                                                            MultipleErrors
                                                                            (Except
                                                                               MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (v :: Control.Monad.Supply.Class.MonadSupply
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Supply.Class.$fMonadSupplyStateT @ (Control.Monad.Supply.SupplyT
                                                      (Control.Monad.Trans.Writer.Lazy.WriterT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         (Control.Monad.Trans.Except.Except
                                                            Language.PureScript.Errors.MultipleErrors)))
                                                 @ s
                                                 v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadSupplyStateT
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadSupplyT @ (WriterT
                                                                    MultipleErrors
                                                                    (Except MultipleErrors))" [orphan] forall (v :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fMonadSupplyT @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                           Language.PureScript.Errors.MultipleErrors
                                           (Control.Monad.Trans.Except.Except
                                              Language.PureScript.Errors.MultipleErrors))
                                      v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterSupplyT @ MultipleErrors @ (WriterT
                                                                                           MultipleErrors
                                                                                           (Except
                                                                                              MultipleErrors))" [orphan] forall (v :: Control.Monad.Writer.Class.MonadWriter
                                                                                                                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Supply.$fMonadWriterSupplyT @ Language.PureScript.Errors.MultipleErrors
                                            @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                 Language.PureScript.Errors.MultipleErrors
                                                 (Control.Monad.Trans.Except.Except
                                                    Language.PureScript.Errors.MultipleErrors))
                                            v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT @ MultipleErrors @ (ExceptT
                                                                                     MultipleErrors
                                                                                     Identity)" [orphan] forall (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                            Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT @ Language.PureScript.Errors.MultipleErrors
                                                 @ (Control.Monad.Trans.Except.ExceptT
                                                      Language.PureScript.Errors.MultipleErrors
                                                      Data.Functor.Identity.Identity)
                                                 v
                                                 v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$c>> @ MultipleErrors @ (ExceptT
                                                                                          MultipleErrors
                                                                                          Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                               ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>> @ Language.PureScript.Errors.MultipleErrors
                                                      @ (Control.Monad.Trans.Except.ExceptT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           Data.Functor.Identity.Identity)
                                                      $dMonoid
                                                      $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$c>>= @ MultipleErrors @ (ExceptT
                                                                                           MultipleErrors
                                                                                           Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                   Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                  ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                 Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>>= @ Language.PureScript.Errors.MultipleErrors
                                                       @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            Data.Functor.Identity.Identity)
                                                       $dMonoid
                                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$c>>=
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterT_$cfail @ MultipleErrors @ (ExceptT
                                                                                            MultipleErrors
                                                                                            Identity)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                      Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                     ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$cfail @ Language.PureScript.Errors.MultipleErrors
                                                        @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             Data.Functor.Identity.Identity)
                                                        $dMonoid
                                                        $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeStateT_$s$fMonadWriterT_$cfail
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterwStateT0 @ MultipleErrors @ (SupplyT
                                                                                            (WriterT
                                                                                               MultipleErrors
                                                                                               (Except
                                                                                                  MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (v :: Control.Monad.Writer.Class.MonadWriter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Writer.Class.$fMonadWriterwStateT0 @ Language.PureScript.Errors.MultipleErrors
                                                   @ (Control.Monad.Supply.SupplyT
                                                        (Control.Monad.Trans.Writer.Lazy.WriterT
                                                           Language.PureScript.Errors.MultipleErrors
                                                           (Control.Monad.Trans.Except.Except
                                                              Language.PureScript.Errors.MultipleErrors)))
                                                   @ s
                                                   v
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterwStateT0
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch $fMonadWriterwWriterT0 @ MultipleErrors @ (ExceptT
                                                                                             MultipleErrors
                                                                                             Identity)" [orphan] forall (v1 :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                    Data.Functor.Identity.Identity))
                                                                                                                                                                                                                                                                                                                                        (v :: GHC.Base.Monoid
                                                                                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Writer.Class.$fMonadWriterwWriterT0 @ Language.PureScript.Errors.MultipleErrors
                                                    @ (Control.Monad.Trans.Except.ExceptT
                                                         Language.PureScript.Errors.MultipleErrors
                                                         Data.Functor.Identity.Identity)
                                                    v
                                                    v1
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$s$fMonadWriterwWriterT0
"SPEC/Language.PureScript.TypeChecker.TypeSearch $w$c<*> @ Identity _" [orphan] [0] forall @ e
                                                                                           (w :: GHC.Base.Monad
                                                                                                   Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$w$c<*> @ Data.Functor.Identity.Identity
                                     @ e
                                     w
  = Language.PureScript.TypeChecker.TypeSearch.$s$fApplicativeExceptT_$c<*>_$s$w$c<*>
      @ e
"SPEC/Language.PureScript.TypeChecker.TypeSearch listen @ (ExceptT
                                                            MultipleErrors Identity) _ _" [orphan] forall @ w
                                                                                                                                                                             @ a
                                                                                                                                                                             ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                              Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.listen @ (Control.Monad.Trans.Except.ExceptT
                                              Language.PureScript.Errors.MultipleErrors
                                              Data.Functor.Identity.Identity)
                                         @ w
                                         @ a
                                         $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$slisten
      @ w
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch pass @ (ExceptT
                                                          MultipleErrors Identity) _ _" [orphan] forall @ w
                                                                                                                                                                         @ a
                                                                                                                                                                         ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                          Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.pass @ (Control.Monad.Trans.Except.ExceptT
                                            Language.PureScript.Errors.MultipleErrors
                                            Data.Functor.Identity.Identity)
                                       @ w
                                       @ a
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$spass
      @ w
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch put @ (SupplyT
                                                         (WriterT
                                                            MultipleErrors
                                                            (Except MultipleErrors))) _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                      ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                       (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                          Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.put @ (Control.Monad.Supply.SupplyT
                                          (Control.Monad.Trans.Writer.Lazy.WriterT
                                             Language.PureScript.Errors.MultipleErrors
                                             (Control.Monad.Trans.Except.Except
                                                Language.PureScript.Errors.MultipleErrors)))
                                     @ s
                                     $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sput
      @ s
"SPEC/Language.PureScript.TypeChecker.TypeSearch state @ (SupplyT
                                                           (WriterT
                                                              MultipleErrors
                                                              (Except MultipleErrors))) _ _" [orphan] forall @ s
                                                                                                                                                                                                                                                                                                                                @ a
                                                                                                                                                                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                                                                                              (Control.Monad.Supply.SupplyT
                                                                                                                                                                                                                                                                                                                                                 (Control.Monad.Trans.Writer.Lazy.WriterT
                                                                                                                                                                                                                                                                                                                                                    Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                                                                    (Control.Monad.Trans.Except.Except
                                                                                                                                                                                                                                                                                                                                                       Language.PureScript.Errors.MultipleErrors))))
  Control.Monad.Trans.State.Lazy.state @ (Control.Monad.Supply.SupplyT
                                            (Control.Monad.Trans.Writer.Lazy.WriterT
                                               Language.PureScript.Errors.MultipleErrors
                                               (Control.Monad.Trans.Except.Except
                                                  Language.PureScript.Errors.MultipleErrors)))
                                       @ s
                                       @ a
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadStatesStateT0_$sstate
      @ s
      @ a
"SPEC/Language.PureScript.TypeChecker.TypeSearch tell @ (ExceptT
                                                          MultipleErrors Identity) _" [orphan] forall @ w
                                                                                                                                                                       ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                        Data.Functor.Identity.Identity))
  Control.Monad.Trans.Writer.Lazy.tell @ (Control.Monad.Trans.Except.ExceptT
                                            Language.PureScript.Errors.MultipleErrors
                                            Data.Functor.Identity.Identity)
                                       @ w
                                       $dMonad
  = Language.PureScript.TypeChecker.TypeSearch.$s$fMonadWriterSupplyT_$stell
      @ w
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

