
==================== FINAL INTERFACE ====================
2018-11-30 19:26:20.864231 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Parser.Lexer 8043
  interface hash: 1285ed518d2deb0304c23981b1a1738f
  ABI hash: db153cafc807e1fa539fece18593da12
  export-list hash: 698a81285a16040f24e674c5083daf63
  orphan hash: 5f12766412f095ea0efd146f2ca444cb
  flag hash: af801e39deabea4814ba66209bc490c9
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Parser.Lexer.anyToken
  Language.PureScript.Parser.Lexer.at
  Language.PureScript.Parser.Lexer.braces
  Language.PureScript.Parser.Lexer.charLiteral
  Language.PureScript.Parser.Lexer.colon
  Language.PureScript.Parser.Lexer.comma
  Language.PureScript.Parser.Lexer.commaSep
  Language.PureScript.Parser.Lexer.commaSep1
  Language.PureScript.Parser.Lexer.dconsname
  Language.PureScript.Parser.Lexer.dot
  Language.PureScript.Parser.Lexer.doubleColon
  Language.PureScript.Parser.Lexer.equals
  Language.PureScript.Parser.Lexer.holeLit
  Language.PureScript.Parser.Lexer.identifier
  Language.PureScript.Parser.Lexer.indent
  Language.PureScript.Parser.Lexer.indentAt
  Language.PureScript.Parser.Lexer.isSymbolChar
  Language.PureScript.Parser.Lexer.isUnquotedKey
  Language.PureScript.Parser.Lexer.kiname
  Language.PureScript.Parser.Lexer.larrow
  Language.PureScript.Parser.Lexer.lbrace
  Language.PureScript.Parser.Lexer.lex
  Language.PureScript.Parser.Lexer.lexLenient
  Language.PureScript.Parser.Lexer.lfatArrow
  Language.PureScript.Parser.Lexer.lname
  Language.PureScript.Parser.Lexer.lname'
  Language.PureScript.Parser.Lexer.lparen
  Language.PureScript.Parser.Lexer.lsquare
  Language.PureScript.Parser.Lexer.match
  Language.PureScript.Parser.Lexer.mname
  Language.PureScript.Parser.Lexer.natural
  Language.PureScript.Parser.Lexer.number
  Language.PureScript.Parser.Lexer.parens
  Language.PureScript.Parser.Lexer.pipe
  Language.PureScript.Parser.Lexer.qualifier
  Language.PureScript.Parser.Lexer.rarrow
  Language.PureScript.Parser.Lexer.rbrace
  Language.PureScript.Parser.Lexer.reserved
  Language.PureScript.Parser.Lexer.reservedPsNames
  Language.PureScript.Parser.Lexer.reservedTypeNames
  Language.PureScript.Parser.Lexer.rfatArrow
  Language.PureScript.Parser.Lexer.rparen
  Language.PureScript.Parser.Lexer.rsquare
  Language.PureScript.Parser.Lexer.semi
  Language.PureScript.Parser.Lexer.semiSep
  Language.PureScript.Parser.Lexer.semiSep1
  Language.PureScript.Parser.Lexer.squares
  Language.PureScript.Parser.Lexer.stringLiteral
  Language.PureScript.Parser.Lexer.symbol
  Language.PureScript.Parser.Lexer.symbol'
  Language.PureScript.Parser.Lexer.tick
  Language.PureScript.Parser.Lexer.token
  Language.PureScript.Parser.Lexer.tyname
  Language.PureScript.Parser.Lexer.uname
  Language.PureScript.Parser.Lexer.uname'
  Language.PureScript.Parser.Lexer.underscore
  Language.PureScript.Parser.Lexer.PositionedToken{Language.PureScript.Parser.Lexer.PositionedToken ptComments ptEndPos ptPrevEndPos ptSourcePos ptToken}
  Language.PureScript.Parser.Lexer.Token
  Language.PureScript.Parser.Lexer.TokenParser
module dependencies: Language.PureScript.Comments
                     Language.PureScript.PSString Language.PureScript.Parser.State
package dependencies: aeson-1.3.1.1 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1 mtl-2.2.2
                      parsec-3.1.13.0 pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      scientific-0.3.6.2 tagged-0.8.5 template-haskell-2.13.0.0
                      text-1.2.3.0 th-abstraction-0.2.8.0 time-1.8.0.2
                      time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Char 3e89818e2b8ef1a2cc5393163484da72
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.String 1b97cff5f9627e73898d75997a9ccf7f
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Enum 8824828888f5a89ecc9e7c73f05f3151
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:GHC.Unicode 8234c40b59f035e845832a42e8725a00
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  mtl-2.2.2:Control.Monad.Identity ca9e9b9bfa404d3d70994a432bbadd6d
import  -/  parsec-3.1.13.0:Text.Parsec 963cbe7b4116cef91451434dc005a011
import  -/  parsec-3.1.13.0:Text.Parsec.Char aba0ba8aa7079b551caee8be42722b1b
import  -/  parsec-3.1.13.0:Text.Parsec.Combinator 86d872425bd48a2d67c0d1ce1a8ccc8b
import  -/  parsec-3.1.13.0:Text.Parsec.Error 5c35aa426bd1cd52bcab90d9a1e3ce4c
import  -/  parsec-3.1.13.0:Text.Parsec.Pos 85d30a347a2120f1b5f286869826a471
import  -/  parsec-3.1.13.0:Text.Parsec.Prim 4e0ad30f54008188b8c54f509e1a8ed9
import  -/  parsec-3.1.13.0:Text.Parsec.Token 71c800868101599a8d0258126c4abc48
import  -/  Language.PureScript.Comments f344ceddf328cf61908be13dd1f90917
  exports: b1904caad26a3e7c6a77f0a1156c2d62
  BlockComment 56a2d8503f61997599d67d66af903973
  Comment 23fbbb637db19d35ca8339b51dc9ecf5
  LineComment 3d180da6caa446540062bbf9a8d088fc
import  -/  Language.PureScript.PSString 29492f728997dffadb84d1bf161f2ce4
  exports: 41608caf7cc5b51f34de641c9952ab6d
  PSString 0c2d9eac7fc8cff2b3ca27abf6053439
import  -/  Language.PureScript.Parser.State fe9f4bd063cadaf6e6254f56db69a432
  exports: d5f29085816fb1aaafdee8f3aac13901
  ParseState 5abb98cffc35c1788f12e72c56b8d4dd
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  text-1.2.3.0:Data.Text.Show 3b4b6fb2985a731022d67f636682da2b
015da505ab7d9bcbf17b066347ec1288
  $fEqPositionedToken ::
    GHC.Classes.Eq Language.PureScript.Parser.Lexer.PositionedToken
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.PositionedToken
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c/= -}
015da505ab7d9bcbf17b066347ec1288
  $fEqPositionedToken_$c/= ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,1*U,1*U)><S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (y :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
015da505ab7d9bcbf17b066347ec1288
  $fEqPositionedToken_$c== ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,1*U,1*U)><S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,U,1*U)>,
     Unfolding: (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (ds1 :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken a1 a2 a3 a4 a5 ->
                 case ds1 of wild1 { Language.PureScript.Parser.Lexer.PositionedToken b1 b2 b3 b4 b5 ->
                 case a1 of ww { Text.Parsec.Pos.SourcePos ww1 ww2 ww3 ->
                 case b1 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 case GHC.Base.eqString ww1 ww5 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Prim.==# ww2 ww6 of lwild {
                        DEFAULT -> GHC.Types.False
                        1#
                        -> case GHC.Prim.==# ww3 ww7 of lwild1 {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case a2 of ww11 { Text.Parsec.Pos.SourcePos ww12 ww13 ww14 ->
                                case b2 of ww15 { Text.Parsec.Pos.SourcePos ww16 ww17 ww18 ->
                                case GHC.Base.eqString ww12 ww16 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Prim.==# ww13 ww17 of lwild2 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> case GHC.Prim.==# ww14 ww18 of lwild3 {
                                            DEFAULT -> GHC.Types.False
                                            1#
                                            -> let {
                                                 $j :: GHC.Types.Bool <join 0>
                                                 = case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                                                          a4
                                                          b4 of wild4 {
                                                     GHC.Types.False -> GHC.Types.False
                                                     GHC.Types.True
                                                     -> GHC.Classes.$fEq[]_$c==
                                                          @ Language.PureScript.Comments.Comment
                                                          Language.PureScript.Comments.$fEqComment
                                                          a5
                                                          b5 }
                                               } in
                                               case a3 of wild4 {
                                                 GHC.Base.Nothing
                                                 -> case b3 of wild5 {
                                                      GHC.Base.Nothing -> $j
                                                      GHC.Base.Just ipv -> GHC.Types.False }
                                                 GHC.Base.Just a7
                                                 -> case b3 of wild5 {
                                                      GHC.Base.Nothing -> GHC.Types.False
                                                      GHC.Base.Just b7
                                                      -> case a7 of ww19 { Text.Parsec.Pos.SourcePos ww20 ww21 ww22 ->
                                                         case b7 of ww23 { Text.Parsec.Pos.SourcePos ww24 ww25 ww26 ->
                                                         case GHC.Base.eqString ww20 ww24 of wild6 {
                                                           GHC.Types.False -> GHC.Types.False
                                                           GHC.Types.True
                                                           -> case GHC.Prim.==#
                                                                     ww21
                                                                     ww25 of lwild4 {
                                                                DEFAULT -> GHC.Types.False
                                                                1#
                                                                -> case GHC.Prim.==#
                                                                          ww22
                                                                          ww26 of lwild5 {
                                                                     DEFAULT -> GHC.Types.False
                                                                     1#
                                                                     -> $j } } } } } } } } } } } } } } } } } } }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fEqPositionedToken_$c==1 ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Language.PureScript.Parser.Lexer.Token)
                   (ds1 :: Language.PureScript.Parser.Lexer.Token) ->
                 case ds of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             wild of a# { DEFAULT ->
                      case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             ds1 of b# { DEFAULT ->
                      GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# a# b#) } }
                   Language.PureScript.Parser.Lexer.Indent a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Indent b1
                        -> GHC.Classes.eqInt a1 b1 }
                   Language.PureScript.Parser.Lexer.LName a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.LName b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.UName a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.UName b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.Qualifier a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Qualifier b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.Symbol a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Symbol b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.CharLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.CharLiteral b1
                        -> GHC.Classes.eqChar a1 b1 }
                   Language.PureScript.Parser.Lexer.StringLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.StringLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ GHC.Word.Word16
                             GHC.Word.$fEqWord16
                             a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.Parser.Lexer.Number a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Number b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.eqInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.False }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.False
                                  Data.Either.Right b2 -> GHC.Classes.eqDouble a2 b2 } } }
                   Language.PureScript.Parser.Lexer.HoleLit a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.HoleLit b1
                        -> Data.Text.$fEqText_$c== a1 b1 } }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fEqToken :: GHC.Classes.Eq Language.PureScript.Parser.Lexer.Token
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                  Language.PureScript.Parser.Lexer.$fEqToken_$c/= -}
bd047d26d792e100b7cef064aba1e7f6
  $fEqToken_$c/= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken ::
    GHC.Classes.Ord Language.PureScript.Parser.Lexer.Token
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fEqToken
                  Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c<
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c<=
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c>
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c>=
                  Language.PureScript.Parser.Lexer.$fOrdToken_$cmax
                  Language.PureScript.Parser.Lexer.$fOrdToken_$cmin -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$c< ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$c<= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$c> ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$c>= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$ccompare ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (a :: Language.PureScript.Parser.Lexer.Token)
                   (b :: Language.PureScript.Parser.Lexer.Token) ->
                 case a of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             wild of a# { DEFAULT ->
                      case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.EQ }
                        1# -> GHC.Types.LT } } }
                   Language.PureScript.Parser.Lexer.Indent a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.># b# 6# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.GT
                             Language.PureScript.Parser.Lexer.Indent b1
                             -> GHC.Classes.compareInt a1 b1 }
                        1# -> GHC.Types.LT } }
                   Language.PureScript.Parser.Lexer.LName a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 21# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.LName b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.UName a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 22# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.UName b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Qualifier a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 23# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.Qualifier b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Symbol a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 24# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.Symbol b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.CharLiteral a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 25# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.CharLiteral b1
                             -> GHC.Classes.$fOrdChar_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.StringLiteral a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 26# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.StringLiteral b1
                             -> GHC.Classes.$fOrd[]_$ccompare
                                  @ GHC.Word.Word16
                                  GHC.Word.$fOrdWord16
                                  a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                                  b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Number a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.Parser.Lexer.Number b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.compareInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.LT }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.GT
                                  Data.Either.Right b2
                                  -> GHC.Classes.$fOrdDouble_$ccompare a2 b2 } }
                        Language.PureScript.Parser.Lexer.HoleLit ds -> GHC.Types.LT }
                   Language.PureScript.Parser.Lexer.HoleLit a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.Parser.Lexer.HoleLit b1
                        -> Data.Text.$fOrdText_$ccompare a1 b1 } }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$cmax ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fOrdToken_$cmin ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
015da505ab7d9bcbf17b066347ec1288
  $fShowPositionedToken ::
    GHC.Show.Show Language.PureScript.Parser.Lexer.PositionedToken
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.PositionedToken
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshowsPrec
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshow
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshowList -}
015da505ab7d9bcbf17b066347ec1288
  $fShowPositionedToken1 ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$w$cshowsPrec ww4 w1 }) -}
015da505ab7d9bcbf17b066347ec1288
  $fShowPositionedToken_$cshow ::
    Language.PureScript.Parser.Lexer.PositionedToken -> GHC.Base.String
  {- Arity: 1, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case w of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$wlvl ww4 }) -}
015da505ab7d9bcbf17b066347ec1288
  $fShowPositionedToken_$cshowList ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   Language.PureScript.Parser.Lexer.$fShowPositionedToken1
                   ls
                   s) -}
015da505ab7d9bcbf17b066347ec1288
  $fShowPositionedToken_$cshowsPrec ::
    GHC.Types.Int
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(LLLSL),1*U(A,A,A,1*U,A)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$w$cshowsPrec ww4 w2 }) -}
bd047d26d792e100b7cef064aba1e7f6
  $fShowToken :: GHC.Show.Show Language.PureScript.Parser.Lexer.Token
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshowsPrec
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshow
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshowList -}
bd047d26d792e100b7cef064aba1e7f6
  $fShowToken1 ::
    Language.PureScript.Parser.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Language.PureScript.Parser.Lexer.$fShowToken_$cshowsPrec
                   Language.PureScript.Parser.Lexer.$fShowToken2) -}
5e505a603f73bf99d7c5f19b80663cce
  $fShowToken2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
bd047d26d792e100b7cef064aba1e7f6
  $fShowToken_$cshow ::
    Language.PureScript.Parser.Lexer.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
bd047d26d792e100b7cef064aba1e7f6
  $fShowToken_$cshowList ::
    [Language.PureScript.Parser.Lexer.Token] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.PureScript.Parser.Lexer.Token])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.PureScript.Parser.Lexer.Token
                   Language.PureScript.Parser.Lexer.$fShowToken1
                   ls
                   s) -}
bd047d26d792e100b7cef064aba1e7f6
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
47f8af10320b9ce10a88bcffda57b16b
  $s$fStreamTextmChar0 ::
    Text.Parsec.Prim.Stream
      Data.Text.Internal.Text
      Data.Functor.Identity.Identity
      GHC.Types.Char
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Text.Internal.Text
                  @ Data.Functor.Identity.Identity
                  @ GHC.Types.Char
                  Data.Functor.Identity.$fMonadIdentity
                  Data.Text.uncons
                    `cast`
                  (<Data.Text.Internal.Text>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <GHC.Base.Maybe (GHC.Types.Char, Data.Text.Internal.Text)>_R)) -}
5d264a21783577a63cba494703fb8a6d
  $tc'At :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4825256484276802911##
                   1186418041156539651##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'At2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
6804bce58a055a34572debb7bbc24b43
  $tc'At1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
b3e47c540b839362f1375fd42df4b49a
  $tc'At2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'At3) -}
9a88e8695f7f42945d12e121e5f1129a
  $tc'At3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'At"#) -}
ee4ddeda56351a997190eb30786b85af
  $tc'CharLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6369025317835700718##
                   17385186398039997676##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral1) -}
d5fa34d327b2516932bbadd5c7f33eba
  $tc'CharLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1726d7aae26f66aeb834e6e08538dcc6
  $tc'CharLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral3) -}
39c0be12508d1ee55961e4679e1a1c36
  $tc'CharLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CharLiteral"#) -}
31ae10ef55804dcded6ddb56db336430
  $tc'Colon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   170641842506057955##
                   3798811829504318244##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Colon1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
de5a899b5b69e46406af0c669e3537e1
  $tc'Colon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Colon2) -}
120789a50715d6670107d9527364bd4a
  $tc'Colon2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Colon"#) -}
163440672c0622b3c352e4f4b5be2c67
  $tc'Comma :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6879181057176157839##
                   15172798233198646924##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Comma1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
bab0a19766dfa536a7616dc96a418e28
  $tc'Comma1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Comma2) -}
da9ed184bb0b5fc7ddf00f334b905a86
  $tc'Comma2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Comma"#) -}
fce55ebbefed2ad3d8d2b5ea72d5f83c
  $tc'Dot :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15908855724737204847##
                   7006264868664351847##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Dot1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
d8fbe703eac3a4ac0efde74766465f7a
  $tc'Dot1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Dot2) -}
25729a1ae1aa905047e4352bd03b0fd2
  $tc'Dot2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Dot"#) -}
1019302451610df3335b5cf59b6c01d5
  $tc'DoubleColon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14569612728607927755##
                   5015770571448346742##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'DoubleColon1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
e59b46cc6032752ae62ea54e2768088f
  $tc'DoubleColon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'DoubleColon2) -}
c7f360a641f23ddd41814fac96444da5
  $tc'DoubleColon2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DoubleColon"#) -}
c481f5d49454524e116eb77ed534bf79
  $tc'Equals :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5950097538850101066##
                   4560176795533544241##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Equals1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
113e6bc8d785f8ff5b0e4669b5d448cd
  $tc'Equals1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Equals2) -}
abbe39e8ccb8598462e7ee9ca05077dd
  $tc'Equals2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Equals"#) -}
73251fc765f3b026b5ec42b8855c247a
  $tc'HoleLit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9590475839940765219##
                   5832694102866250497##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'HoleLit2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
0fbda4ae34a41aaffb2cf7ad86f15651
  $tc'HoleLit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0154fea855bc34899e515dd73669f284
  $tc'HoleLit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'HoleLit3) -}
e5f5f4f691abc7da76bcf529d3f56610
  $tc'HoleLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HoleLit"#) -}
5c718ecdefca0580fb3bf175bc02de5c
  $tc'Indent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11374266953674061064##
                   10904810097649641190##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Indent2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'Indent1) -}
a7cef64b9c1594fbc964ca8fc1bd9471
  $tc'Indent1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c29be772c5c19615e5ade34bc608dd32
  $tc'Indent2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Indent3) -}
aa65179efcf245e6ade7959072494de8
  $tc'Indent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Indent"#) -}
a0aebfb217a81695acca34723d4ebf9c
  $tc'LArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4281039447634905749##
                   427774265848980310##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
2c71073301393e478af9c84cca84cea0
  $tc'LArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LArrow2) -}
85cf14f709ee3c8c2a9365d6d57c0892
  $tc'LArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LArrow"#) -}
427adb718e7f1c99bf77b600f68f431b
  $tc'LBrace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14762163265977163467##
                   10838168478245820767##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LBrace1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
1bcc03bd629990cc6680211b261889c7
  $tc'LBrace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LBrace2) -}
1892a3c2f8e0827331014a32bb8e81b3
  $tc'LBrace2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LBrace"#) -}
23059b36849135adc8a297d1926fe59b
  $tc'LFatArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10143925820286690944##
                   13527046124332283197##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LFatArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
b9bea10a9ef838f6858ac290afedf031
  $tc'LFatArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LFatArrow2) -}
6741d95c5b3400232aa286459c5290ff
  $tc'LFatArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LFatArrow"#) -}
c582d99b70c288a739a749ac670dac42
  $tc'LName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17455454314824032638##
                   2189920068116808596##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LName1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
4a7aeafe8686403cb0c7156cddb14cd7
  $tc'LName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LName2) -}
a7a1fe261b6cde83f766380af99b53cf
  $tc'LName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LName"#) -}
c6da1c532dc0720c9ab70bea2f062981
  $tc'LParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11804483152136121538##
                   1267062628421485346##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LParen1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
f94b190c716e5de18df7714775d67ebe
  $tc'LParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LParen2) -}
57cda29b87b30f3cbbc9b7886cf6d82e
  $tc'LParen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LParen"#) -}
15cb9e9b24c827ffeebe1adbe977caf4
  $tc'LSquare :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7111112289261722780##
                   15306383350376067515##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LSquare1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
37921b2a1506b0193356a18bd1254c6a
  $tc'LSquare1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LSquare2) -}
898d2be76b661ae9162ed7e8b5138b11
  $tc'LSquare2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LSquare"#) -}
1fb31b005590f41a15664c4862a86184
  $tc'Number :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13980756121172634560##
                   6351751161056935847##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Number2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'Number1) -}
bfb5cc693000ee6d9e3820f4f252e9bb
  $tc'Number1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e18cb23e78cd8241986deee1d8786ad
  $tc'Number2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Number3) -}
f3a01631d7219d534625fe3edf34b741
  $tc'Number3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Number"#) -}
617df29131156068d26069ea8f8d8ea7
  $tc'Pipe :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14295668258783665485##
                   6345422246562615032##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Pipe1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
bee72f2e0f6b0b1af4786e20d20e9572
  $tc'Pipe1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Pipe2) -}
3d2ab92847429537b32a0620760eeb5c
  $tc'Pipe2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pipe"#) -}
7f6adb739f53cb94d9dd1f1b6841c86e
  $tc'PositionedToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6168626870274449159##
                   15718907540511917263##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken1) -}
933f769f2288edc348d7ad1f5864b019
  $tc'PositionedToken1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
066adeedbcba650a15c8c9d8609a6df1
  $tc'PositionedToken2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken3) -}
0e5cfb37003e12472ae88be180d90b5f
  $tc'PositionedToken3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PositionedToken"#) -}
fd9f8a9094cb32c66656862b1b55b17e
  $tc'Qualifier :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12581281553191992626##
                   18313188663041754970##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Qualifier1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
1e69258d8a7c7a8a91e0a89080a2f93a
  $tc'Qualifier1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Qualifier2) -}
66502b0019c8211d9eda0cc36927869a
  $tc'Qualifier2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Qualifier"#) -}
03f103d5aa3fe3ec0b95e1399becb604
  $tc'RArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15965161592172920527##
                   477119402958296481##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
dc61fc6674aa0cd9c50eca62392caa1e
  $tc'RArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RArrow2) -}
8adc97335729d9eb25ae4c5637bfe991
  $tc'RArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RArrow"#) -}
1a9922a270469ab559dd8581f680d664
  $tc'RBrace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6577559692255839121##
                   10235302726756920755##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RBrace1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
74787c8221c03b463dec46850eef48e7
  $tc'RBrace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RBrace2) -}
77af05e45e8ed29dee3faacdbb6bfab4
  $tc'RBrace2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RBrace"#) -}
7f38fe1d50b4c96035191beaccf8bd93
  $tc'RFatArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9249426176596350366##
                   17881267997669696673##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RFatArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
e6a6dc7db69c6deb7cddefef17b998a6
  $tc'RFatArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RFatArrow2) -}
bbb1435b11dbc1c3a15f52caa3c3e5e7
  $tc'RFatArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RFatArrow"#) -}
122f3fae37fec2b693fc919d71aa7a41
  $tc'RParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11245796707080937239##
                   15569809805952245020##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RParen1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
010f475af68355ca78b6009c68f8b6a2
  $tc'RParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RParen2) -}
d49b026745a8da264d4808c5ac89f6d3
  $tc'RParen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RParen"#) -}
e9519874469653ab50ee0c089fde0635
  $tc'RSquare :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12755158892703817064##
                   667349655292319318##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RSquare1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
54be62e6f835df6a7ac15f1b1f40b614
  $tc'RSquare1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RSquare2) -}
03dd246807cd1f00d89bec6be2ccdbad
  $tc'RSquare2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RSquare"#) -}
bdee83270c5e01c6f3dc6b745f48a1c4
  $tc'Semi :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17285844636868255998##
                   12108959866373647369##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Semi1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
a9f8642df918cf0433e69c538b032cd7
  $tc'Semi1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Semi2) -}
611137bd2ee514551c1a4ac3a3ec5611
  $tc'Semi2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Semi"#) -}
dc9e8bae6ad640148ef7d0789852f147
  $tc'StringLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1724380479213364461##
                   11795376971580745399##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral1) -}
a3d5bbbb60a7b6274d488d57f11f89a5
  $tc'StringLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d9e262f4ab34972e7e75c0a33dac992f
  $tc'StringLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral3) -}
350b504a8706476f55b5b4cf206d476c
  $tc'StringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLiteral"#) -}
578b6ed8cddcb586ca405cc94af81e15
  $tc'Symbol :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6895844312697250710##
                   943404830619534075##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Symbol1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
4ad4e6691b31f48f8c54bf15f46977d8
  $tc'Symbol1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Symbol2) -}
ee9afd0e74baea2c7686e94a2aa9b06c
  $tc'Symbol2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Symbol"#) -}
31a4e43c0edf26f38f585530571c6b3f
  $tc'Tick :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   98347968134906999##
                   1775548205582855858##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Tick1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
12de45b8f270487f346306484d3edfdf
  $tc'Tick1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Tick2) -}
240a9025da80f76945488187bc82c5fe
  $tc'Tick2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Tick"#) -}
60ec61bba5cc1fff1f8484a30a472582
  $tc'UName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2276014857667896595##
                   8380059885609362029##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'UName1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
f066dbf49a22d0f7f582c2b34b644c75
  $tc'UName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'UName2) -}
0a09b24c75d88a92efad9b7f5ded7e6d
  $tc'UName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UName"#) -}
d8f84560e9fa1bd137a73736c3beed16
  $tc'Underscore :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7949021973321415607##
                   17955861965593579441##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Underscore1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
2097ae0e755e48ab2e6a6385ace6ded8
  $tc'Underscore1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Underscore2) -}
078ae44c421fd167adfc0bfb5d06eea0
  $tc'Underscore2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Underscore"#) -}
a21f8523d46eac2a18a696d8d41e4272
  $tcPositionedToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16572936776841242695##
                   14438001712840321729##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tcPositionedToken1
                   0#
                   GHC.Types.krep$*) -}
d697b3ca77920f37656a14bb8c189cf3
  $tcPositionedToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tcPositionedToken2) -}
6a4312fcbab9f67b486a1f6db21bd2fb
  $tcPositionedToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PositionedToken"#) -}
a58b532609cdf211b0411f8b2c94f143
  $tcToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3647884325230355178##
                   2311388212144293634##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tcToken1
                   0#
                   GHC.Types.krep$*) -}
09b13becc7cba0238848db14bbfb0577
  $tcToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tcToken2) -}
0e44d541a2ff5c44b64fbdfc4f65dad3
  $tcToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Token"#) -}
70c882f94d0d31907a373e4ff344beae
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Parser.Lexer.$trModule3
                   Language.PureScript.Parser.Lexer.$trModule1) -}
76607288f870a562212d24080a0fb378
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$trModule2) -}
7774b39405979ad9a9d6b15558b337ed
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.Parser.Lexer"#) -}
ba90e034ae944d3191f8f4bfa2d8eb05
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$trModule4) -}
8ed9f7be3c8b93631f6663ab54549398
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
8e3e1baa70240a3b5e4a31dfa26c6a94
  $w$cshowsPrec ::
    Language.PureScript.Parser.Lexer.Token
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Language.PureScript.Parser.Lexer.Token)
                   (w :: GHC.Base.String) ->
                 case Language.PureScript.Parser.Lexer.prettyPrintToken
                        ww of wild { Data.Text.Internal.Text dt6 dt7 dt8 ->
                 let {
                   end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                 } in
                 letrec {
                   $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww1 end of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexWord16Array# dt6 ww1 of r# { DEFAULT ->
                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ GHC.Types.Char
                                 (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                 ($wunfold (GHC.Prim.+# ww1 1#))
                            1#
                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                      ($wunfold (GHC.Prim.+# ww1 1#))
                                 1#
                                 -> case GHC.Prim.indexWord16Array#
                                           dt6
                                           (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C#
                                         (GHC.Prim.chr#
                                            (GHC.Prim.+#
                                               (GHC.Prim.+#
                                                  (GHC.Prim.uncheckedIShiftL#
                                                     (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                     10#)
                                                  (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                               65536#)))
                                      ($wunfold (GHC.Prim.+# ww1 2#)) } } } }
                       1# -> GHC.Types.[] @ GHC.Types.Char }
                 } in
                 GHC.Base.++ @ GHC.Types.Char ($wunfold dt7) w }) -}
5d28c49582c2a1fb55a7a09f5a3c74a2
  $w$j :: GHC.Prim.Char# -> Data.Text.Internal.Text -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U)>, Inline: [0] -}
54a9dcc20dd9bd7397c7a43f56bb43ab
  $wanyToken ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Parser.Lexer.PositionedToken
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case ts of wild1 {
                        []
                        -> case t of wild2 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                           case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           w wild2
                             (Text.Parsec.Prim.State
                                @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                @ Language.PureScript.Parser.State.ParseState
                                (GHC.Types.[] @ Language.PureScript.Parser.Lexer.PositionedToken)
                                v
                                ww2)
                             (Text.Parsec.Error.ParseError
                                v
                                (GHC.Types.[] @ Text.Parsec.Error.Message)) } }
                        : t1 ts1
                        -> case t1 of wild2 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                           case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           w t
                             (Text.Parsec.Prim.State
                                @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                @ Language.PureScript.Parser.State.ParseState
                                wild1
                                v
                                ww2)
                             (Text.Parsec.Error.ParseError
                                v
                                (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } }) -}
9b755d6aab08796ed7b46ddf01609b11
  $wisUnquotedKey ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#) ->
                 case GHC.Prim.<=# ww2 0# of lwild {
                   DEFAULT
                   -> case GHC.Prim.indexWord16Array# ww ww1 of r# { DEFAULT ->
                      case GHC.Prim.ltWord# r# 55296## of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.indexWord16Array#
                                       ww
                                       (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                Language.PureScript.Parser.Lexer.$w$j
                                  (GHC.Prim.chr#
                                     (GHC.Prim.+#
                                        (GHC.Prim.+#
                                           (GHC.Prim.uncheckedIShiftL#
                                              (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                              10#)
                                           (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                        65536#))
                                  (case ww2 of lwild3 {
                                     DEFAULT
                                     -> Data.Text.Internal.Text
                                          ww
                                          (GHC.Prim.+# ww1 2#)
                                          (GHC.Prim.-# lwild3 2#)
                                     2# -> Data.Text.Internal.empty }) }
                             1#
                             -> Language.PureScript.Parser.Lexer.$w$j
                                  (GHC.Prim.chr# (GHC.Prim.word2Int# r#))
                                  (case ww2 of lwild3 {
                                     DEFAULT
                                     -> Data.Text.Internal.Text
                                          ww
                                          (GHC.Prim.+# ww1 1#)
                                          (GHC.Prim.-# lwild3 1#)
                                     1# -> Data.Text.Internal.empty }) }
                        1#
                        -> Language.PureScript.Parser.Lexer.$w$j
                             (GHC.Prim.chr# (GHC.Prim.word2Int# r#))
                             (case ww2 of lwild2 {
                                DEFAULT
                                -> Data.Text.Internal.Text
                                     ww
                                     (GHC.Prim.+# ww1 1#)
                                     (GHC.Prim.-# lwild2 1#)
                                1# -> Data.Text.Internal.empty }) } }
                   1# -> GHC.Types.False }) -}
7160c44994ecdd32f2d0300f007a1801
  $wlvl :: Language.PureScript.Parser.Lexer.Token -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.prettyPrintToken
                        ww of wild { Data.Text.Internal.Text dt6 dt7 dt8 ->
                 let {
                   end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                 } in
                 letrec {
                   $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww1 end of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexWord16Array# dt6 ww1 of r# { DEFAULT ->
                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ GHC.Types.Char
                                 (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                 ($wunfold (GHC.Prim.+# ww1 1#))
                            1#
                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                      ($wunfold (GHC.Prim.+# ww1 1#))
                                 1#
                                 -> case GHC.Prim.indexWord16Array#
                                           dt6
                                           (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C#
                                         (GHC.Prim.chr#
                                            (GHC.Prim.+#
                                               (GHC.Prim.+#
                                                  (GHC.Prim.uncheckedIShiftL#
                                                     (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                     10#)
                                                  (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                               65536#)))
                                      ($wunfold (GHC.Prim.+# ww1 2#)) } } } }
                       1# -> GHC.Types.[] @ GHC.Types.Char }
                 } in
                 $wunfold dt7 }) -}
3f17bd5508e51ca1565fb1d0017581e8
  $wp ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Types.Char
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.CharLiteral c
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w c
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w c
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
5f427c66cae1f2ccfbb0528e9fd3ff0b
  $wp1 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.UName s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
037756f092e1cb92601531832511e66f
  $wp10 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.PSString.PSString
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.StringLiteral s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
f098b1df9a58ad8894097826ea857aec
  $wp11 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Text.Internal.Text -> Data.Functor.Identity.Identity b
                          <join 1> {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: Data.Text.Internal.Text)[OneShot] ->
                          case ts of wild2 {
                            []
                            -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                               w x
                                 (Text.Parsec.Prim.State
                                    @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                    @ Language.PureScript.Parser.State.ParseState
                                    (GHC.Types.[]
                                       @ Language.PureScript.Parser.Lexer.PositionedToken)
                                    v
                                    ww2)
                                 (Text.Parsec.Error.ParseError
                                    v
                                    (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                            : t1 ts1
                            -> case t1 of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                               case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                               w x
                                 (Text.Parsec.Prim.State
                                    @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                    @ Language.PureScript.Parser.State.ParseState
                                    wild2
                                    v
                                    ww2)
                                 (Text.Parsec.Error.ParseError
                                    v
                                    (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                      } in
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.LFatArrow
                        -> $j Language.PureScript.Parser.Lexer.symbol9
                        Language.PureScript.Parser.Lexer.Colon
                        -> $j Language.PureScript.Parser.Lexer.symbol7
                        Language.PureScript.Parser.Lexer.At
                        -> $j Language.PureScript.Parser.Lexer.symbol5
                        Language.PureScript.Parser.Lexer.Symbol s -> $j s } } }) -}
39030b512683b177103290dbcde665de
  $wp12 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.UName s
                        -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                           let {
                             end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                           } in
                           let {
                             exit :: Data.Functor.Identity.Identity b <join 0>
                             = case ts of wild4 {
                                 []
                                 -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         (GHC.Types.[]
                                            @ Language.PureScript.Parser.Lexer.PositionedToken)
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                 : t1 ts1
                                 -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                    case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         wild4
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                           } in
                           letrec {
                             $wloop_any :: GHC.Prim.Int# -> Data.Functor.Identity.Identity b
                               <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                             = \ (ww3 :: GHC.Prim.Int#) ->
                               case GHC.Prim.>=# ww3 end of lwild {
                                 DEFAULT
                                 -> case GHC.Prim.indexWord16Array# dt6 ww3 of r# { DEFAULT ->
                                    case GHC.Prim.geWord# r# 55296## of lwild1 {
                                      DEFAULT
                                      -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                           DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#) '\''# -> $j }
                                      1#
                                      -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                           DEFAULT
                                           -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#)
                                                '\''# -> $j }
                                           1#
                                           -> case GHC.Prim.indexWord16Array#
                                                     dt6
                                                     (GHC.Prim.+# ww3 1#) of r#1 { DEFAULT ->
                                              case GHC.Prim.chr#
                                                     (GHC.Prim.+#
                                                        (GHC.Prim.+#
                                                           (GHC.Prim.uncheckedIShiftL#
                                                              (GHC.Prim.-#
                                                                 (GHC.Prim.word2Int# r#)
                                                                 55296#)
                                                              10#)
                                                           (GHC.Prim.-#
                                                              (GHC.Prim.word2Int# r#1)
                                                              56320#))
                                                        65536#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 2#)
                                                '\''# -> $j } } } } }
                                 1# -> exit }
                           } in
                           $wloop_any dt7 } } } }) -}
d02e4fd4867070d24e0ffdfde9eb4eee
  $wp2 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.HoleLit n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
b0b80d701984261299c44cf252f5d65d
  $wp3 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.LName s
                        -> case GHC.List.elem
                                  @ Data.Text.Internal.Text
                                  Data.Text.$fEqText
                                  s
                                  Language.PureScript.Parser.Lexer.reservedPsNames of wild3 {
                             GHC.Types.False
                             -> case ts of wild4 {
                                  []
                                  -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w s
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          (GHC.Types.[]
                                             @ Language.PureScript.Parser.Lexer.PositionedToken)
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                  : t1 ts1
                                  -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                     case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w s
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          wild4
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                             GHC.Types.True -> $j } } } }) -}
b4ccc824117bda2f1d3684fd466299e7
  $wp4 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Types.Int
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Indent n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
4e65996852710124c5bac6bffefb8f4a
  $wp5 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.LName s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
2d7d6603fc822d09d669faf5229f1cc9
  $wp6 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.UName s
                        -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                           let {
                             end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                           } in
                           let {
                             exit :: Data.Functor.Identity.Identity b <join 0>
                             = case ts of wild4 {
                                 []
                                 -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         (GHC.Types.[]
                                            @ Language.PureScript.Parser.Lexer.PositionedToken)
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                 : t1 ts1
                                 -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                    case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         wild4
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                           } in
                           letrec {
                             $wloop_any :: GHC.Prim.Int# -> Data.Functor.Identity.Identity b
                               <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                             = \ (ww3 :: GHC.Prim.Int#) ->
                               case GHC.Prim.>=# ww3 end of lwild {
                                 DEFAULT
                                 -> case GHC.Prim.indexWord16Array# dt6 ww3 of r# { DEFAULT ->
                                    case GHC.Prim.geWord# r# 55296## of lwild1 {
                                      DEFAULT
                                      -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                           DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#) '_'# -> $j }
                                      1#
                                      -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                           DEFAULT
                                           -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#)
                                                '_'# -> $j }
                                           1#
                                           -> case GHC.Prim.indexWord16Array#
                                                     dt6
                                                     (GHC.Prim.+# ww3 1#) of r#1 { DEFAULT ->
                                              case GHC.Prim.chr#
                                                     (GHC.Prim.+#
                                                        (GHC.Prim.+#
                                                           (GHC.Prim.uncheckedIShiftL#
                                                              (GHC.Prim.-#
                                                                 (GHC.Prim.word2Int# r#)
                                                                 55296#)
                                                              10#)
                                                           (GHC.Prim.-#
                                                              (GHC.Prim.word2Int# r#1)
                                                              56320#))
                                                        65536#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 2#)
                                                '_'# -> $j } } } } }
                                 1# -> exit }
                           } in
                           $wloop_any dt7 } } } }) -}
cd9fdb4440376d53234c1d4769daa617
  $wp7 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Integer.Type.Integer
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.Number ds5
                        -> case ds5 of wild3 {
                             Data.Either.Left n
                             -> case ts of wild4 {
                                  []
                                  -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w n
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          (GHC.Types.[]
                                             @ Language.PureScript.Parser.Lexer.PositionedToken)
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                  : t1 ts1
                                  -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds6 ds7 ds8 ds9 ds10 ->
                                     case ds6 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w n
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          wild4
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                             Data.Either.Right ipv -> $j } } } }) -}
c471970ff8072df8adcfc22e1c957d13
  $wp8 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Number n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
96453183267fecdc26035817f96c4f55
  $wp9 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Qualifier s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
f0209d07a7ea3c557797b08cb5c216fb
  $wparseComment ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0] -}
78035d6fc8edd06f4ff414fc38ccba50
  $wparsePositionedToken ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wmany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   (Language.PureScript.Parser.Lexer.lex5 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   @ b
                   w
                   (\ (x :: [Language.PureScript.Comments.Comment])
                      (s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    Language.PureScript.Parser.Lexer.lex12
                      @ u
                      x
                      @ b
                      s2
                      w1
                      w3
                      (\ (x1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                         (s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                         (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                       w1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w3 (Text.Parsec.Error.mergeError err err')))
                   w3
                   (\ (x :: [Language.PureScript.Comments.Comment])
                      (s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    Language.PureScript.Parser.Lexer.lex12
                      @ u
                      x
                      @ b
                      s2
                      w1
                      w3
                      (\ (x1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                         (s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                         (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                       w2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w3 (Text.Parsec.Error.mergeError err err')))) -}
0970b4077b0649374d0a2b7ccb426649
  $wtoken ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> forall b.
       [Language.PureScript.Parser.Lexer.PositionedToken]
       -> Text.Parsec.Pos.SourcePos
       -> Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
                   @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w1 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w2 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case w (case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                              ds3 }) of wild2 {
                        GHC.Base.Nothing
                        -> w2
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case t of ww3 { Language.PureScript.Parser.Lexer.PositionedToken ww4 ww5 ww6 ww7 ww8 ->
                                    case Language.PureScript.Parser.Lexer.$wlvl
                                           ww7 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 } })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        GHC.Base.Just x
                        -> case ts of wild1 {
                             []
                             -> case t of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                                case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w1
                                  x
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } }
                             : t1 ts1
                             -> case t1 of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                                case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w1
                                  x
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild1
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } }) -}
d80b573d36b2004821aeb6399bc084b9
  type Lexer u a =
    Text.Parsec.Prim.Parsec Data.Text.Internal.Text u a
015da505ab7d9bcbf17b066347ec1288
  data PositionedToken
    = PositionedToken {ptSourcePos :: Text.Parsec.Pos.SourcePos,
                       ptEndPos :: Text.Parsec.Pos.SourcePos,
                       ptPrevEndPos :: GHC.Base.Maybe Text.Parsec.Pos.SourcePos,
                       ptToken :: Language.PureScript.Parser.Lexer.Token,
                       ptComments :: [Language.PureScript.Comments.Comment]}
bd047d26d792e100b7cef064aba1e7f6
  data Token
    = LParen
    | RParen
    | LBrace
    | RBrace
    | LSquare
    | RSquare
    | Indent GHC.Types.Int
    | LArrow
    | RArrow
    | LFatArrow
    | RFatArrow
    | Colon
    | DoubleColon
    | Equals
    | Pipe
    | Tick
    | Dot
    | Comma
    | Semi
    | At
    | Underscore
    | LName Data.Text.Internal.Text
    | UName Data.Text.Internal.Text
    | Qualifier Data.Text.Internal.Text
    | Symbol Data.Text.Internal.Text
    | CharLiteral GHC.Types.Char
    | StringLiteral Language.PureScript.PSString.PSString
    | Number (Data.Either.Either
                GHC.Integer.Type.Integer GHC.Types.Double)
    | HoleLit Data.Text.Internal.Text
187b24d9915c74f6cd19336cd3ce961b
  type TokenParser a =
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      a
13ff47b18f74925c023f931286c55ea9
  anyToken ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.anyToken1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Parser.Lexer.PositionedToken>_R)) -}
2a60c26a30088f8bffb671c6f02d09ff
  anyToken1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wanyToken
                   @ b
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
275a946428a4a6aa71a319f60d570be8
  at :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.At) -}
b26ec2b99dfa76b3b95a07e0b9efe061
  braces ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.braces1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
168f5184d555992e8df2a6ad936b76e2
  braces1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lbrace
                   Language.PureScript.Parser.Lexer.rbrace
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
9895db113a76865049e7e79ad83bb873
  charLiteral ::
    Language.PureScript.Parser.Lexer.TokenParser GHC.Types.Char
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.charLiteral1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Types.Char>_R)) -}
6277f926b2d2ccda8f067915a478ba8d
  charLiteral1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Language.PureScript.Parser.Lexer.charLiteral4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Language.PureScript.Parser.Lexer.charLiteral2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
504e85fcb0886e54a7c789f4c2351de2
  charLiteral2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.charLiteral_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
f2026ac4b478e0cfdaf450be432ed112
  charLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("char literal"#) -}
1d6571b8bf2e46b6e7214aa152e9b678
  charLiteral4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp @ b ww1 ww2 ww3 w1 w4 }) -}
52f53136437bdd2c54d83124dad9bafa
  charLiteral_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.charLiteral3) -}
b143968510ff6fbe8b56445c23e770f1
  colon :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Colon) -}
791c67369d64a7957db4c9296a5f4536
  comma :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Comma) -}
d353b58fd203544763c113c2ba09a113
  commaSep ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.commaSep2
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
b322b1c526c474b09842312f0b11d610
  commaSep1 ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.commaSep3
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
ea03c9c75051b3b78ca5c3bc6e57794b
  commaSep2 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (6, True, True)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.comma
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
a176d1a5709166b6c67b853bd3f431cd
  commaSep3 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy1
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.comma
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
c62058e002a41518edc5eb7a4d74a0a4
  dconsname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.dconsname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
21e0dc97efcf0331e354f5872c36e3f8
  dconsname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.dconsname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
8a01fbb8a36e612e8ae45dfa9e34143d
  dconsname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.dconsname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
aaf63af56a388e97d3ac4a7aaa60b279
  dconsname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("data constructor name"#) -}
85e9ad24c4f8b5f3f8d44406d51983c7
  dconsname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp1 @ b ww1 ww2 ww3 w1 w4 }) -}
571ac5c3a84b4997c596205bc25031f6
  dconsname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.dconsname3) -}
fe83d7033cfab2127f9b28818ba3c35a
  dot :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Dot) -}
294dc4fa850a55a85acd8909ea86e45d
  doubleColon :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.DoubleColon) -}
2988535b336fd44374b9bedc6c505004
  equals :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Equals) -}
a9347910938bbb19fa2d464a536314c4
  holeLit ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.holeLit1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
63be32c5e4090876e2c2bd4b413a4303
  holeLit1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.holeLit4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.holeLit2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
e1467e932c9784afdb326d68d70946ea
  holeLit2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.holeLit_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
b710b627916b0fc254e58271c141fb65
  holeLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("hole literal"#) -}
d5f95744dc2d428eda378bed04b435dc
  holeLit4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp2 @ b ww1 ww2 ww3 w1 w4 }) -}
e82d61db266f7b1df7aac4a49953f5b0
  holeLit_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.holeLit3) -}
71517dd1b5165f695e88eab2aaf7b72d
  identifier ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.identifier1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
1b4a3cf0f6178f8f22031903ef4f30c0
  identifier1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.identifier4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.identifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
b3e2836e0a93131d8d8c74cda37f0649
  identifier2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.identifier_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
0f8a93d68939c7d303e7bbc731435f70
  identifier3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("identifier"#) -}
fda3471398a2ff983fa77ee1f001d423
  identifier4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp3 @ b ww1 ww2 ww3 w1 w4 }) -}
8edb6bb2ae6912ce449d9f0e1a102f75
  identifier_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.identifier3) -}
5bd238e46eab8404e4dd5b108d4496b8
  indent ::
    Language.PureScript.Parser.Lexer.TokenParser GHC.Types.Int
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.indent1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Types.Int>_R)) -}
453a2f00790d93c3f351afe96ff9154b
  indent1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Types.Int
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Types.Int
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Int
                   Language.PureScript.Parser.Lexer.indent4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Int>_R))
                   Language.PureScript.Parser.Lexer.indent2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
36628168acdce2be1b5cf95424b529fc
  indent2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.indent_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
e2560d8c81e236548240972a3789f3c0
  indent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("indentation"#) -}
d5fea4d1ff72f04f859d500bad25e373
  indent4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Types.Int
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Types.Int
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp4 @ b ww1 ww2 ww3 w1 w4 }) -}
ba57a51b52323895b895544163150056
  indentAt ::
    Text.Parsec.Pos.Column
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U)> -}
36bdb069cd4bc028013fb194f4ae32bd
  indent_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.indent3) -}
1f2a5ed9da6180be8c6a5c78fed0933b
  isSymbolChar :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: (\ (c :: GHC.Types.Char) ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        c
                        Language.PureScript.Parser.Lexer.isSymbolChar1 of wild {
                   GHC.Types.False
                   -> case c of wild1 { GHC.Types.C# c1 ->
                      case GHC.Prim.ltChar# c1 '\128'# of lwild {
                        DEFAULT -> GHC.Unicode.$wisSymbol c1 1# -> GHC.Types.False } }
                   GHC.Types.True -> GHC.Types.True }) -}
5f335fa8d3173728e65abe4fdf408d4e
  isSymbolChar1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.isSymbolChar2) -}
ad5631b68bf37a996ccdbebfe25083f1
  isSymbolChar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":!#$%&*+./<=>?@\\^|-~"#) -}
f245417816e78fa9b894878e6e53fb67
  isUnquotedKey :: Data.Text.Internal.Text -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wisUnquotedKey ww1 ww2 ww3 }) -}
b07c2a02fa459e73e061eb95704400ed
  kiname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.kiname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
aafb7a5d3a47d33c7be7926b69c4e18e
  kiname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.kiname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
8d9ded680e9c37e8525f0552ff256da2
  kiname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.kiname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
1630ff85ffb6fc7fa80b49353f5564e3
  kiname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("kind name"#) -}
83e4772b7aa37a747b6b23c1d386c597
  kiname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.kiname3) -}
eb0d6bbf837ccfe9a289c159d851c717
  larrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LArrow) -}
b2224ab5909c74837c4f6d880d1d8520
  lbrace :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LBrace) -}
8cc273ef9ffe00ce51529fc0c7f44874
  lex ::
    GHC.IO.FilePath
    -> Data.Text.Internal.Text
    -> Data.Either.Either
         Text.Parsec.Error.ParseError
         [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (f2 :: GHC.IO.FilePath)
                   (s :: Data.Text.Internal.Text) ->
                 case (Text.Parsec.Prim.runPT
                         @ Data.Text.Internal.Text
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                         Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                         (Language.PureScript.Parser.Lexer.lex1 @ ())
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                         GHC.Tuple.()
                         f2
                         s)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild {
                   Data.Either.Left x -> wild
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ Text.Parsec.Error.ParseError
                        @ [Language.PureScript.Parser.Lexer.PositionedToken]
                        (Language.PureScript.Parser.Lexer.updatePositions y) }) -}
4f4475b876960e44a2a768ddce965782
  lex1 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex3 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                   (Language.PureScript.Parser.Lexer.lex2 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
08335f807b75d7d26833b5c4691d8677
  lex10 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: [Language.PureScript.Parser.Lexer.PositionedToken]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: [Language.PureScript.Parser.Lexer.PositionedToken]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wmany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   (Language.PureScript.Parser.Lexer.lex11 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Parser.Lexer.PositionedToken>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
7f420487e48d94bc1d10291a4a44c4d6
  lex11 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Lexer.$wparsePositionedToken
                   @ u
                   @ b
                   w
                   w1
                   w3
                   w4) -}
46f5e7ce3db2db97d3a2d4f4d1da119c
  lex12 ::
    [Language.PureScript.Comments.Comment]
    -> forall b.
       Text.Parsec.Prim.State Data.Text.Internal.Text u
       -> (Language.PureScript.Parser.Lexer.PositionedToken
           -> Text.Parsec.Prim.State Data.Text.Internal.Text u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Language.PureScript.Parser.Lexer.PositionedToken
           -> Text.Parsec.Prim.State Data.Text.Internal.Text u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
a5e0d5623481bf5edd6e5707c72a4d49
  lex2 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Combinator.eof1
                   @ Data.Text.Internal.Text
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ u
                   Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                   GHC.Show.$fShowChar) -}
e9b31033edd730699f92a672313e170a
  lex3 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex9 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                   (Language.PureScript.Parser.Lexer.lex4 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
dac953149e9dcad78f155de5afd8e22b
  lex4 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wskipMany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   (Language.PureScript.Parser.Lexer.lex5 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
11bd8a207109c5b3fa75cea86d3c072d
  lex5 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex8 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   (Language.PureScript.Parser.Lexer.lex6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
547ae50319f653e3a6e267116e3ed884
  lex6 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wskipMany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Language.PureScript.Parser.Lexer.lex7 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
cec9f3b13c26cf576bd27c7acf8fa621
  lex7 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   (w2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ Data.Text.Internal.Text
                   @ Data.Functor.Identity.Identity
                   @ u
                   Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                   GHC.Unicode.isSpace
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
5f3d8113be4586eead06c9b93a40d8bc
  lex8 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(U)><L,A><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Comments.Comment
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Comments.Comment
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Lexer.$wparseComment
                   @ u
                   @ b
                   w
                   w1
                   w3
                   w4) -}
12760f42aa6103e3656537c938cdf925
  lex9 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT2
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   (Language.PureScript.Parser.Lexer.lex6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   (Language.PureScript.Parser.Lexer.lex10 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))) -}
68552e3e6929d952f8af88426d1a4b3a
  lexLenient ::
    GHC.IO.FilePath
    -> Data.Text.Internal.Text
    -> Data.Either.Either
         Text.Parsec.Error.ParseError
         [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (f2 :: GHC.IO.FilePath)
                   (s :: Data.Text.Internal.Text) ->
                 case (Text.Parsec.Prim.runPT
                         @ Data.Text.Internal.Text
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                         Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                         (Language.PureScript.Parser.Lexer.lex3 @ ())
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                         GHC.Tuple.()
                         f2
                         s)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild {
                   Data.Either.Left x -> wild
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ Text.Parsec.Error.ParseError
                        @ [Language.PureScript.Parser.Lexer.PositionedToken]
                        (Language.PureScript.Parser.Lexer.updatePositions y) }) -}
4e25e7a7d7274d41ecb80a84c2839d17
  lex_$sgo2 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(A,U,A,A,A)><L,1*U> -}
da33b36664b93f644a6dff765dae264b
  lfatArrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LFatArrow) -}
6e1d4b4ef234a78f7b87fd5f992b70f0
  lname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.lname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
ddbc74234ff5893caea93ffd0d384ff0
  lname' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
98b87f583a57959aaf29d3874c3662d0
  lname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.lname2
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.identifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
d6f4616c6b26c48a60e4bb53f959f13c
  lname2 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp5 @ b ww1 ww2 ww3 w1 w4 }) -}
d22aae6e16dfc68c424dfc08f6166610
  lparen :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LParen) -}
8e3600d740e1cb9ebccf7feb7a0bf0c9
  lsquare :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LSquare) -}
47e916397fe2d1e084336a5c6c1783b7
  match ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U> -}
70083b67af3d0ef40a356c978f24a512
  mname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.mname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
1a6c1fe1aa3f2629177b2558bde34c92
  mname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.mname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.mname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
29fd4c657c2395ab5438584de2c6309d
  mname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.mname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
f11d630219f8e335c66808e0266b8580
  mname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("module name"#) -}
154fdee14e11af45a439abc3ed79468f
  mname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp6 @ b ww1 ww2 ww3 w1 w4 }) -}
b7ec71ead96bc873fe6271594075e43c
  mname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.mname3) -}
cc2f624eb796f5bf7f8c3ba013e49aa2
  natural ::
    Language.PureScript.Parser.Lexer.TokenParser
      GHC.Integer.Type.Integer
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.natural1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Integer.Type.Integer>_R)) -}
355633c8534faa72a186ce44e35ee339
  natural1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Integer.Type.Integer
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Integer.Type.Integer
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Integer.Type.Integer
                   Language.PureScript.Parser.Lexer.natural4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Integer.Type.Integer>_R))
                   Language.PureScript.Parser.Lexer.natural2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
090d007527407bc05ce1e77ccc371f37
  natural2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.natural_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
98a5eba5255b5fd4646adb28b5419636
  natural3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("natural"#) -}
ab9670d34117c190a517435acf50db6f
  natural4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Integer.Type.Integer
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Integer.Type.Integer
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp7 @ b ww1 ww2 ww3 w1 w4 }) -}
07aa530de74bdb214e829f2afc9e3554
  natural_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.natural3) -}
d88b152b54a60439c2dc595cbdb56e8d
  number ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.number1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Either.Either
                             GHC.Integer.Type.Integer GHC.Types.Double>_R)) -}
50cffd76a1e93e60d4268e487a897979
  number1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Either.Either
                              GHC.Integer.Type.Integer GHC.Types.Double
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Either.Either
                              GHC.Integer.Type.Integer GHC.Types.Double
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double)
                   Language.PureScript.Parser.Lexer.number3
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double>_R))
                   Language.PureScript.Parser.Lexer.number_msgs
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
26f85ba84ae418e9834e6e47a3e159a0
  number2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("number"#) -}
da769a5b4b862494d2d16e84e378ab5d
  number3 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp8 @ b ww1 ww2 ww3 w1 w4 }) -}
9670effcf937afee742673e9206d215e
  number_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.number2) -}
8e8f32c673359dedf8e60480192977ec
  number_msgs :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.number_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
cf084ae74dc27c8c9070bf462d824e6e
  parens ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.parens1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
615d1d155fba83d5000d8c953df1b7c5
  parens1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lparen
                   Language.PureScript.Parser.Lexer.rparen
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
5b3096c272c057a0a415cb07ea4ab678
  pipe :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Pipe) -}
ecd054b55b46ec0554a5171c88cc151e
  prettyPrintToken ::
    Language.PureScript.Parser.Lexer.Token -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,1*U> -}
015da505ab7d9bcbf17b066347ec1288
  ptComments ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> [Language.PureScript.Comments.Comment]
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds5 }) -}
015da505ab7d9bcbf17b066347ec1288
  ptEndPos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLL),1*U(A,1*U(U,U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds2 }) -}
015da505ab7d9bcbf17b066347ec1288
  ptPrevEndPos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Base.Maybe Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSLL),1*U(A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds3 }) -}
015da505ab7d9bcbf17b066347ec1288
  ptSourcePos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U,U,U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds1 }) -}
015da505ab7d9bcbf17b066347ec1288
  ptToken ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.Token
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds4 }) -}
73e20023a6cb1181c833e27f5af4d00c
  qualifier ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.qualifier1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
a87f0aa3e5ae5e6bbaaf0fc2383d0641
  qualifier1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.qualifier4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.qualifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
ed2f5360755526f35f7d6df1b2440c32
  qualifier2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.qualifier_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
0ea14b0f51f7afa6b592b652d1a3682a
  qualifier3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("qualifier"#) -}
c59f13f031fa02b65b28b503c0e6c206
  qualifier4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp9 @ b ww1 ww2 ww3 w1 w4 }) -}
eb92a57f084f61bc4c851b304e74f599
  qualifier_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.qualifier3) -}
6ff8539bff2e21d2fc59f86fe8f0d442
  rarrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RArrow) -}
edd5d8c3e5c15e170977fb765ec8652f
  rbrace :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RBrace) -}
01d5938beb4343cb6453f0c465ad02c7
  reserved ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
400d417738afd5ca45175466117bea63
  reservedPsNames :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames70
                   Language.PureScript.Parser.Lexer.reservedPsNames1) -}
cecfa596b09cfdeb7e428797c55c1394
  reservedPsNames1 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames68
                   Language.PureScript.Parser.Lexer.reservedPsNames2) -}
796e7d932a7fa96f1216525f63b0ddb5
  reservedPsNames10 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames50
                   Language.PureScript.Parser.Lexer.reservedPsNames11) -}
243f8ebff1d843adb55fc92d552fa459
  reservedPsNames11 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames48
                   Language.PureScript.Parser.Lexer.reservedPsNames12) -}
512ce00e7e5945ddb7109c2f9daa3385
  reservedPsNames12 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames46
                   Language.PureScript.Parser.Lexer.reservedPsNames13) -}
dd6753bd15a66784fdef32d2ffb01970
  reservedPsNames13 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames44
                   Language.PureScript.Parser.Lexer.reservedPsNames14) -}
331a6c2341856ee8421a8692cfc1d4ee
  reservedPsNames14 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames42
                   Language.PureScript.Parser.Lexer.reservedPsNames15) -}
eacdd289514df8d31d2eab149bddd96d
  reservedPsNames15 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames40
                   Language.PureScript.Parser.Lexer.reservedPsNames16) -}
6366e7a425f4abf47e93e59699658494
  reservedPsNames16 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames38
                   Language.PureScript.Parser.Lexer.reservedPsNames17) -}
41a87f6f09e45a04301e76fb527c93c0
  reservedPsNames17 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames36
                   Language.PureScript.Parser.Lexer.reservedPsNames18) -}
187680e1bd1a316321062f3939cd634c
  reservedPsNames18 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames34
                   Language.PureScript.Parser.Lexer.reservedPsNames19) -}
d5b9f4cf5c24dacbe2cc481b8b2b5259
  reservedPsNames19 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames32
                   Language.PureScript.Parser.Lexer.reservedPsNames20) -}
321d6db18d541dbe0549317d6b8c3072
  reservedPsNames2 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames66
                   Language.PureScript.Parser.Lexer.reservedPsNames3) -}
ff47f3afcc66d8daef7d6bbf1f5a6c0e
  reservedPsNames20 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames30
                   Language.PureScript.Parser.Lexer.reservedPsNames21) -}
41c9ceb5778296a20716fa3c74120939
  reservedPsNames21 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames28
                   Language.PureScript.Parser.Lexer.reservedPsNames22) -}
61fcdebff0ac5e4112508c5357065ed3
  reservedPsNames22 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames26
                   Language.PureScript.Parser.Lexer.reservedPsNames23) -}
163367b0b590b0ba5e98950bf42fe3d3
  reservedPsNames23 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames24
                   (GHC.Types.[] @ Data.Text.Internal.Text)) -}
8bdcb0043d4c3aadc79ae520639a5e72
  reservedPsNames24 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames25) -}
393045387f3ff652cde4d7c8a42a5f3a
  reservedPsNames25 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("where"#) -}
68046093b911ea275a57c57b4b28fd7a
  reservedPsNames26 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames27) -}
1b17bbd7a7eba337fc8139db2deb2496
  reservedPsNames27 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("in"#) -}
90561368c9fee12b7f1ae767479c62a3
  reservedPsNames28 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames29) -}
8b0983d73fad67cb022a9a545981f66d
  reservedPsNames29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("false"#) -}
c7389ab52cbe299a01d646a82d9558d4
  reservedPsNames3 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames64
                   Language.PureScript.Parser.Lexer.reservedPsNames4) -}
a7ae28eb6c709ed1c3248cfa6502885c
  reservedPsNames30 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames31) -}
2f596cf253b77608a4ee28698137c5f5
  reservedPsNames31 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("true"#) -}
6f3061c05c67c1cc22ce492fe0db8a0b
  reservedPsNames32 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames33) -}
941817211cc313144104551459cb80a0
  reservedPsNames33 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("let"#) -}
c3805a2f8aaadb9daaedc8df59f29c04
  reservedPsNames34 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames35) -}
7041059287efa4ade2cda642e19a5d00
  reservedPsNames35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ado"#) -}
8cf6252be27e5aec15f9088a608aced7
  reservedPsNames36 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames37) -}
89e3129832e7157c1af3a88eeebe5ff6
  reservedPsNames37 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("do"#) -}
dbd6e23bdadd8face89afd3ce6ebf7b2
  reservedPsNames38 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames39) -}
f7290342088e26a842661da72e2a8d79
  reservedPsNames39 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("else"#) -}
71e1bd1bf300ca27140fee1eaf6e1ab9
  reservedPsNames4 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames62
                   Language.PureScript.Parser.Lexer.reservedPsNames5) -}
dd8ba61e5888f53e3c9c88670b17d0bc
  reservedPsNames40 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames41) -}
ded307f56403546021c8c177eb710188
  reservedPsNames41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("then"#) -}
6b5755c2d2c919dec7bb18b6d6806cad
  reservedPsNames42 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames43) -}
3e714d7e2d94eb34a049a1a5ef96bb11
  reservedPsNames43 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("if"#) -}
22caae3a7a694f366080ee5f7e111613
  reservedPsNames44 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames45) -}
6ba1e6b30bed0d55263901b35e30705a
  reservedPsNames45 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("of"#) -}
ad2fc200d782a512649b623a9da40c1c
  reservedPsNames46 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames47) -}
7b9523d35cc769ea80a4493d6ca7e2bb
  reservedPsNames47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("case"#) -}
abb7831a037c674a62982d0a35564ef9
  reservedPsNames48 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames49) -}
e049312244f8272fbf6392d21e0dc176
  reservedPsNames49 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("module"#) -}
0b1520422685e8e7ff3c5cb421487117
  reservedPsNames5 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames60
                   Language.PureScript.Parser.Lexer.reservedPsNames6) -}
c71a3037ee209c3ebb05753f4847224b
  reservedPsNames50 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames51) -}
4f1278bd0a8229698f7aad1239bf8bc5
  reservedPsNames51 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("derive"#) -}
9bfe66592745413404b65bd162490bc4
  reservedPsNames52 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames53) -}
3f1f017bbd80a1aa5ce814ed6fc3c32a
  reservedPsNames53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("instance"#) -}
810fc5820609c3ba644571b8875d6c69
  reservedPsNames54 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames55) -}
463d298163863ce6f2455bff71fd4539
  reservedPsNames55 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("class"#) -}
a44403dd261d3c84b177afe8c0102625
  reservedPsNames56 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames57) -}
059630aff5a1176b5b3c7abe8220d85e
  reservedPsNames57 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infix"#) -}
6abee32a45779ebe1ba9d7b0965eb313
  reservedPsNames58 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames59) -}
1a525dacda9483ae2da1203590e27beb
  reservedPsNames59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infixr"#) -}
4858044173d52567655d33ea9db93fd2
  reservedPsNames6 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames58
                   Language.PureScript.Parser.Lexer.reservedPsNames7) -}
3b75a65d52fcdd78683212b0672789fe
  reservedPsNames60 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames61) -}
d64a9039c37fe9056b17cccb9aad50b6
  reservedPsNames61 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infixl"#) -}
80823255b1a763f8a43ac39e75225dec
  reservedPsNames62 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames63) -}
fedf6c16ea8c890be419e12aed80a7fb
  reservedPsNames63 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("import"#) -}
b1b24d1e44bbd1f5aa6623b53bd3cc10
  reservedPsNames64 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames65) -}
915bb754620d02a405360c133138b0e8
  reservedPsNames65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("foreign"#) -}
4b17ea0bfcb6628e323002f628ddd743
  reservedPsNames66 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames67) -}
c0b69209590dd5f4ee402ff9f7c44864
  reservedPsNames67 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("type"#) -}
4f55d82e1db3e39fd2dd3e099b16a57c
  reservedPsNames68 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames69) -}
fbf1b782bf03e922834514d62dc73b2c
  reservedPsNames69 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("newtype"#) -}
e37106330ff4d3289d0c24b831f60901
  reservedPsNames7 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames56
                   Language.PureScript.Parser.Lexer.reservedPsNames8) -}
23246352a1af1c5161a72f2949e14b4b
  reservedPsNames70 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames71) -}
13e88619bf7134ca74a7d90995c0da81
  reservedPsNames71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("data"#) -}
e3e4dcb2ecabc929c5c1a882cec7886e
  reservedPsNames8 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames54
                   Language.PureScript.Parser.Lexer.reservedPsNames9) -}
720a8fc4163497d7051a365ad3791283
  reservedPsNames9 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames52
                   Language.PureScript.Parser.Lexer.reservedPsNames10) -}
4bc98bac8b82b49720d283817c837094
  reservedTypeNames :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedTypeNames1
                   Language.PureScript.Parser.Lexer.reservedPsNames23) -}
15edabee96d0ef5b709584c5746d0f96
  reservedTypeNames1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedTypeNames2) -}
10d814c77531a28b4040ee2fae75c944
  reservedTypeNames2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("forall"#) -}
5ab8ee2cfbcabb5bfd66b2533861e390
  rfatArrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RFatArrow) -}
526bf94b06d3d64ec6a63e9c53ddb2ab
  rparen :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RParen) -}
551a0c49e48bbc8f3bad8f4a3744b356
  rsquare :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RSquare) -}
5390183b18a1b591954e06ca4793633a
  semi :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Semi) -}
19fad2ccc5fb5dc916a4f17b27786ddf
  semiSep ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.semiSep2
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
74162ebfb0fa439b23204a820236209a
  semiSep1 ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.semiSep3
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
c166ac73ffc178c25a39fd0e384e32d5
  semiSep2 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (6, True, True)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.semi
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
37c0c8913758ecd5110237acd6d56839
  semiSep3 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy1
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.semi
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
f06e23d6a1ec5d566668267ec2acb8b1
  squares ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.squares1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
4a7d0432207ce1aa1c0f94b376782dde
  squares1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lsquare
                   Language.PureScript.Parser.Lexer.rsquare
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
5b013bddd8e088b3207ee7aa6d991705
  stringLiteral ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.PSString.PSString
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.stringLiteral1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.PSString.PSString>_R)) -}
7ad5764353969fa90529f40e1179a590
  stringLiteral1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Language.PureScript.PSString.PSString
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Language.PureScript.PSString.PSString
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.PSString.PSString
                   Language.PureScript.Parser.Lexer.stringLiteral4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.PSString.PSString>_R))
                   Language.PureScript.Parser.Lexer.stringLiteral2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
a7cf7a029d60ae3893180d030acc90d3
  stringLiteral2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.stringLiteral_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
b95142f94434201a6b6ba00bca18a57f
  stringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("string literal"#) -}
601e82910c3505a35738735497b0c1b9
  stringLiteral4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp10 @ b ww1 ww2 ww3 w1 w4 }) -}
ff6068673127a9ca6f25011b05a1dd60
  stringLiteral_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.stringLiteral3) -}
7dd8c55c092324ed2efcd817d6c7248f
  symbol ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.symbol1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
d1fd86a62b72396f3e5973cba6978c34
  symbol' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
a922d2daa9491fe848e642de7ba10ba3
  symbol1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.symbol4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.symbol2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
eef3e90148f5295bc8db0d178986f42f
  symbol10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
ea19f4f64fd07cd3d8bca09b8f962fc3
  symbol2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.symbol_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
c4ace39d523c4dbf43394e115d5999f1
  symbol3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("symbol"#) -}
6ffaec3b452fae72b4090ccf10807d34
  symbol4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp11 @ b ww1 ww2 ww3 w1 w4 }) -}
8a81ea1a0a8ad8134ea6d602fcc1ab4f
  symbol5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol6) -}
5ac960f74e371ece7c77f53e57bb4a96
  symbol6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("@"#) -}
af8ad4b38fa9cd306ffd0688f5043473
  symbol7 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol8) -}
3f682b648df97c98498f9c7fbd10083b
  symbol8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
332ffa12914dcc127f497da9d8891802
  symbol9 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol10) -}
26e5d5807961c308ef5dab70aa79e907
  symbol_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol3) -}
c48b67402017ba67b1ca2142f31e7279
  tick :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Tick) -}
04d991d6ee781b8b6c3e0a9a6f50789a
  token ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.token1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
4fb724fb42772655d3eba1a8972452ca
  token1 ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w :: Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
                   @ b
                   (w1 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w2 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w1 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wtoken
                   @ a
                   w
                   @ b
                   ww1
                   ww2
                   ww3
                   w2
                   w5 }) -}
8d496fac787139075602f87ff093888b
  tyname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.tyname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
0a4268f8c48a7ccb39ccd920402b2b2f
  tyname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.tyname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
256f10c33583c97aec6e5d94248c18b5
  tyname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.tyname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
818e112b1cbf04c5c68b992ed44095dd
  tyname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("type name"#) -}
d23fc49bafd62370ff88af1d5c56788d
  tyname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.tyname3) -}
e63804a86f0d5e1d671b1d3e63489e75
  uname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.uname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
e77afc4a70585bcab81d006dbfe77e26
  uname' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 6,
     Strictness: <L,1*U(U,U,U)><L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.uname'1
                  `cast`
                (<Data.Text.Internal.Text>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <()>_R)) -}
c66ebe380769ea947bd84fc51c8019cf
  uname'1 ::
    Data.Text.Internal.Text
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (()
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*U(U,U,U)><L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ (s :: Data.Text.Internal.Text)
                   @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: ()
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: ()
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ ()
                   (\ @ b1
                      (eta6 :: Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState)[OneShot]
                      (eta7 :: ()
                               -> Text.Parsec.Prim.State
                                    [Language.PureScript.Parser.Lexer.PositionedToken]
                                    Language.PureScript.Parser.State.ParseState
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta8 :: Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta9 :: ()
                               -> Text.Parsec.Prim.State
                                    [Language.PureScript.Parser.Lexer.PositionedToken]
                                    Language.PureScript.Parser.State.ParseState
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta10 :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1)[OneShot] ->
                    case eta6 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                    case ww1 of wild {
                      []
                      -> eta10 (Text.Parsec.Error.ParseError ww2 Text.Parsec.Prim.token2)
                      : t ts
                      -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                         let {
                           $j :: Data.Functor.Identity.Identity b1 <join 0>
                           = eta10
                               (Text.Parsec.Error.ParseError
                                  ww2
                                  (GHC.Types.:
                                     @ Text.Parsec.Error.Message
                                     (case Language.PureScript.Parser.Lexer.$wlvl
                                             ds3 of dt6 { DEFAULT ->
                                      Text.Parsec.Error.SysUnExpect dt6 })
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)))
                         } in
                         case ds3 of wild2 {
                           DEFAULT -> $j
                           Language.PureScript.Parser.Lexer.UName s'
                           -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                              case s' of wild4 { Data.Text.Internal.Text dt9 dt10 dt11 ->
                              case GHC.Prim.==# dt8 dt11 of lwild {
                                DEFAULT -> $j
                                1#
                                -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.ByteArray#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.State#
                                                                       GHC.Prim.RealWorld
                                                                  -> (# GHC.Prim.State#
                                                                          GHC.Prim.RealWorld,
                                                                        GHC.Prim.Int# #)}
                                          dt6
                                          (GHC.Prim.int2Word# dt7)
                                          dt9
                                          (GHC.Prim.int2Word# dt10)
                                          (GHC.Prim.int2Word# dt8)
                                          GHC.Prim.realWorld# of wild5 { (#,#) ds5 ds6 ->
                                   case GHC.Prim.narrow32Int# ds6 of wild6 {
                                     DEFAULT -> $j
                                     0#
                                     -> case ts of wild7 {
                                          []
                                          -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                             eta7
                                               GHC.Tuple.()
                                               (Text.Parsec.Prim.State
                                                  @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                                  @ Language.PureScript.Parser.State.ParseState
                                                  (GHC.Types.[]
                                                     @ Language.PureScript.Parser.Lexer.PositionedToken)
                                                  v
                                                  ww3)
                                               (Text.Parsec.Error.ParseError
                                                  v
                                                  (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                          : t1 ts1
                                          -> case t1 of wild8 { Language.PureScript.Parser.Lexer.PositionedToken ds7 ds8 ds9 ds10 ds11 ->
                                             case ds7 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                             eta7
                                               GHC.Tuple.()
                                               (Text.Parsec.Prim.State
                                                  @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                                  @ Language.PureScript.Parser.State.ParseState
                                                  wild7
                                                  v
                                                  ww3)
                                               (Text.Parsec.Error.ParseError
                                                  v
                                                  (GHC.Types.[]
                                                     @ Text.Parsec.Error.Message)) } } } } } } } } } } } })
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   Language.PureScript.Parser.Lexer.uname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
519bb631450ae6d5494db998bbc76c50
  uname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.uname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.uname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
ae2d0a9adbb6450f82d75dc64921d193
  uname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.uname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
a6c851a41e830fe75c3766d78e74be5c
  uname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("proper name"#) -}
1907f1ae2807f2c888c6eb607a7566e5
  uname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp12 @ b ww1 ww2 ww3 w1 w4 }) -}
df6b9c15137e8eb0205f180c265ca4f5
  uname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.uname3) -}
69c9526f4aba04813bc9cc79358acdd6
  underscore :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Underscore) -}
8e5170b95acfd77b0290262e40f5b734
  updatePositions ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.PureScript.Parser.Lexer.PositionedToken]) ->
                 case ds of wild {
                   []
                   -> GHC.Types.[] @ Language.PureScript.Parser.Lexer.PositionedToken
                   : x xs
                   -> GHC.Types.:
                        @ Language.PureScript.Parser.Lexer.PositionedToken
                        x
                        (Language.PureScript.Parser.Lexer.lex_$sgo2 xs x xs) }) -}
instance GHC.Classes.Eq [Language.PureScript.Parser.Lexer.PositionedToken]
  = Language.PureScript.Parser.Lexer.$fEqPositionedToken
instance GHC.Classes.Eq [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fEqToken
instance GHC.Classes.Ord [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fOrdToken
instance GHC.Show.Show [Language.PureScript.Parser.Lexer.PositionedToken]
  = Language.PureScript.Parser.Lexer.$fShowPositionedToken
instance GHC.Show.Show [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fShowToken
"SPEC/Language.PureScript.Parser.Lexer $fStreamTextmChar0 @ Identity" [orphan] forall (v :: GHC.Base.Monad
                                                                                              Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStreamTextmChar0 @ Data.Functor.Identity.Identity
                                      v
  = Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

