
==================== FINAL INTERFACE ====================
2019-01-24 14:13:40.092087 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Parser.Lexer 8043
  interface hash: ae799b0aaf55004fd6b8180378499213
  ABI hash: ea857194274ee8b3812ad62bbb2c9ed1
  export-list hash: ca7efc854dfe3379de291b0f8c8d7ea0
  orphan hash: 27ada0c48af9c0bef4905bc136ded511
  flag hash: af801e39deabea4814ba66209bc490c9
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Parser.Lexer.anyToken
  Language.PureScript.Parser.Lexer.at
  Language.PureScript.Parser.Lexer.braces
  Language.PureScript.Parser.Lexer.charLiteral
  Language.PureScript.Parser.Lexer.colon
  Language.PureScript.Parser.Lexer.comma
  Language.PureScript.Parser.Lexer.commaSep
  Language.PureScript.Parser.Lexer.commaSep1
  Language.PureScript.Parser.Lexer.dconsname
  Language.PureScript.Parser.Lexer.dot
  Language.PureScript.Parser.Lexer.doubleColon
  Language.PureScript.Parser.Lexer.equals
  Language.PureScript.Parser.Lexer.holeLit
  Language.PureScript.Parser.Lexer.identifier
  Language.PureScript.Parser.Lexer.indent
  Language.PureScript.Parser.Lexer.indentAt
  Language.PureScript.Parser.Lexer.isSymbolChar
  Language.PureScript.Parser.Lexer.isUnquotedKey
  Language.PureScript.Parser.Lexer.kiname
  Language.PureScript.Parser.Lexer.larrow
  Language.PureScript.Parser.Lexer.lbrace
  Language.PureScript.Parser.Lexer.lex
  Language.PureScript.Parser.Lexer.lexLenient
  Language.PureScript.Parser.Lexer.lfatArrow
  Language.PureScript.Parser.Lexer.lname
  Language.PureScript.Parser.Lexer.lname'
  Language.PureScript.Parser.Lexer.lparen
  Language.PureScript.Parser.Lexer.lsquare
  Language.PureScript.Parser.Lexer.match
  Language.PureScript.Parser.Lexer.mname
  Language.PureScript.Parser.Lexer.natural
  Language.PureScript.Parser.Lexer.number
  Language.PureScript.Parser.Lexer.parens
  Language.PureScript.Parser.Lexer.pipe
  Language.PureScript.Parser.Lexer.qualifier
  Language.PureScript.Parser.Lexer.rarrow
  Language.PureScript.Parser.Lexer.rbrace
  Language.PureScript.Parser.Lexer.reserved
  Language.PureScript.Parser.Lexer.reservedPsNames
  Language.PureScript.Parser.Lexer.reservedTypeNames
  Language.PureScript.Parser.Lexer.rfatArrow
  Language.PureScript.Parser.Lexer.rparen
  Language.PureScript.Parser.Lexer.rsquare
  Language.PureScript.Parser.Lexer.semi
  Language.PureScript.Parser.Lexer.semiSep
  Language.PureScript.Parser.Lexer.semiSep1
  Language.PureScript.Parser.Lexer.squares
  Language.PureScript.Parser.Lexer.stringLiteral
  Language.PureScript.Parser.Lexer.symbol
  Language.PureScript.Parser.Lexer.symbol'
  Language.PureScript.Parser.Lexer.tick
  Language.PureScript.Parser.Lexer.token
  Language.PureScript.Parser.Lexer.tyname
  Language.PureScript.Parser.Lexer.uname
  Language.PureScript.Parser.Lexer.uname'
  Language.PureScript.Parser.Lexer.underscore
  Language.PureScript.Parser.Lexer.PositionedToken{Language.PureScript.Parser.Lexer.PositionedToken ptComments ptEndPos ptPrevEndPos ptSourcePos ptToken}
  Language.PureScript.Parser.Lexer.Token
  Language.PureScript.Parser.Lexer.TokenParser
module dependencies: Language.PureScript.Comments
                     Language.PureScript.PSString Language.PureScript.Parser.State
package dependencies: aeson-1.3.1.1 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1 mtl-2.2.2
                      parsec-3.1.13.0 pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      scientific-0.3.6.2 tagged-0.8.5 template-haskell-2.13.0.0
                      text-1.2.3.0 th-abstraction-0.2.8.0 time-1.8.0.2
                      time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Char 3e89818e2b8ef1a2cc5393163484da72
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.String 1b97cff5f9627e73898d75997a9ccf7f
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Enum 8824828888f5a89ecc9e7c73f05f3151
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:GHC.Unicode 8234c40b59f035e845832a42e8725a00
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  mtl-2.2.2:Control.Monad.Identity ca9e9b9bfa404d3d70994a432bbadd6d
import  -/  parsec-3.1.13.0:Text.Parsec 963cbe7b4116cef91451434dc005a011
import  -/  parsec-3.1.13.0:Text.Parsec.Char aba0ba8aa7079b551caee8be42722b1b
import  -/  parsec-3.1.13.0:Text.Parsec.Combinator 86d872425bd48a2d67c0d1ce1a8ccc8b
import  -/  parsec-3.1.13.0:Text.Parsec.Error 5c35aa426bd1cd52bcab90d9a1e3ce4c
import  -/  parsec-3.1.13.0:Text.Parsec.Pos 85d30a347a2120f1b5f286869826a471
import  -/  parsec-3.1.13.0:Text.Parsec.Prim 4e0ad30f54008188b8c54f509e1a8ed9
import  -/  parsec-3.1.13.0:Text.Parsec.Token 71c800868101599a8d0258126c4abc48
import  -/  Language.PureScript.Comments 1a682522a2f855328ca87bb68705794c
  exports: 9921c985b3279420b3b7a2b7ccc8b32e
  BlockComment 294e575fa681c397997a5b2ea1e38a73
  Comment 2e827a5b834f92cc9beef533348585fa
  LineComment f8711d4fb06b5c1fc5f0cc86b994034b
import  -/  Language.PureScript.PSString 482bcd39d274b3e3efbde5749bd9d797
  exports: dedd5d31dc509736134f041863efd1d4
  PSString 96ffea2472d48cda76cc39d47ab7bb82
import  -/  Language.PureScript.Parser.State 30ecb6d393d258ed6a43e1772eca1abf
  exports: dd6ef157d2027be1acaee486dc7fca19
  ParseState 62a6f136821eff488575d67f3b51d3ef
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
import  -/  text-1.2.3.0:Data.Text.Show 3b4b6fb2985a731022d67f636682da2b
bc5773f44100b87481d9bda3f9e246b7
  $fEqPositionedToken ::
    GHC.Classes.Eq Language.PureScript.Parser.Lexer.PositionedToken
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.PositionedToken
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c/= -}
bc5773f44100b87481d9bda3f9e246b7
  $fEqPositionedToken_$c/= ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,1*U,1*U)><S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (y :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
bc5773f44100b87481d9bda3f9e246b7
  $fEqPositionedToken_$c== ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,1*U,1*U)><S(S(SLL)LLLL),1*U(1*U(1*U,U,U),1*U(1*U,U,U),1*U,U,1*U)>,
     Unfolding: (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (ds1 :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken a1 a2 a3 a4 a5 ->
                 case ds1 of wild1 { Language.PureScript.Parser.Lexer.PositionedToken b1 b2 b3 b4 b5 ->
                 case a1 of ww { Text.Parsec.Pos.SourcePos ww1 ww2 ww3 ->
                 case b1 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 case GHC.Base.eqString ww1 ww5 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Prim.==# ww2 ww6 of lwild {
                        DEFAULT -> GHC.Types.False
                        1#
                        -> case GHC.Prim.==# ww3 ww7 of lwild1 {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case a2 of ww11 { Text.Parsec.Pos.SourcePos ww12 ww13 ww14 ->
                                case b2 of ww15 { Text.Parsec.Pos.SourcePos ww16 ww17 ww18 ->
                                case GHC.Base.eqString ww12 ww16 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Prim.==# ww13 ww17 of lwild2 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> case GHC.Prim.==# ww14 ww18 of lwild3 {
                                            DEFAULT -> GHC.Types.False
                                            1#
                                            -> let {
                                                 $j :: GHC.Types.Bool <join 0>
                                                 = case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                                                          a4
                                                          b4 of wild4 {
                                                     GHC.Types.False -> GHC.Types.False
                                                     GHC.Types.True
                                                     -> GHC.Classes.$fEq[]_$c==
                                                          @ Language.PureScript.Comments.Comment
                                                          Language.PureScript.Comments.$fEqComment
                                                          a5
                                                          b5 }
                                               } in
                                               case a3 of wild4 {
                                                 GHC.Base.Nothing
                                                 -> case b3 of wild5 {
                                                      GHC.Base.Nothing -> $j
                                                      GHC.Base.Just ipv -> GHC.Types.False }
                                                 GHC.Base.Just a7
                                                 -> case b3 of wild5 {
                                                      GHC.Base.Nothing -> GHC.Types.False
                                                      GHC.Base.Just b7
                                                      -> case a7 of ww19 { Text.Parsec.Pos.SourcePos ww20 ww21 ww22 ->
                                                         case b7 of ww23 { Text.Parsec.Pos.SourcePos ww24 ww25 ww26 ->
                                                         case GHC.Base.eqString ww20 ww24 of wild6 {
                                                           GHC.Types.False -> GHC.Types.False
                                                           GHC.Types.True
                                                           -> case GHC.Prim.==#
                                                                     ww21
                                                                     ww25 of lwild4 {
                                                                DEFAULT -> GHC.Types.False
                                                                1#
                                                                -> case GHC.Prim.==#
                                                                          ww22
                                                                          ww26 of lwild5 {
                                                                     DEFAULT -> GHC.Types.False
                                                                     1#
                                                                     -> $j } } } } } } } } } } } } } } } } } } }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fEqPositionedToken_$c==1 ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Language.PureScript.Parser.Lexer.Token)
                   (ds1 :: Language.PureScript.Parser.Lexer.Token) ->
                 case ds of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             wild of a# { DEFAULT ->
                      case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             ds1 of b# { DEFAULT ->
                      GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# a# b#) } }
                   Language.PureScript.Parser.Lexer.Indent a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Indent b1
                        -> GHC.Classes.eqInt a1 b1 }
                   Language.PureScript.Parser.Lexer.LName a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.LName b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.UName a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.UName b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.Qualifier a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Qualifier b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.Symbol a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Symbol b1
                        -> Data.Text.$fEqText_$c== a1 b1 }
                   Language.PureScript.Parser.Lexer.CharLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.CharLiteral b1
                        -> GHC.Classes.eqChar a1 b1 }
                   Language.PureScript.Parser.Lexer.StringLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.StringLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ GHC.Word.Word16
                             GHC.Word.$fEqWord16
                             a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.Parser.Lexer.Number a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.Number b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.eqInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.False }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.False
                                  Data.Either.Right b2 -> GHC.Classes.eqDouble a2 b2 } } }
                   Language.PureScript.Parser.Lexer.HoleLit a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.Parser.Lexer.HoleLit b1
                        -> Data.Text.$fEqText_$c== a1 b1 } }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fEqToken :: GHC.Classes.Eq Language.PureScript.Parser.Lexer.Token
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                  Language.PureScript.Parser.Lexer.$fEqToken_$c/= -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fEqToken_$c/= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fEqPositionedToken_$c==1
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken ::
    GHC.Classes.Ord Language.PureScript.Parser.Lexer.Token
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fEqToken
                  Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c<
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c<=
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c>
                  Language.PureScript.Parser.Lexer.$fOrdToken_$c>=
                  Language.PureScript.Parser.Lexer.$fOrdToken_$cmax
                  Language.PureScript.Parser.Lexer.$fOrdToken_$cmin -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$c< ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$c<= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$c> ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$c>= ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$ccompare ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (a :: Language.PureScript.Parser.Lexer.Token)
                   (b :: Language.PureScript.Parser.Lexer.Token) ->
                 case a of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             wild of a# { DEFAULT ->
                      case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.EQ }
                        1# -> GHC.Types.LT } } }
                   Language.PureScript.Parser.Lexer.Indent a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.># b# 6# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.GT
                             Language.PureScript.Parser.Lexer.Indent b1
                             -> GHC.Classes.compareInt a1 b1 }
                        1# -> GHC.Types.LT } }
                   Language.PureScript.Parser.Lexer.LName a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 21# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.LName b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.UName a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 22# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.UName b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Qualifier a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 23# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.Qualifier b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Symbol a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 24# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.Symbol b1
                             -> Data.Text.$fOrdText_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.CharLiteral a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 25# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.CharLiteral b1
                             -> GHC.Classes.$fOrdChar_$ccompare a1 b1 }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.StringLiteral a1
                   -> case GHC.Prim.dataToTag#
                             @ Language.PureScript.Parser.Lexer.Token
                             b of b# { DEFAULT ->
                      case GHC.Prim.<# b# 26# of lwild {
                        DEFAULT
                        -> case b of wild1 {
                             DEFAULT -> GHC.Types.LT
                             Language.PureScript.Parser.Lexer.StringLiteral b1
                             -> GHC.Classes.$fOrd[]_$ccompare
                                  @ GHC.Word.Word16
                                  GHC.Word.$fOrdWord16
                                  a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                                  b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                        1# -> GHC.Types.GT } }
                   Language.PureScript.Parser.Lexer.Number a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.Parser.Lexer.Number b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.compareInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.LT }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.GT
                                  Data.Either.Right b2
                                  -> GHC.Classes.$fOrdDouble_$ccompare a2 b2 } }
                        Language.PureScript.Parser.Lexer.HoleLit ds -> GHC.Types.LT }
                   Language.PureScript.Parser.Lexer.HoleLit a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.Parser.Lexer.HoleLit b1
                        -> Data.Text.$fOrdText_$ccompare a1 b1 } }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$cmax ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fOrdToken_$cmin ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.PureScript.Parser.Lexer.Token)
                   (y :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.$fOrdToken_$ccompare
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
bc5773f44100b87481d9bda3f9e246b7
  $fShowPositionedToken ::
    GHC.Show.Show Language.PureScript.Parser.Lexer.PositionedToken
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.PositionedToken
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshowsPrec
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshow
                  Language.PureScript.Parser.Lexer.$fShowPositionedToken_$cshowList -}
bc5773f44100b87481d9bda3f9e246b7
  $fShowPositionedToken1 ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$w$cshowsPrec ww4 w1 }) -}
bc5773f44100b87481d9bda3f9e246b7
  $fShowPositionedToken_$cshow ::
    Language.PureScript.Parser.Lexer.PositionedToken -> GHC.Base.String
  {- Arity: 1, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case w of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$wlvl ww4 }) -}
bc5773f44100b87481d9bda3f9e246b7
  $fShowPositionedToken_$cshowList ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   Language.PureScript.Parser.Lexer.$fShowPositionedToken1
                   ls
                   s) -}
bc5773f44100b87481d9bda3f9e246b7
  $fShowPositionedToken_$cshowsPrec ::
    GHC.Types.Int
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(LLLSL),1*U(A,A,A,1*U,A)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { Language.PureScript.Parser.Lexer.PositionedToken ww1 ww2 ww3 ww4 ww5 ->
                 Language.PureScript.Parser.Lexer.$w$cshowsPrec ww4 w2 }) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fShowToken :: GHC.Show.Show Language.PureScript.Parser.Lexer.Token
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Parser.Lexer.Token
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshowsPrec
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshow
                  Language.PureScript.Parser.Lexer.$fShowToken_$cshowList -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fShowToken1 ::
    Language.PureScript.Parser.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Language.PureScript.Parser.Lexer.$fShowToken_$cshowsPrec
                   Language.PureScript.Parser.Lexer.$fShowToken2) -}
c63d995695c40de34187be9d1be908e8
  $fShowToken2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fShowToken_$cshow ::
    Language.PureScript.Parser.Lexer.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fShowToken_$cshowList ::
    [Language.PureScript.Parser.Lexer.Token] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.PureScript.Parser.Lexer.Token])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.PureScript.Parser.Lexer.Token
                   Language.PureScript.Parser.Lexer.$fShowToken1
                   ls
                   s) -}
bfca495d98b2e792a78f6b37fc87fcb4
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int
    -> Language.PureScript.Parser.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
6b300b3e5cd01e2734f419db9577a16d
  $s$fStreamTextmChar0 ::
    Text.Parsec.Prim.Stream
      Data.Text.Internal.Text
      Data.Functor.Identity.Identity
      GHC.Types.Char
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Text.Internal.Text
                  @ Data.Functor.Identity.Identity
                  @ GHC.Types.Char
                  Data.Functor.Identity.$fMonadIdentity
                  Data.Text.uncons
                    `cast`
                  (<Data.Text.Internal.Text>_R
                   ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                 <GHC.Base.Maybe (GHC.Types.Char, Data.Text.Internal.Text)>_R)) -}
c55b71c198740c5d8f7ec7362a30947d
  $tc'At :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12166358927068233336##
                   11983491641565972544##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'At2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
c109324f3e4fa25ade9d136c0954edea
  $tc'At1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
c08b49acdc05f1f31f30606f301cf4e1
  $tc'At2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'At3) -}
b493901be4ec0f57d214673a367025d1
  $tc'At3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'At"#) -}
cfd4c3bbd5e12f96a808f34affbdce91
  $tc'CharLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12951397044888161632##
                   2719385693133476815##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral1) -}
92308c7c7acd315aa40c1f3fa767f622
  $tc'CharLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fc0df21411b67f44c88f81d4f6956350
  $tc'CharLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'CharLiteral3) -}
65275cde4cb51c8188a0e3acb711c530
  $tc'CharLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CharLiteral"#) -}
fbb553a27369e728bb8d50599fdf6eb5
  $tc'Colon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5518202271882116858##
                   6947278995071148670##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Colon1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
40154b789dd46282a67435de6975373c
  $tc'Colon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Colon2) -}
3077e8c27d7ba6cb3eb681c631b46dd0
  $tc'Colon2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Colon"#) -}
cefe259079994953c30e25b9671b0a7d
  $tc'Comma :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10709152952453753571##
                   5119626860139132092##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Comma1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
7bbca853fa3a909bd2c6f54947cf884d
  $tc'Comma1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Comma2) -}
d8ba713f515771ada40882e03a609185
  $tc'Comma2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Comma"#) -}
6bff06c1e30cccca81b2e32483af6af9
  $tc'Dot :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   461934652560317255##
                   8404216948829349508##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Dot1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
220ae156a104c1b999edfcf30a8c1bb9
  $tc'Dot1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Dot2) -}
7ce797b6a1c753bee1c13a728f42795f
  $tc'Dot2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Dot"#) -}
8c5e37d9ad1190c2df26969c62129d6a
  $tc'DoubleColon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6465851094054690661##
                   15773522683840749819##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'DoubleColon1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
2e6b0a6a7ddd881c0d891c3282a2547f
  $tc'DoubleColon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'DoubleColon2) -}
e9e3978c9555dee1723de966e9cb9d02
  $tc'DoubleColon2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DoubleColon"#) -}
057ab3b2d6e9e3d95053a69b13373638
  $tc'Equals :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16437082427721454516##
                   12456329500183293496##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Equals1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
8b21a2f70a7afe6d1032fe3130cc5fc6
  $tc'Equals1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Equals2) -}
f07e67e45004ed70197344f37950c0bc
  $tc'Equals2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Equals"#) -}
538992f8a91a8a8b1bc20e82e33836fc
  $tc'HoleLit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15046204066628776343##
                   15894775966686614557##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'HoleLit2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
d2f42fc059560bb6b8e2abf67da930af
  $tc'HoleLit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0e5d18c91080be492fe97edea73aa645
  $tc'HoleLit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'HoleLit3) -}
680688f77953836c95fdd7be95c663c1
  $tc'HoleLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HoleLit"#) -}
62f34ca8a1d274ab14848128c8f7b080
  $tc'Indent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6070433514953620257##
                   6163804647601649149##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Indent2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'Indent1) -}
68c60623ea2d39f7841c22f9e8cc6f44
  $tc'Indent1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4418fce07f6b3002e636389a544f1984
  $tc'Indent2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Indent3) -}
00703cd49b472cf3c8ac3ccf7ba43491
  $tc'Indent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Indent"#) -}
255fe5caa2b9f5cd0db2285d8ce73f14
  $tc'LArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10599861624735261172##
                   14591294203052179529##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
4efb09eaea163b7a53c34e5b63982392
  $tc'LArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LArrow2) -}
2897a1a3f1236d25860c0b8ce245c46c
  $tc'LArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LArrow"#) -}
b528701dfa38d379aadf2e2337af35b5
  $tc'LBrace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16030914392527574177##
                   10868484802586839461##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LBrace1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
55cc818e1c84d9f73185f1206f2ffb0f
  $tc'LBrace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LBrace2) -}
11b96503055168d267bc10915e04b6d1
  $tc'LBrace2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LBrace"#) -}
69952d5e123d8260b5f4ea3dc9e45552
  $tc'LFatArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15264414668826584914##
                   8238004997542702986##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LFatArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
bcda9506b87fef9281119be48419bde5
  $tc'LFatArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LFatArrow2) -}
b3cfc1fb31562d90f58e158cace04b17
  $tc'LFatArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LFatArrow"#) -}
5aeb5999130dc0f035aed1fa3cc39fa0
  $tc'LName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8602783090727260265##
                   6683123697091341956##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LName1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
b2d65c6073390294ca37a481b15210cd
  $tc'LName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LName2) -}
027bd36a426a98746d1c3f0c1a9ddb38
  $tc'LName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LName"#) -}
e6cf454f5226560e28dee03f7b68b6df
  $tc'LParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   404223410465383853##
                   16026425634393129261##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LParen1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
08110e862919d73b72c4aad10c7befdb
  $tc'LParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LParen2) -}
3bf2518c9f3cc04f46312cd78be0c9b8
  $tc'LParen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LParen"#) -}
b6020e34274ca2afbcc7694e28139b06
  $tc'LSquare :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3945695736873209434##
                   16934107070595802572##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'LSquare1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
12b47dd56cb50fdcf018d549ca061953
  $tc'LSquare1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'LSquare2) -}
327ba5153e8bd9a216fdad0b176bb755
  $tc'LSquare2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LSquare"#) -}
7d2f8a37bae6390207ae721f2b9b6bc0
  $tc'Number :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5631961913104262814##
                   4163543495399007359##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Number2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'Number1) -}
3b7c6f4ce8b340790b0f61569cc0ae3b
  $tc'Number1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2f0c20da65fefc6ef179b2beae493688
  $tc'Number2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Number3) -}
ba29e7e2eb9ce39739bd1ff7b9c52bf2
  $tc'Number3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Number"#) -}
ea041c850ddb9a3be33a6f3096ecd39c
  $tc'Pipe :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12420815057104271129##
                   1937405425581014815##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Pipe1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
3c21ccdbcbd548fe2758c26dde7cd121
  $tc'Pipe1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Pipe2) -}
d2113c922b437b62ed51fc6f8a952049
  $tc'Pipe2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pipe"#) -}
814e9b8393e346c95e42c2bbc607f547
  $tc'PositionedToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14950807745774890697##
                   11295303896351681058##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken1) -}
754fdf0a8532d5495dee07a847e3b2e9
  $tc'PositionedToken1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4169f1266b4d2ab0a707880f68b5aa8b
  $tc'PositionedToken2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'PositionedToken3) -}
303d945b40a9a09dc2f7285ce6410b94
  $tc'PositionedToken3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PositionedToken"#) -}
51968843396e6a969f7873c02274c389
  $tc'Qualifier :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1706444000540875869##
                   11645282539496898105##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Qualifier1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
a8bdc49aed9631c03d5aee4ea2f94cc0
  $tc'Qualifier1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Qualifier2) -}
a7868770c90c6995990a3a4314375aa7
  $tc'Qualifier2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Qualifier"#) -}
c6bdf971bb2d261358372a7593edce85
  $tc'RArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7867465476048363498##
                   5199975458935707236##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
9101ca780d76e475ac00204c4c6c526d
  $tc'RArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RArrow2) -}
77d1ef3e78390d17ae267204c126fde1
  $tc'RArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RArrow"#) -}
334c82e9e938e2ec42d7875a45d93d56
  $tc'RBrace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10526445249861597354##
                   5344352337381915459##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RBrace1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
466c0ae0450201489159abc4c0eb9870
  $tc'RBrace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RBrace2) -}
a610f50be19d0f1b57add654f81567dc
  $tc'RBrace2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RBrace"#) -}
df1901615153d06e5eada1df57e207bb
  $tc'RFatArrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1715619457810227970##
                   18381928197029404829##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RFatArrow1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
963d3e5c1c55ee794de2fd46fc1c3d06
  $tc'RFatArrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RFatArrow2) -}
f2366fb2f98a1ff05ed97dcd7b296b2d
  $tc'RFatArrow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RFatArrow"#) -}
6e3dce8003ff0a034a974271e08496fe
  $tc'RParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7843107566685037973##
                   17395471466869781550##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RParen1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
cd0e8cba05beec8cefc2edad2194dbda
  $tc'RParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RParen2) -}
0c9b9929f9a78fe16033b62297ee97ee
  $tc'RParen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RParen"#) -}
c057fdaa8926a868cb27f4ac23270d9d
  $tc'RSquare :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9727537247517671001##
                   14509978275693136023##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'RSquare1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
14041948f9ffe8de03e149beb61c3f3f
  $tc'RSquare1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'RSquare2) -}
b90ccb1b0753754a2088a394a24a4513
  $tc'RSquare2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RSquare"#) -}
1ed4fa279ec9a8be9a0ee291e0cbedef
  $tc'Semi :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4301835936542908815##
                   2932964071258167914##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Semi1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
860686542126027ef7230f46c07646ad
  $tc'Semi1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Semi2) -}
c7b51e900f8ada99c5e9c51deefbd7b8
  $tc'Semi2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Semi"#) -}
ae89f95d37a097492c737bad9345d79c
  $tc'StringLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13161347288861038345##
                   5927997285092019807##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral2
                   0#
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral1) -}
82c7fd030bb22d8d28bf9c4026705ec8
  $tc'StringLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a176f9c130aa5a647ae5f66e1f840d9a
  $tc'StringLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'StringLiteral3) -}
4d1cfb1e9be50cb2825b539f898d158a
  $tc'StringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLiteral"#) -}
744e51ec8aa14916661ef4714c837281
  $tc'Symbol :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10407053987751989703##
                   16840204590782224011##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Symbol1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
adce233f99750bce14d242147ab57b51
  $tc'Symbol1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Symbol2) -}
475e9b46564fa40bc2ca7d0337e602bf
  $tc'Symbol2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Symbol"#) -}
5c3ef263a4cf286b158f05013fc86c10
  $tc'Tick :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4084797847473656829##
                   3262103359160752028##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Tick1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
4eb0dd68202284bbb853bb6162682978
  $tc'Tick1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Tick2) -}
9e3b1e5908a4cb03201dae73460a022c
  $tc'Tick2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Tick"#) -}
260ba42410b1708b186cb7e409de937b
  $tc'UName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5512548091041401243##
                   3549725571122053867##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'UName1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'HoleLit1) -}
6bcbe90bd31675f810628a76cea400b5
  $tc'UName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'UName2) -}
08bd2803f4e240b2f16c04a65c7223a5
  $tc'UName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UName"#) -}
10981dad0da50d8488073cddb5ef0cd3
  $tc'Underscore :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12992962319000232925##
                   15977413381116119302##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tc'Underscore1
                   0#
                   Language.PureScript.Parser.Lexer.$tc'At1) -}
07b7e7fc3c048ab755720e9fb056de99
  $tc'Underscore1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tc'Underscore2) -}
116ea8ceedad29567d8912c47ffcdc5c
  $tc'Underscore2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Underscore"#) -}
fa2d1eddd1e480cc21bf1da5427ce03a
  $tcPositionedToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18215443856604015764##
                   16830658023888185427##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tcPositionedToken1
                   0#
                   GHC.Types.krep$*) -}
75106d92c5a066f6259ca0f3e84d57a8
  $tcPositionedToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tcPositionedToken2) -}
038534e87c5ed22bedeebebba3af5b08
  $tcPositionedToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PositionedToken"#) -}
75b7fa364f9290898a3da42c7b08ef48
  $tcToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14243732422124953673##
                   2681360174019341669##
                   Language.PureScript.Parser.Lexer.$trModule
                   Language.PureScript.Parser.Lexer.$tcToken1
                   0#
                   GHC.Types.krep$*) -}
f6cc70b3fa5499361e520b8a43f1873d
  $tcToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$tcToken2) -}
ad86095353847a70c335488ece43f240
  $tcToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Token"#) -}
988f0f88e71d52b6db2c03329a028625
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Parser.Lexer.$trModule3
                   Language.PureScript.Parser.Lexer.$trModule1) -}
e681743d34a6361d13ff4afc24b5c1d9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$trModule2) -}
275a3a233c5e44e364e6d8151bcacd31
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.Parser.Lexer"#) -}
c0a0ef4681b5daa4ebd7db7f77097c02
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Parser.Lexer.$trModule4) -}
42002af185c8c10af71d99757a21e869
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
7dc61984674c7245a0fef352d444471b
  $w$cshowsPrec ::
    Language.PureScript.Parser.Lexer.Token
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Language.PureScript.Parser.Lexer.Token)
                   (w :: GHC.Base.String) ->
                 case Language.PureScript.Parser.Lexer.prettyPrintToken
                        ww of wild { Data.Text.Internal.Text dt6 dt7 dt8 ->
                 let {
                   end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                 } in
                 letrec {
                   $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww1 end of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexWord16Array# dt6 ww1 of r# { DEFAULT ->
                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ GHC.Types.Char
                                 (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                 ($wunfold (GHC.Prim.+# ww1 1#))
                            1#
                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                      ($wunfold (GHC.Prim.+# ww1 1#))
                                 1#
                                 -> case GHC.Prim.indexWord16Array#
                                           dt6
                                           (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C#
                                         (GHC.Prim.chr#
                                            (GHC.Prim.+#
                                               (GHC.Prim.+#
                                                  (GHC.Prim.uncheckedIShiftL#
                                                     (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                     10#)
                                                  (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                               65536#)))
                                      ($wunfold (GHC.Prim.+# ww1 2#)) } } } }
                       1# -> GHC.Types.[] @ GHC.Types.Char }
                 } in
                 GHC.Base.++ @ GHC.Types.Char ($wunfold dt7) w }) -}
92440d553956789fc4446f75813bab88
  $w$j :: GHC.Prim.Char# -> Data.Text.Internal.Text -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U)>, Inline: [0] -}
1b5d61eb86e5478325c6d50fc353e856
  $wanyToken ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.Parser.Lexer.PositionedToken
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case ts of wild1 {
                        []
                        -> case t of wild2 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                           case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           w wild2
                             (Text.Parsec.Prim.State
                                @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                @ Language.PureScript.Parser.State.ParseState
                                (GHC.Types.[] @ Language.PureScript.Parser.Lexer.PositionedToken)
                                v
                                ww2)
                             (Text.Parsec.Error.ParseError
                                v
                                (GHC.Types.[] @ Text.Parsec.Error.Message)) } }
                        : t1 ts1
                        -> case t1 of wild2 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                           case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           w t
                             (Text.Parsec.Prim.State
                                @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                @ Language.PureScript.Parser.State.ParseState
                                wild1
                                v
                                ww2)
                             (Text.Parsec.Error.ParseError
                                v
                                (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } }) -}
9dfe103c340a8503d0034d84c2a2a36b
  $wisUnquotedKey ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#) ->
                 case GHC.Prim.<=# ww2 0# of lwild {
                   DEFAULT
                   -> case GHC.Prim.indexWord16Array# ww ww1 of r# { DEFAULT ->
                      case GHC.Prim.ltWord# r# 55296## of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.indexWord16Array#
                                       ww
                                       (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                Language.PureScript.Parser.Lexer.$w$j
                                  (GHC.Prim.chr#
                                     (GHC.Prim.+#
                                        (GHC.Prim.+#
                                           (GHC.Prim.uncheckedIShiftL#
                                              (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                              10#)
                                           (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                        65536#))
                                  (case ww2 of lwild3 {
                                     DEFAULT
                                     -> Data.Text.Internal.Text
                                          ww
                                          (GHC.Prim.+# ww1 2#)
                                          (GHC.Prim.-# lwild3 2#)
                                     2# -> Data.Text.Internal.empty }) }
                             1#
                             -> Language.PureScript.Parser.Lexer.$w$j
                                  (GHC.Prim.chr# (GHC.Prim.word2Int# r#))
                                  (case ww2 of lwild3 {
                                     DEFAULT
                                     -> Data.Text.Internal.Text
                                          ww
                                          (GHC.Prim.+# ww1 1#)
                                          (GHC.Prim.-# lwild3 1#)
                                     1# -> Data.Text.Internal.empty }) }
                        1#
                        -> Language.PureScript.Parser.Lexer.$w$j
                             (GHC.Prim.chr# (GHC.Prim.word2Int# r#))
                             (case ww2 of lwild2 {
                                DEFAULT
                                -> Data.Text.Internal.Text
                                     ww
                                     (GHC.Prim.+# ww1 1#)
                                     (GHC.Prim.-# lwild2 1#)
                                1# -> Data.Text.Internal.empty }) } }
                   1# -> GHC.Types.False }) -}
4bde4cf8372980bbf3dfdf2cd30f79ce
  $wlvl :: Language.PureScript.Parser.Lexer.Token -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Language.PureScript.Parser.Lexer.Token) ->
                 case Language.PureScript.Parser.Lexer.prettyPrintToken
                        ww of wild { Data.Text.Internal.Text dt6 dt7 dt8 ->
                 let {
                   end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                 } in
                 letrec {
                   $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww1 end of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexWord16Array# dt6 ww1 of r# { DEFAULT ->
                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ GHC.Types.Char
                                 (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                 ($wunfold (GHC.Prim.+# ww1 1#))
                            1#
                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                      ($wunfold (GHC.Prim.+# ww1 1#))
                                 1#
                                 -> case GHC.Prim.indexWord16Array#
                                           dt6
                                           (GHC.Prim.+# ww1 1#) of r#1 { DEFAULT ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C#
                                         (GHC.Prim.chr#
                                            (GHC.Prim.+#
                                               (GHC.Prim.+#
                                                  (GHC.Prim.uncheckedIShiftL#
                                                     (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                     10#)
                                                  (GHC.Prim.-# (GHC.Prim.word2Int# r#1) 56320#))
                                               65536#)))
                                      ($wunfold (GHC.Prim.+# ww1 2#)) } } } }
                       1# -> GHC.Types.[] @ GHC.Types.Char }
                 } in
                 $wunfold dt7 }) -}
3ad8cbbb3a737a8bbba3857e8dd58009
  $wp ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Types.Char
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.CharLiteral c
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w c
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w c
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
803f2e926bc55091bf2cd55091a0be06
  $wp1 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.UName s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
5034faaf31bd4458fb94ed61e2f02cbd
  $wp10 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Language.PureScript.PSString.PSString
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.StringLiteral s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
3e23917d33b606cf9968932f38c4b2a8
  $wp11 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Text.Internal.Text -> Data.Functor.Identity.Identity b
                          <join 1> {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: Data.Text.Internal.Text)[OneShot] ->
                          case ts of wild2 {
                            []
                            -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                               w x
                                 (Text.Parsec.Prim.State
                                    @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                    @ Language.PureScript.Parser.State.ParseState
                                    (GHC.Types.[]
                                       @ Language.PureScript.Parser.Lexer.PositionedToken)
                                    v
                                    ww2)
                                 (Text.Parsec.Error.ParseError
                                    v
                                    (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                            : t1 ts1
                            -> case t1 of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                               case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                               w x
                                 (Text.Parsec.Prim.State
                                    @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                    @ Language.PureScript.Parser.State.ParseState
                                    wild2
                                    v
                                    ww2)
                                 (Text.Parsec.Error.ParseError
                                    v
                                    (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                      } in
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.LFatArrow
                        -> $j Language.PureScript.Parser.Lexer.symbol9
                        Language.PureScript.Parser.Lexer.Colon
                        -> $j Language.PureScript.Parser.Lexer.symbol7
                        Language.PureScript.Parser.Lexer.At
                        -> $j Language.PureScript.Parser.Lexer.symbol5
                        Language.PureScript.Parser.Lexer.Symbol s -> $j s } } }) -}
607d87c9d7b5e855f93d68824c4e2640
  $wp12 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.UName s
                        -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                           let {
                             end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                           } in
                           let {
                             exit :: Data.Functor.Identity.Identity b <join 0>
                             = case ts of wild4 {
                                 []
                                 -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         (GHC.Types.[]
                                            @ Language.PureScript.Parser.Lexer.PositionedToken)
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                 : t1 ts1
                                 -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                    case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         wild4
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                           } in
                           letrec {
                             $wloop_any :: GHC.Prim.Int# -> Data.Functor.Identity.Identity b
                               <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                             = \ (ww3 :: GHC.Prim.Int#) ->
                               case GHC.Prim.>=# ww3 end of lwild {
                                 DEFAULT
                                 -> case GHC.Prim.indexWord16Array# dt6 ww3 of r# { DEFAULT ->
                                    case GHC.Prim.geWord# r# 55296## of lwild1 {
                                      DEFAULT
                                      -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                           DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#) '\''# -> $j }
                                      1#
                                      -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                           DEFAULT
                                           -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#)
                                                '\''# -> $j }
                                           1#
                                           -> case GHC.Prim.indexWord16Array#
                                                     dt6
                                                     (GHC.Prim.+# ww3 1#) of r#1 { DEFAULT ->
                                              case GHC.Prim.chr#
                                                     (GHC.Prim.+#
                                                        (GHC.Prim.+#
                                                           (GHC.Prim.uncheckedIShiftL#
                                                              (GHC.Prim.-#
                                                                 (GHC.Prim.word2Int# r#)
                                                                 55296#)
                                                              10#)
                                                           (GHC.Prim.-#
                                                              (GHC.Prim.word2Int# r#1)
                                                              56320#))
                                                        65536#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 2#)
                                                '\''# -> $j } } } } }
                                 1# -> exit }
                           } in
                           $wloop_any dt7 } } } }) -}
6eff369dff3ccc7b39c65a02ae90027d
  $wp2 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.HoleLit n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
982873f5fe9e42e4fb7f7391921ee5ac
  $wp3 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.LName s
                        -> case GHC.List.elem
                                  @ Data.Text.Internal.Text
                                  Data.Text.$fEqText
                                  s
                                  Language.PureScript.Parser.Lexer.reservedPsNames of wild3 {
                             GHC.Types.False
                             -> case ts of wild4 {
                                  []
                                  -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w s
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          (GHC.Types.[]
                                             @ Language.PureScript.Parser.Lexer.PositionedToken)
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                  : t1 ts1
                                  -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                     case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w s
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          wild4
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                             GHC.Types.True -> $j } } } }) -}
dca04435b0e4cd0158414522d40db2f2
  $wp4 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Types.Int
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Indent n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
6c6cfba2b12f4df83c3794d8aba132ae
  $wp5 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.LName s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
472050633d6c19de9efc7a0b591addf4
  $wp6 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.UName s
                        -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                           let {
                             end :: GHC.Prim.Int# = GHC.Prim.+# dt7 dt8
                           } in
                           let {
                             exit :: Data.Functor.Identity.Identity b <join 0>
                             = case ts of wild4 {
                                 []
                                 -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         (GHC.Types.[]
                                            @ Language.PureScript.Parser.Lexer.PositionedToken)
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                 : t1 ts1
                                 -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                    case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                    w wild3
                                      (Text.Parsec.Prim.State
                                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                         @ Language.PureScript.Parser.State.ParseState
                                         wild4
                                         v
                                         ww2)
                                      (Text.Parsec.Error.ParseError
                                         v
                                         (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                           } in
                           letrec {
                             $wloop_any :: GHC.Prim.Int# -> Data.Functor.Identity.Identity b
                               <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                             = \ (ww3 :: GHC.Prim.Int#) ->
                               case GHC.Prim.>=# ww3 end of lwild {
                                 DEFAULT
                                 -> case GHC.Prim.indexWord16Array# dt6 ww3 of r# { DEFAULT ->
                                    case GHC.Prim.geWord# r# 55296## of lwild1 {
                                      DEFAULT
                                      -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                           DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#) '_'# -> $j }
                                      1#
                                      -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                           DEFAULT
                                           -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 1#)
                                                '_'# -> $j }
                                           1#
                                           -> case GHC.Prim.indexWord16Array#
                                                     dt6
                                                     (GHC.Prim.+# ww3 1#) of r#1 { DEFAULT ->
                                              case GHC.Prim.chr#
                                                     (GHC.Prim.+#
                                                        (GHC.Prim.+#
                                                           (GHC.Prim.uncheckedIShiftL#
                                                              (GHC.Prim.-#
                                                                 (GHC.Prim.word2Int# r#)
                                                                 55296#)
                                                              10#)
                                                           (GHC.Prim.-#
                                                              (GHC.Prim.word2Int# r#1)
                                                              56320#))
                                                        65536#) of wild4 {
                                                DEFAULT -> $wloop_any (GHC.Prim.+# ww3 2#)
                                                '_'# -> $j } } } } }
                                 1# -> exit }
                           } in
                           $wloop_any dt7 } } } }) -}
ced02cb598a2bc148b92e13fdb560fcb
  $wp7 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: GHC.Integer.Type.Integer
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      let {
                        $j :: Data.Functor.Identity.Identity b <join 0>
                        = w1
                            (Text.Parsec.Error.ParseError
                               ww1
                               (GHC.Types.:
                                  @ Text.Parsec.Error.Message
                                  (case Language.PureScript.Parser.Lexer.$wlvl
                                          ds3 of dt6 { DEFAULT ->
                                   Text.Parsec.Error.SysUnExpect dt6 })
                                  (GHC.Types.[] @ Text.Parsec.Error.Message)))
                      } in
                      case ds3 of wild2 {
                        DEFAULT -> $j
                        Language.PureScript.Parser.Lexer.Number ds5
                        -> case ds5 of wild3 {
                             Data.Either.Left n
                             -> case ts of wild4 {
                                  []
                                  -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w n
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          (GHC.Types.[]
                                             @ Language.PureScript.Parser.Lexer.PositionedToken)
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                  : t1 ts1
                                  -> case t1 of wild5 { Language.PureScript.Parser.Lexer.PositionedToken ds6 ds7 ds8 ds9 ds10 ->
                                     case ds6 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                     w n
                                       (Text.Parsec.Prim.State
                                          @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                          @ Language.PureScript.Parser.State.ParseState
                                          wild4
                                          v
                                          ww2)
                                       (Text.Parsec.Error.ParseError
                                          v
                                          (GHC.Types.[] @ Text.Parsec.Error.Message)) } } }
                             Data.Either.Right ipv -> $j } } } }) -}
ebae1ea677468b12e3bc3f9847c22762
  $wp8 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Number n
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w n
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
1b9c3304ff02f976f614021ee3de7bd5
  $wp9 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Text.Parsec.Pos.SourcePos
    -> Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w :: Data.Text.Internal.Text
                         -> Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b)
                   (w1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w1 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        DEFAULT
                        -> w1
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case Language.PureScript.Parser.Lexer.$wlvl
                                           wild2 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        Language.PureScript.Parser.Lexer.Qualifier s
                        -> case ts of wild3 {
                             []
                             -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                             : t1 ts1
                             -> case t1 of wild4 { Language.PureScript.Parser.Lexer.PositionedToken ds5 ds6 ds7 ds8 ds9 ->
                                case ds5 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w s
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild3
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } } }) -}
58828b69c9e9258852b02119bce25043
  $wparseComment ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0] -}
8d8fb14b8b685c09bf5524d0d8259b71
  $wparsePositionedToken ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wmany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   (Language.PureScript.Parser.Lexer.lex5 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   @ b
                   w
                   (\ (x :: [Language.PureScript.Comments.Comment])
                      (s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    Language.PureScript.Parser.Lexer.lex12
                      @ u
                      x
                      @ b
                      s2
                      w1
                      w3
                      (\ (x1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                         (s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                         (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                       w1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w3 (Text.Parsec.Error.mergeError err err')))
                   w3
                   (\ (x :: [Language.PureScript.Comments.Comment])
                      (s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    Language.PureScript.Parser.Lexer.lex12
                      @ u
                      x
                      @ b
                      s2
                      w1
                      w3
                      (\ (x1 :: Language.PureScript.Parser.Lexer.PositionedToken)
                         (s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)[OneShot]
                         (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                       w2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w3 (Text.Parsec.Error.mergeError err err')))) -}
ffd26c3919f1d92c08094b94358f6a4b
  $wtoken ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> forall b.
       [Language.PureScript.Parser.Lexer.PositionedToken]
       -> Text.Parsec.Pos.SourcePos
       -> Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S,1*U><L,U><L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
                   @ b
                   (ww :: [Language.PureScript.Parser.Lexer.PositionedToken])
                   (ww1 :: Text.Parsec.Pos.SourcePos)
                   (ww2 :: Language.PureScript.Parser.State.ParseState)
                   (w1 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case ww of wild {
                   [] -> w2 (Text.Parsec.Error.ParseError ww1 Text.Parsec.Prim.token2)
                   : t ts
                   -> case w (case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                              ds3 }) of wild2 {
                        GHC.Base.Nothing
                        -> w2
                             (Text.Parsec.Error.ParseError
                                ww1
                                (GHC.Types.:
                                   @ Text.Parsec.Error.Message
                                   (case t of ww3 { Language.PureScript.Parser.Lexer.PositionedToken ww4 ww5 ww6 ww7 ww8 ->
                                    case Language.PureScript.Parser.Lexer.$wlvl
                                           ww7 of dt6 { DEFAULT ->
                                    Text.Parsec.Error.SysUnExpect dt6 } })
                                   (GHC.Types.[] @ Text.Parsec.Error.Message)))
                        GHC.Base.Just x
                        -> case ts of wild1 {
                             []
                             -> case t of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                                case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w1
                                  x
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     (GHC.Types.[]
                                        @ Language.PureScript.Parser.Lexer.PositionedToken)
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } }
                             : t1 ts1
                             -> case t1 of wild3 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                                case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                w1
                                  x
                                  (Text.Parsec.Prim.State
                                     @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                     @ Language.PureScript.Parser.State.ParseState
                                     wild1
                                     v
                                     ww2)
                                  (Text.Parsec.Error.ParseError
                                     v
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)) } } } } }) -}
6c8791e42c32f667ce201134ebea6e78
  type Lexer u a =
    Text.Parsec.Prim.Parsec Data.Text.Internal.Text u a
bc5773f44100b87481d9bda3f9e246b7
  data PositionedToken
    = PositionedToken {ptSourcePos :: Text.Parsec.Pos.SourcePos,
                       ptEndPos :: Text.Parsec.Pos.SourcePos,
                       ptPrevEndPos :: GHC.Base.Maybe Text.Parsec.Pos.SourcePos,
                       ptToken :: Language.PureScript.Parser.Lexer.Token,
                       ptComments :: [Language.PureScript.Comments.Comment]}
bfca495d98b2e792a78f6b37fc87fcb4
  data Token
    = LParen
    | RParen
    | LBrace
    | RBrace
    | LSquare
    | RSquare
    | Indent GHC.Types.Int
    | LArrow
    | RArrow
    | LFatArrow
    | RFatArrow
    | Colon
    | DoubleColon
    | Equals
    | Pipe
    | Tick
    | Dot
    | Comma
    | Semi
    | At
    | Underscore
    | LName Data.Text.Internal.Text
    | UName Data.Text.Internal.Text
    | Qualifier Data.Text.Internal.Text
    | Symbol Data.Text.Internal.Text
    | CharLiteral GHC.Types.Char
    | StringLiteral Language.PureScript.PSString.PSString
    | Number (Data.Either.Either
                GHC.Integer.Type.Integer GHC.Types.Double)
    | HoleLit Data.Text.Internal.Text
6e8d7b68c7546ba407a16e8526c7556f
  type TokenParser a =
    Text.Parsec.Prim.Parsec
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      a
9a9b6cc76ec3dbbf67d6554ce65f36b2
  anyToken ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.anyToken1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.Parser.Lexer.PositionedToken>_R)) -}
935956094e3c4fcee976c93745806cde
  anyToken1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wanyToken
                   @ b
                   ww1
                   ww2
                   ww3
                   w1
                   w4 }) -}
4583bf023837ea7f761b9fd5a1e6fb6a
  at :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.At) -}
2aef1f8effaa82424b998862c34e06ab
  braces ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.braces1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
58be7ea47da787368537cf267416c420
  braces1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lbrace
                   Language.PureScript.Parser.Lexer.rbrace
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
5a592564852c039d596e33d11ef78a9e
  charLiteral ::
    Language.PureScript.Parser.Lexer.TokenParser GHC.Types.Char
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.charLiteral1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Types.Char>_R)) -}
f2396f48c239aed48558aededaeaa886
  charLiteral1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Language.PureScript.Parser.Lexer.charLiteral4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Language.PureScript.Parser.Lexer.charLiteral2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
9c39c436b527b3ed5d0c2db3601821b4
  charLiteral2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.charLiteral_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
7761c8e98a9bc0665a862bb076c64978
  charLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("char literal"#) -}
06aa0f4d6053d7512d481db1f459cc88
  charLiteral4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp @ b ww1 ww2 ww3 w1 w4 }) -}
bc28eb524544fe3ca5aa19cd9a704b4f
  charLiteral_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.charLiteral3) -}
0f0cb61fe317b60daa06f8f230f69470
  colon :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Colon) -}
52ff63f9da68caea93f8dbe50c070988
  comma :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Comma) -}
eb2688c2d4650f36f9e2956a5175779a
  commaSep ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.commaSep2
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
370ade44ebf28ca0ea4e39090759c92d
  commaSep1 ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.commaSep3
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
ed69dc3784ac03bedf2f629fbefc9fb2
  commaSep2 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (6, True, True)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.comma
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
67ef66d5ce996560f3dfd5b4bd2c1582
  commaSep3 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy1
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.comma
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
d4e1a14321595b7f35da211d957677b6
  dconsname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.dconsname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
12aa2b8428bf729404bdc9d42c5bc45b
  dconsname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.dconsname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
7733d9fb27c4645788e48b3388c15830
  dconsname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.dconsname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
e4433995d526fcb0c1b7106da65c2a87
  dconsname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("data constructor name"#) -}
d7d5ec1d4cd20887c531b678cb465b93
  dconsname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp1 @ b ww1 ww2 ww3 w1 w4 }) -}
8b9f9c983fe3f5dc9a9d56acd392d121
  dconsname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.dconsname3) -}
e34ec3ff7d1c1f0364c0678896f18f4d
  dot :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Dot) -}
05b6cfb8f46b56e88737d68e35a22068
  doubleColon :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.DoubleColon) -}
35eb066ad0b667ec5a0ef3672c1f5c35
  equals :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Equals) -}
d128f2ea8cc360ec08b3ecb90951500a
  holeLit ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.holeLit1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
b3b41b51167189a9eb3d91510fd335ea
  holeLit1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.holeLit4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.holeLit2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
59a83412805482eaef139a2980c73f29
  holeLit2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.holeLit_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
3e48266a2b1a989ff840002b03016e41
  holeLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("hole literal"#) -}
15b5a65334029b2197e163f74159717c
  holeLit4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp2 @ b ww1 ww2 ww3 w1 w4 }) -}
221edc34a58dae877503975131410f33
  holeLit_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.holeLit3) -}
694a9255e1b6cb3d8c5e23ccd5c0704b
  identifier ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.identifier1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
57b167411db34b6231f20f01c5e9c54e
  identifier1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.identifier4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.identifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
bc836aa887d27f96847c0c1aad561273
  identifier2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.identifier_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c73638d58a558815a9d060900b28dc
  identifier3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("identifier"#) -}
a386f9cb874659bc75f5b9f0651e0575
  identifier4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp3 @ b ww1 ww2 ww3 w1 w4 }) -}
45fbafb7783f8aba13f807bdbe5120dd
  identifier_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.identifier3) -}
5e15bca08d9cebece5df1a171959247b
  indent ::
    Language.PureScript.Parser.Lexer.TokenParser GHC.Types.Int
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.indent1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Types.Int>_R)) -}
20e12beaf8d3d7395fb7cd405bdd0bf1
  indent1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Types.Int
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Types.Int
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Int
                   Language.PureScript.Parser.Lexer.indent4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Int>_R))
                   Language.PureScript.Parser.Lexer.indent2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
951958718c29af4419b5bd665d273ebc
  indent2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.indent_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
b889758bacf595c3ed04361668269286
  indent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("indentation"#) -}
83663a41a33e7f7bbebba20ccc239262
  indent4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Int
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Types.Int
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Types.Int
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp4 @ b ww1 ww2 ww3 w1 w4 }) -}
52b8971894fb2369d80d84edaad06220
  indentAt ::
    Text.Parsec.Pos.Column
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U)> -}
b5590da613853bdde664676e28b2ba82
  indent_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.indent3) -}
b88848d8ff741526e8260cef1d5c3ede
  isSymbolChar :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: (\ (c :: GHC.Types.Char) ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        c
                        Language.PureScript.Parser.Lexer.isSymbolChar1 of wild {
                   GHC.Types.False
                   -> case c of wild1 { GHC.Types.C# c1 ->
                      case GHC.Prim.ltChar# c1 '\128'# of lwild {
                        DEFAULT -> GHC.Unicode.$wisSymbol c1 1# -> GHC.Types.False } }
                   GHC.Types.True -> GHC.Types.True }) -}
122318939130183429e53102708f76e1
  isSymbolChar1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.isSymbolChar2) -}
49db90ac045fc8e27d31be41dc6e9413
  isSymbolChar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":!#$%&*+./<=>?@\\^|-~"#) -}
99c36d6ee62cf0e9f1cb07f067722f16
  isUnquotedKey :: Data.Text.Internal.Text -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wisUnquotedKey ww1 ww2 ww3 }) -}
3d9765d6ed6aa1077d78b41f3ed8217e
  kiname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.kiname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
8a4865c4468bd6b195f318b5785c80e0
  kiname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.kiname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
1629bdb1b86328339cd5aac203c92f2e
  kiname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.kiname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
66f6e6227d3fe2a07511f39cda5917db
  kiname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("kind name"#) -}
dd12e881cbc1ccfaea885ed59611360d
  kiname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.kiname3) -}
bda6cd537e95497467b620a84d8684a4
  larrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LArrow) -}
a36867a5e84e41329f8d19141dcbbfe9
  lbrace :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LBrace) -}
2288b6151bebf7b01b4d73039b433c5f
  lex ::
    GHC.IO.FilePath
    -> Data.Text.Internal.Text
    -> Data.Either.Either
         Text.Parsec.Error.ParseError
         [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (f2 :: GHC.IO.FilePath)
                   (s :: Data.Text.Internal.Text) ->
                 case (Text.Parsec.Prim.runPT
                         @ Data.Text.Internal.Text
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                         Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                         (Language.PureScript.Parser.Lexer.lex1 @ ())
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                         GHC.Tuple.()
                         f2
                         s)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild {
                   Data.Either.Left x -> wild
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ Text.Parsec.Error.ParseError
                        @ [Language.PureScript.Parser.Lexer.PositionedToken]
                        (Language.PureScript.Parser.Lexer.updatePositions y) }) -}
165a8f5e3a7cae0959be59d915a633f5
  lex1 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex3 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                   (Language.PureScript.Parser.Lexer.lex2 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
1f07d3a0691b93af6bc55436dcbf245c
  lex10 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: [Language.PureScript.Parser.Lexer.PositionedToken]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: [Language.PureScript.Parser.Lexer.PositionedToken]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wmany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   (Language.PureScript.Parser.Lexer.lex11 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Parser.Lexer.PositionedToken>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
0c4cd7f78ea110c9bf7ca769a3c6c3fb
  lex11 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Parser.Lexer.PositionedToken
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Parser.Lexer.PositionedToken
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Lexer.$wparsePositionedToken
                   @ u
                   @ b
                   w
                   w1
                   w3
                   w4) -}
ab5ebf5a710bbc00a11996feea023b18
  lex12 ::
    [Language.PureScript.Comments.Comment]
    -> forall b.
       Text.Parsec.Prim.State Data.Text.Internal.Text u
       -> (Language.PureScript.Parser.Lexer.PositionedToken
           -> Text.Parsec.Prim.State Data.Text.Internal.Text u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Language.PureScript.Parser.Lexer.PositionedToken
           -> Text.Parsec.Prim.State Data.Text.Internal.Text u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
2690caeec46b333d27e8e24c4e93b581
  lex2 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Combinator.eof1
                   @ Data.Text.Internal.Text
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ u
                   Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                   GHC.Show.$fShowChar) -}
dd74eeb138f16c7f9dad70705934cf15
  lex3 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex9 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                   (Language.PureScript.Parser.Lexer.lex4 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
74c1e6e83a99c17a277e316c53f5435a
  lex4 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wskipMany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   (Language.PureScript.Parser.Lexer.lex5 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
3215ad0ed3bd36a5719215406276e0ec
  lex5 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT1
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Comments.Comment
                   @ ()
                   (Language.PureScript.Parser.Lexer.lex8 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.Comments.Comment>_R))
                   (Language.PureScript.Parser.Lexer.lex6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))) -}
05c79b0291c3e11d241f30382d55b8a3
  lex6 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w2 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: ()
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.$wskipMany
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Language.PureScript.Parser.Lexer.lex7 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b
                   w1
                   w2
                   w3
                   w4) -}
d814086d7926db78ccbb039463495010
  lex7 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   (w2 :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ Data.Text.Internal.Text
                   @ Data.Functor.Identity.Identity
                   @ u
                   Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                   GHC.Unicode.isSpace
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
8816852be86129fbfdb628bcdb760f11
  lex8 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.Comments.Comment
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(U)><L,A><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b
                   (w :: Text.Parsec.Prim.State Data.Text.Internal.Text u)
                   (w1 :: Language.PureScript.Comments.Comment
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.Comments.Comment
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text u
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Language.PureScript.Parser.Lexer.$wparseComment
                   @ u
                   @ b
                   w
                   w1
                   w3
                   w4) -}
5e21e3036f8a6d2282f3046618690137
  lex9 ::
    Text.Parsec.Prim.State Data.Text.Internal.Text u
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Language.PureScript.Parser.Lexer.PositionedToken]
        -> Text.Parsec.Prim.State Data.Text.Internal.Text u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (\ @ u ->
                 Text.Parsec.Prim.$fApplicativeParsecT2
                   @ Data.Text.Internal.Text
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   (Language.PureScript.Parser.Lexer.lex6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   (Language.PureScript.Parser.Lexer.lex10 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))) -}
04037475ff800ffd3538c5f78c35b5ca
  lexLenient ::
    GHC.IO.FilePath
    -> Data.Text.Internal.Text
    -> Data.Either.Either
         Text.Parsec.Error.ParseError
         [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (f2 :: GHC.IO.FilePath)
                   (s :: Data.Text.Internal.Text) ->
                 case (Text.Parsec.Prim.runPT
                         @ Data.Text.Internal.Text
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                         Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                         (Language.PureScript.Parser.Lexer.lex3 @ ())
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                         GHC.Tuple.()
                         f2
                         s)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild {
                   Data.Either.Left x -> wild
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ Text.Parsec.Error.ParseError
                        @ [Language.PureScript.Parser.Lexer.PositionedToken]
                        (Language.PureScript.Parser.Lexer.updatePositions y) }) -}
c89c8bc89a5f568f39d918aff246bb53
  lex_$sgo2 ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> Language.PureScript.Parser.Lexer.PositionedToken
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(A,U,A,A,A)><L,1*U> -}
6add5a6ecd453b66182c8f1fcb016cd2
  lfatArrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LFatArrow) -}
e6d2248b6cef9835fc21ed990a9a9f5a
  lname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.lname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
7a4cb2585f8ce0816fb7104b2c5cbbda
  lname' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
b3a6c4962e56842616ecba0bbe6f9133
  lname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.lname2
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.identifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
49bef2846069494729ccaf0b6f16a927
  lname2 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp5 @ b ww1 ww2 ww3 w1 w4 }) -}
21204f8e335c4cce6e69a16a21d990c6
  lparen :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LParen) -}
ae7ca44cd95949caf46aa72ad7d9a2ae
  lsquare :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.LSquare) -}
c7799d8c0dae200e937243a93bb9e486
  match ::
    Language.PureScript.Parser.Lexer.Token
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U> -}
ddb7a12738546f3d739d4eae51236357
  mname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.mname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
e1b52e4579ab2336ee0ad6f2c7b5b7da
  mname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.mname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.mname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
3cf16cfe843684a833b0546f8f1d2bc7
  mname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.mname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
8296f57edbfd93f4cc95e578fd2d9aeb
  mname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("module name"#) -}
706ba28f025087f9f388e22ae6071b3b
  mname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp6 @ b ww1 ww2 ww3 w1 w4 }) -}
da4846b2d7dd79a855ca5e8d3e2b5868
  mname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.mname3) -}
12b58cf860886eed904b838d83bc4667
  natural ::
    Language.PureScript.Parser.Lexer.TokenParser
      GHC.Integer.Type.Integer
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.natural1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Integer.Type.Integer>_R)) -}
594b97765b3ca293dd7d3114fad502c4
  natural1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: GHC.Integer.Type.Integer
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: GHC.Integer.Type.Integer
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ GHC.Integer.Type.Integer
                   Language.PureScript.Parser.Lexer.natural4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Integer.Type.Integer>_R))
                   Language.PureScript.Parser.Lexer.natural2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
d1af57e08a663cfb18b111de735161be
  natural2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.natural_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
639002702380aadfbb46379a8e215bc5
  natural3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("natural"#) -}
e5d7d962864399c95c04e1b9e0f1b056
  natural4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Integer.Type.Integer
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: GHC.Integer.Type.Integer
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Integer.Type.Integer
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp7 @ b ww1 ww2 ww3 w1 w4 }) -}
8aab6c3bdca9d42d8afb6c3575b3448a
  natural_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.natural3) -}
fcb4800a1d23aa2f7711b8499f312aca
  number ::
    Language.PureScript.Parser.Lexer.TokenParser
      (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.number1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Either.Either
                             GHC.Integer.Type.Integer GHC.Types.Double>_R)) -}
3f639708df0159bf8ab24e85f110376b
  number1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Either.Either
                              GHC.Integer.Type.Integer GHC.Types.Double
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Either.Either
                              GHC.Integer.Type.Integer GHC.Types.Double
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double)
                   Language.PureScript.Parser.Lexer.number3
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double>_R))
                   Language.PureScript.Parser.Lexer.number_msgs
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
254c5e80a0dbbd9448dcc8dbe81120fc
  number2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("number"#) -}
0832d4933865559107347f509d20f78b
  number3 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Either.Either GHC.Integer.Type.Integer GHC.Types.Double
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp8 @ b ww1 ww2 ww3 w1 w4 }) -}
7e38f3dc44a0da8793c4d9cee8aff7d1
  number_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.number2) -}
64875443aecd1de23dbabd37f1a433c3
  number_msgs :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.number_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
537455fc7f82a6049320a8434f7b3d11
  parens ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.parens1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
6ae81d7cd773a65f54dcadc4535957d8
  parens1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lparen
                   Language.PureScript.Parser.Lexer.rparen
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
54b83fcd00e53bf35b33618e963bdab7
  pipe :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Pipe) -}
21832ca05f6469eeec68f71abcb014fa
  prettyPrintToken ::
    Language.PureScript.Parser.Lexer.Token -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,1*U> -}
bc5773f44100b87481d9bda3f9e246b7
  ptComments ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> [Language.PureScript.Comments.Comment]
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds5 }) -}
bc5773f44100b87481d9bda3f9e246b7
  ptEndPos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLL),1*U(A,1*U(U,U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds2 }) -}
bc5773f44100b87481d9bda3f9e246b7
  ptPrevEndPos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> GHC.Base.Maybe Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSLL),1*U(A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds3 }) -}
bc5773f44100b87481d9bda3f9e246b7
  ptSourcePos ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Text.Parsec.Pos.SourcePos
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U,U,U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds1 }) -}
bc5773f44100b87481d9bda3f9e246b7
  ptToken ::
    Language.PureScript.Parser.Lexer.PositionedToken
    -> Language.PureScript.Parser.Lexer.Token
  RecSel Left Language.PureScript.Parser.Lexer.PositionedToken
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Parser.Lexer.PositionedToken) ->
                 case ds of wild { Language.PureScript.Parser.Lexer.PositionedToken ds1 ds2 ds3 ds4 ds5 ->
                 ds4 }) -}
10d4e9a621b54ed0a86368b9d31aa39c
  qualifier ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.qualifier1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
82ed4bc09ec4ea5236bafa9ca20efbde
  qualifier1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.qualifier4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.qualifier2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
c3284ca321d51d323e237596ea9e4657
  qualifier2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.qualifier_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
6a8b4fcb61b7c0fd92e439d93982f9d9
  qualifier3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("qualifier"#) -}
6805ab2beafaad3edb1cb26dae36b5df
  qualifier4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp9 @ b ww1 ww2 ww3 w1 w4 }) -}
3cdb6d634481903732a484aa8fcf33bd
  qualifier_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.qualifier3) -}
b1890175eb712a279e1082f12de6600e
  rarrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RArrow) -}
553d5fd3ed9921a7f0c995ce30a0bc07
  rbrace :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RBrace) -}
ec1bcb71bd3278035364d5b23f87537a
  reserved ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
739f1ca5d96f908c4e6634a8ecca62a4
  reservedPsNames :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames70
                   Language.PureScript.Parser.Lexer.reservedPsNames1) -}
6125b449d9302b98e45f95130b09387b
  reservedPsNames1 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames68
                   Language.PureScript.Parser.Lexer.reservedPsNames2) -}
af783281435f074ab68dd4fc77930190
  reservedPsNames10 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames50
                   Language.PureScript.Parser.Lexer.reservedPsNames11) -}
c8af9f9b55d395c49472ca393bbfaa4c
  reservedPsNames11 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames48
                   Language.PureScript.Parser.Lexer.reservedPsNames12) -}
1f63185d82f599a5e58e7da97d9bb4cf
  reservedPsNames12 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames46
                   Language.PureScript.Parser.Lexer.reservedPsNames13) -}
a43a45fc953c39061bb1df0e673f7518
  reservedPsNames13 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames44
                   Language.PureScript.Parser.Lexer.reservedPsNames14) -}
760bb421935d7b07a27a610bb229cab9
  reservedPsNames14 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames42
                   Language.PureScript.Parser.Lexer.reservedPsNames15) -}
763721a1e9239806bd1bfd269560fbf3
  reservedPsNames15 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames40
                   Language.PureScript.Parser.Lexer.reservedPsNames16) -}
1aa164236a364a2bea60414f918d9f5a
  reservedPsNames16 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames38
                   Language.PureScript.Parser.Lexer.reservedPsNames17) -}
2fd9a3c573c485975cc7b191e8623b1a
  reservedPsNames17 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames36
                   Language.PureScript.Parser.Lexer.reservedPsNames18) -}
7e9a7bc30bd3092f7e8300cc5d3e6053
  reservedPsNames18 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames34
                   Language.PureScript.Parser.Lexer.reservedPsNames19) -}
223e621b0e8dd95a39def5c32eb28e96
  reservedPsNames19 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames32
                   Language.PureScript.Parser.Lexer.reservedPsNames20) -}
c738e8b814ada6ee7313e7c3bc50244a
  reservedPsNames2 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames66
                   Language.PureScript.Parser.Lexer.reservedPsNames3) -}
f4b0dfa6353b8603734033c65a70f049
  reservedPsNames20 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames30
                   Language.PureScript.Parser.Lexer.reservedPsNames21) -}
d8a322262f3c57db8ae860cbffe5866c
  reservedPsNames21 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames28
                   Language.PureScript.Parser.Lexer.reservedPsNames22) -}
4c49411fc906f84058a4b01c80f57eea
  reservedPsNames22 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames26
                   Language.PureScript.Parser.Lexer.reservedPsNames23) -}
555b9112a6235cf8315ff2ef99ed1aea
  reservedPsNames23 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames24
                   (GHC.Types.[] @ Data.Text.Internal.Text)) -}
136a69ae37ecb5c1c83688a603e8bdf3
  reservedPsNames24 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames25) -}
bb98d25e25c22dabc5f6839533f4397c
  reservedPsNames25 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("where"#) -}
351a5a669042f205a5a6c8b92511da43
  reservedPsNames26 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames27) -}
a2c3c6b6f464ff0f14fdbeb41293c4d3
  reservedPsNames27 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("in"#) -}
660115768f9891bcd617c71c9ad4f3c1
  reservedPsNames28 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames29) -}
b89f58c769b3b2ccb8d3d01be27bb682
  reservedPsNames29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("false"#) -}
eeab95e76fcbe2ab4f3f2e9a25af4fd5
  reservedPsNames3 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames64
                   Language.PureScript.Parser.Lexer.reservedPsNames4) -}
3929021a0a49e7bf81c35fff07324292
  reservedPsNames30 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames31) -}
7a541cb013190c347ac886b86c5b9be0
  reservedPsNames31 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("true"#) -}
e2dc0262ef63abef9c4658300d8318fb
  reservedPsNames32 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames33) -}
3e201b715a0f6178baf960bbacf0efa4
  reservedPsNames33 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("let"#) -}
c313df62f0f4814c627d66ca95a3a323
  reservedPsNames34 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames35) -}
06d9071628874d5615656a21ec5197e0
  reservedPsNames35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ado"#) -}
2451e9552f3248407c45819b9d2e6025
  reservedPsNames36 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames37) -}
836cc34ec2c1254d85df9630b802d7a5
  reservedPsNames37 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("do"#) -}
959a6d1f9eea59d80c8feb7baaa259fe
  reservedPsNames38 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames39) -}
a1bf00cc18e580b044daae647f6769c5
  reservedPsNames39 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("else"#) -}
16cf2741ae3b535af586a8fc7b1030a3
  reservedPsNames4 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames62
                   Language.PureScript.Parser.Lexer.reservedPsNames5) -}
fb73232a1b23f94292890edc855799e6
  reservedPsNames40 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames41) -}
571aa1a6ace35ba782bdaef12df9d85d
  reservedPsNames41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("then"#) -}
ecef3f2f7b07b963a466bef8a8155b9e
  reservedPsNames42 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames43) -}
84e7cc1b5cd725cc3e20dc5dd5e7f2f4
  reservedPsNames43 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("if"#) -}
d1918fbd1566f1f089728201902d4160
  reservedPsNames44 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames45) -}
f299a8e0c158c3f014f16d1ca7a72847
  reservedPsNames45 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("of"#) -}
8e0873ffe5dfa4e8c921e52654eb10b4
  reservedPsNames46 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames47) -}
2d8d49203071eaf145857554a88a5bfa
  reservedPsNames47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("case"#) -}
5730b9c7368fa75752b9b469f89da08a
  reservedPsNames48 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames49) -}
da48c643d7fa1603f62256a9ea420593
  reservedPsNames49 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("module"#) -}
542de807ffaf470a75444dbbf44b7025
  reservedPsNames5 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames60
                   Language.PureScript.Parser.Lexer.reservedPsNames6) -}
9c4e35f917b1507f7d55960ec0ff8063
  reservedPsNames50 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames51) -}
c6a540c32e330fcf22a5c6421a101928
  reservedPsNames51 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("derive"#) -}
3b2bb4daa9fcab364eb79c1c6e8c2fec
  reservedPsNames52 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames53) -}
def92a54205d5ee726dc9c30cd012dce
  reservedPsNames53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("instance"#) -}
95ca6dbc9fe41077cbec122d4a491ca2
  reservedPsNames54 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames55) -}
ce05217cfa4891ace78b45feae6d2bef
  reservedPsNames55 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("class"#) -}
b44b63cdf6cdf753fa00162447051db7
  reservedPsNames56 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames57) -}
da8883561488a73d36b9da2f9bd2be52
  reservedPsNames57 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infix"#) -}
06c01240b4e9c97965d8cba7c2f6dd35
  reservedPsNames58 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames59) -}
b2a4e6af9d4548b48d74c6d722c30fc8
  reservedPsNames59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infixr"#) -}
632b2c850a924730ea6d8c934e951019
  reservedPsNames6 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames58
                   Language.PureScript.Parser.Lexer.reservedPsNames7) -}
c6198c239942b16577814e61ef3222e4
  reservedPsNames60 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames61) -}
43f81e46619069f21c454095dc124262
  reservedPsNames61 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("infixl"#) -}
ea30cbe548ef46d52524640e27aba6f3
  reservedPsNames62 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames63) -}
c0a10e3bf3ec5116afa1228846b0d019
  reservedPsNames63 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("import"#) -}
21408c83f79431a6212a269cbd081ce3
  reservedPsNames64 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames65) -}
2b5263ff9e68a9470a90e69a24b5bd5d
  reservedPsNames65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("foreign"#) -}
0c92bc9a07bcffa0e2f15ffa7de61999
  reservedPsNames66 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames67) -}
2a12323394b77e7ee9d5e609adf070c0
  reservedPsNames67 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("type"#) -}
e0cd562a1479885e5d90fd97d731cb1a
  reservedPsNames68 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames69) -}
35a753a240dfa39b5a3ff0efed4200ab
  reservedPsNames69 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("newtype"#) -}
ee4e723a160d685c57f9a480e6c03a34
  reservedPsNames7 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames56
                   Language.PureScript.Parser.Lexer.reservedPsNames8) -}
5a4f5f47947828852b977605cc2d9dfb
  reservedPsNames70 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedPsNames71) -}
e58570e9d43ac1e61cea078bd8e7e4c1
  reservedPsNames71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("data"#) -}
5dd44ec351d6562030a16c80797cd78b
  reservedPsNames8 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames54
                   Language.PureScript.Parser.Lexer.reservedPsNames9) -}
1e81bf63651ac9712c76581ecaaf7e8e
  reservedPsNames9 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedPsNames52
                   Language.PureScript.Parser.Lexer.reservedPsNames10) -}
c94792c617ae9c1884d6047d34859737
  reservedTypeNames :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.reservedTypeNames1
                   Language.PureScript.Parser.Lexer.reservedPsNames23) -}
931c191ed0b2de01e7a245bc6cef1aac
  reservedTypeNames1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.reservedTypeNames2) -}
ba42c3bada0d8da38694fbe74e04a17e
  reservedTypeNames2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("forall"#) -}
ed0b513d8da554887e6e09347f94d534
  rfatArrow :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RFatArrow) -}
abce595f7004f2566281f858f165d45b
  rparen :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RParen) -}
f9a70c0a4ad24785119602da8a838629
  rsquare :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.RSquare) -}
2f7b4f7b4904f66e099015d9867fd10a
  semi :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Semi) -}
1ee094a5f5284541e42355424b8cc75e
  semiSep ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.semiSep2
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
f098d8e7a61ec61f38ceabc445a169ac
  semiSep1 ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser [a]
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.semiSep3
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <[a]>_R)) -}
35876f79c34ad2abe646cbe6d0d7bf7c
  semiSep2 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (6, True, True)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.semi
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
b568075117792df8a37e3d52a0afa950
  semiSep3 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (y :: Text.Parsec.Prim.ParsecT
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState
                           Data.Functor.Identity.Identity
                           a)
                   @ b
                   (w3 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w4 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: [a]
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wsepBy1
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ a
                   @ ()
                   y
                   Language.PureScript.Parser.Lexer.semi
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
acecedad9206ee0b0b93a3769b02859a
  squares ::
    Language.PureScript.Parser.Lexer.TokenParser a
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.squares1
                  `cast`
                (forall (a :: <*>_N).
                 <Text.Parsec.Prim.ParsecT
                    [Language.PureScript.Parser.Lexer.PositionedToken]
                    Language.PureScript.Parser.State.ParseState
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
2be4c0140221e6fd2a35d222cbab2491
  squares1 ::
    Text.Parsec.Prim.ParsecT
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
      Data.Functor.Identity.Identity
      a
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w3 :: Text.Parsec.Prim.ParsecT
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState
                            Data.Functor.Identity.Identity
                            a)
                   @ b
                   (w4 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w5 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w7 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w8 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wbetween
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.Parser.Lexer.PositionedToken
                   @ Language.PureScript.Parser.State.ParseState
                   @ ()
                   @ ()
                   @ a
                   Language.PureScript.Parser.Lexer.lsquare
                   Language.PureScript.Parser.Lexer.rsquare
                   w3
                   @ b
                   w4
                   w5
                   w6
                   w7
                   w8) -}
07d9c3a7dcb697ede90a3401e8d445d0
  stringLiteral ::
    Language.PureScript.Parser.Lexer.TokenParser
      Language.PureScript.PSString.PSString
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.stringLiteral1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Language.PureScript.PSString.PSString>_R)) -}
af44c9547caba5c1ffad06c3109e526f
  stringLiteral1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Language.PureScript.PSString.PSString
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Language.PureScript.PSString.PSString
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Language.PureScript.PSString.PSString
                   Language.PureScript.Parser.Lexer.stringLiteral4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Language.PureScript.PSString.PSString>_R))
                   Language.PureScript.Parser.Lexer.stringLiteral2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
4415cbd667d1a147269ad2f2505c4dc1
  stringLiteral2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.stringLiteral_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
76944f9bcb610cca0cd07247c33d532d
  stringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("string literal"#) -}
9aa5557c5c7243ad2a7f28722ece85b5
  stringLiteral4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Language.PureScript.PSString.PSString
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Language.PureScript.PSString.PSString
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp10 @ b ww1 ww2 ww3 w1 w4 }) -}
e8ef62ef8a4733c94afed9cf0978a855
  stringLiteral_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.stringLiteral3) -}
99f9bd1c3cc328461c9c3f0e625dbd70
  symbol ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.symbol1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
df4ff0c7873c69ba6cef310524845e94
  symbol' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 1, Strictness: <L,U(U,U,U)> -}
9b6860b351070017740be57df4d15351
  symbol1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.symbol4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.symbol2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
01c1a8b9aad60bf6ca6646e0686d5595
  symbol10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
baeeb268224a548eb9d34d528970adc6
  symbol2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.symbol_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
334a622ef767f4583e0aa2c3f52deda5
  symbol3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("symbol"#) -}
59885c734b89077ff4976e4385bf5ec8
  symbol4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp11 @ b ww1 ww2 ww3 w1 w4 }) -}
5156090e2b6000429b6b86f5dbc478ac
  symbol5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol6) -}
c2dda20648ccdfa1e3543a70696dfde3
  symbol6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("@"#) -}
8f84989a455acb523b3b54ff1e24c97f
  symbol7 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol8) -}
d6a3eb1e5522ff18e80ececf45d9f86b
  symbol8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
8bc6a29c198a6f97805c5a0ff1201ae4
  symbol9 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol10) -}
d2cc1ae5905c390e5b37b3eb7a558b0d
  symbol_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.symbol3) -}
c831d224c40a1a9f24679a2d19fa416a
  tick :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Tick) -}
78479706c9b14cf7d1e54f86591729d2
  token ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> Language.PureScript.Parser.Lexer.TokenParser a
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.token1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <a>_R)) -}
b533e1315a3a22c654c1f4614c6c9aca
  token1 ::
    (Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (a
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*C1(U)><S(SSS),1*U(1*U,U,U)><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   (w :: Language.PureScript.Parser.Lexer.Token -> GHC.Base.Maybe a)
                   @ b
                   (w1 :: Text.Parsec.Prim.State
                            [Language.PureScript.Parser.Lexer.PositionedToken]
                            Language.PureScript.Parser.State.ParseState)
                   (w2 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: a
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w1 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wtoken
                   @ a
                   w
                   @ b
                   ww1
                   ww2
                   ww3
                   w2
                   w5 }) -}
bad2b5d5088002f28817c15bc5b31705
  tyname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.tyname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
29cf9d82f8a477668b8d639c19e0d94a
  tyname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.dconsname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.tyname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
9ff0337e5850826422d454b917f50ccb
  tyname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.tyname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
81c06acf0a2e6e5d777b1dd376a94a40
  tyname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("type name"#) -}
3e746b8a23e8f46d71e718ccb78897c4
  tyname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.tyname3) -}
d26aa9b1095a33d7b2bed5c0902c7f7c
  uname ::
    Language.PureScript.Parser.Lexer.TokenParser
      Data.Text.Internal.Text
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.uname1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                          <Language.PureScript.Parser.State.ParseState>_R
                          <Data.Functor.Identity.Identity>_R
                          <Data.Text.Internal.Text>_R)) -}
fa0890052e720dcce691f585f5098170
  uname' ::
    Data.Text.Internal.Text
    -> Language.PureScript.Parser.Lexer.TokenParser ()
  {- Arity: 6,
     Strictness: <L,1*U(U,U,U)><L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Parser.Lexer.uname'1
                  `cast`
                (<Data.Text.Internal.Text>_R
                 ->_R Sym (Text.Parsec.Prim.N:ParsecT[0]
                               <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                               <Language.PureScript.Parser.State.ParseState>_R
                               <Data.Functor.Identity.Identity>_R
                               <()>_R)) -}
efdeb3d637f561300e4d84bbd1079a82
  uname'1 ::
    Data.Text.Internal.Text
    -> forall b.
       Text.Parsec.Prim.State
         [Language.PureScript.Parser.Lexer.PositionedToken]
         Language.PureScript.Parser.State.ParseState
       -> (()
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Parsec.Prim.State
                [Language.PureScript.Parser.Lexer.PositionedToken]
                Language.PureScript.Parser.State.ParseState
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,1*U(U,U,U)><L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ (s :: Data.Text.Internal.Text)
                   @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: ()
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: ()
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ ()
                   (\ @ b1
                      (eta6 :: Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState)[OneShot]
                      (eta7 :: ()
                               -> Text.Parsec.Prim.State
                                    [Language.PureScript.Parser.Lexer.PositionedToken]
                                    Language.PureScript.Parser.State.ParseState
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta8 :: Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta9 :: ()
                               -> Text.Parsec.Prim.State
                                    [Language.PureScript.Parser.Lexer.PositionedToken]
                                    Language.PureScript.Parser.State.ParseState
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1)[OneShot]
                      (eta10 :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1)[OneShot] ->
                    case eta6 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                    case ww1 of wild {
                      []
                      -> eta10 (Text.Parsec.Error.ParseError ww2 Text.Parsec.Prim.token2)
                      : t ts
                      -> case t of wild1 { Language.PureScript.Parser.Lexer.PositionedToken ds ds1 ds2 ds3 ds4 ->
                         let {
                           $j :: Data.Functor.Identity.Identity b1 <join 0>
                           = eta10
                               (Text.Parsec.Error.ParseError
                                  ww2
                                  (GHC.Types.:
                                     @ Text.Parsec.Error.Message
                                     (case Language.PureScript.Parser.Lexer.$wlvl
                                             ds3 of dt6 { DEFAULT ->
                                      Text.Parsec.Error.SysUnExpect dt6 })
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)))
                         } in
                         case ds3 of wild2 {
                           DEFAULT -> $j
                           Language.PureScript.Parser.Lexer.UName s'
                           -> case s of wild3 { Data.Text.Internal.Text dt6 dt7 dt8 ->
                              case s' of wild4 { Data.Text.Internal.Text dt9 dt10 dt11 ->
                              case GHC.Prim.==# dt8 dt11 of lwild {
                                DEFAULT -> $j
                                1#
                                -> case {__pkg_ccall text-1.2.3.0 GHC.Prim.ByteArray#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.ByteArray#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.Word#
                                                                  -> GHC.Prim.State#
                                                                       GHC.Prim.RealWorld
                                                                  -> (# GHC.Prim.State#
                                                                          GHC.Prim.RealWorld,
                                                                        GHC.Prim.Int# #)}
                                          dt6
                                          (GHC.Prim.int2Word# dt7)
                                          dt9
                                          (GHC.Prim.int2Word# dt10)
                                          (GHC.Prim.int2Word# dt8)
                                          GHC.Prim.realWorld# of wild5 { (#,#) ds5 ds6 ->
                                   case GHC.Prim.narrow32Int# ds6 of wild6 {
                                     DEFAULT -> $j
                                     0#
                                     -> case ts of wild7 {
                                          []
                                          -> case ds of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                             eta7
                                               GHC.Tuple.()
                                               (Text.Parsec.Prim.State
                                                  @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                                  @ Language.PureScript.Parser.State.ParseState
                                                  (GHC.Types.[]
                                                     @ Language.PureScript.Parser.Lexer.PositionedToken)
                                                  v
                                                  ww3)
                                               (Text.Parsec.Error.ParseError
                                                  v
                                                  (GHC.Types.[] @ Text.Parsec.Error.Message)) }
                                          : t1 ts1
                                          -> case t1 of wild8 { Language.PureScript.Parser.Lexer.PositionedToken ds7 ds8 ds9 ds10 ds11 ->
                                             case ds7 of v { Text.Parsec.Pos.SourcePos ipv ipv1 ipv2 ->
                                             eta7
                                               GHC.Tuple.()
                                               (Text.Parsec.Prim.State
                                                  @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                                  @ Language.PureScript.Parser.State.ParseState
                                                  wild7
                                                  v
                                                  ww3)
                                               (Text.Parsec.Error.ParseError
                                                  v
                                                  (GHC.Types.[]
                                                     @ Text.Parsec.Error.Message)) } } } } } } } } } } } })
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   Language.PureScript.Parser.Lexer.uname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
ca1cc2d295d9394829da0e2b923509f5
  uname1 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta1 :: Text.Parsec.Prim.State
                              [Language.PureScript.Parser.Lexer.PositionedToken]
                              Language.PureScript.Parser.State.ParseState)
                   (eta2 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Data.Text.Internal.Text
                            -> Text.Parsec.Prim.State
                                 [Language.PureScript.Parser.Lexer.PositionedToken]
                                 Language.PureScript.Parser.State.ParseState
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta5 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ [Language.PureScript.Parser.Lexer.PositionedToken]
                   @ Language.PureScript.Parser.State.ParseState
                   @ Data.Functor.Identity.Identity
                   @ Data.Text.Internal.Text
                   Language.PureScript.Parser.Lexer.uname4
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                             <Language.PureScript.Parser.State.ParseState>_R
                             <Data.Functor.Identity.Identity>_R
                             <Data.Text.Internal.Text>_R))
                   Language.PureScript.Parser.Lexer.uname2
                   @ b
                   eta1
                   eta2
                   eta3
                   eta4
                   eta5) -}
8fdd64f3d7e2a6412bd284f6d20201ce
  uname2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Language.PureScript.Parser.Lexer.uname_msg
                   (GHC.Types.[] @ GHC.Base.String)) -}
a91c3840b24ca29d05d6e1f4c537828b
  uname3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("proper name"#) -}
8b94a968b045738f21ce377ae545978b
  uname4 ::
    Text.Parsec.Prim.State
      [Language.PureScript.Parser.Lexer.PositionedToken]
      Language.PureScript.Parser.State.ParseState
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Data.Text.Internal.Text
        -> Text.Parsec.Prim.State
             [Language.PureScript.Parser.Lexer.PositionedToken]
             Language.PureScript.Parser.State.ParseState
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(SSS),1*U(1*U,U,U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State
                           [Language.PureScript.Parser.Lexer.PositionedToken]
                           Language.PureScript.Parser.State.ParseState)
                   (w1 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: Data.Text.Internal.Text
                          -> Text.Parsec.Prim.State
                               [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.State.ParseState
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 Language.PureScript.Parser.Lexer.$wp12 @ b ww1 ww2 ww3 w1 w4 }) -}
569da0ad9947b0b9b984f9d539b71543
  uname_msg :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.PureScript.Parser.Lexer.uname3) -}
92d06e5c179717e78ed1fbf4834f5cc5
  underscore :: Language.PureScript.Parser.Lexer.TokenParser ()
  {- Unfolding: (Language.PureScript.Parser.Lexer.match
                   Language.PureScript.Parser.Lexer.Underscore) -}
f5b859ca92d10e23dff39e6085edf597
  updatePositions ::
    [Language.PureScript.Parser.Lexer.PositionedToken]
    -> [Language.PureScript.Parser.Lexer.PositionedToken]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.PureScript.Parser.Lexer.PositionedToken]) ->
                 case ds of wild {
                   []
                   -> GHC.Types.[] @ Language.PureScript.Parser.Lexer.PositionedToken
                   : x xs
                   -> GHC.Types.:
                        @ Language.PureScript.Parser.Lexer.PositionedToken
                        x
                        (Language.PureScript.Parser.Lexer.lex_$sgo2 xs x xs) }) -}
instance GHC.Classes.Eq [Language.PureScript.Parser.Lexer.PositionedToken]
  = Language.PureScript.Parser.Lexer.$fEqPositionedToken
instance GHC.Classes.Eq [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fEqToken
instance GHC.Classes.Ord [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fOrdToken
instance GHC.Show.Show [Language.PureScript.Parser.Lexer.PositionedToken]
  = Language.PureScript.Parser.Lexer.$fShowPositionedToken
instance GHC.Show.Show [Language.PureScript.Parser.Lexer.Token]
  = Language.PureScript.Parser.Lexer.$fShowToken
"SPEC/Language.PureScript.Parser.Lexer $fStreamTextmChar0 @ Identity" [orphan] forall (v :: GHC.Base.Monad
                                                                                              Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStreamTextmChar0 @ Data.Functor.Identity.Identity
                                      v
  = Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

