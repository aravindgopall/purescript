
==================== FINAL INTERFACE ====================
2019-01-24 14:17:41.705178 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.SourceFile 8043
  interface hash: baf03eb4c146046fa79445c6a4095ee2
  ABI hash: c74d69ddf93a90292d74305bb762cfa1
  export-list hash: e00d77246c86a899e3f8f790a1647fa1
  orphan hash: 34f12ff010b58a2a4a77ff8a5e0bc304
  flag hash: 5ca2b6297314332f988f1cde11325eb2
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Ide.SourceFile.extractAstInformation
  Language.PureScript.Ide.SourceFile.extractSpans
  Language.PureScript.Ide.SourceFile.extractTypeAnnotations
  Language.PureScript.Ide.SourceFile.parseModule
  Language.PureScript.Ide.SourceFile.parseModulesFromFiles
module dependencies: Control.Monad.Logger Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript
                     Language.PureScript.AST Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.CodeGen.JS
                     Language.PureScript.CodeGen.JS.Common
                     Language.PureScript.CodeGen.JS.Printer Language.PureScript.Comments
                     Language.PureScript.Constants Language.PureScript.CoreFn
                     Language.PureScript.CoreFn.Ann Language.PureScript.CoreFn.Binders
                     Language.PureScript.CoreFn.Desugar Language.PureScript.CoreFn.Expr
                     Language.PureScript.CoreFn.Meta Language.PureScript.CoreFn.Module
                     Language.PureScript.CoreFn.Optimizer
                     Language.PureScript.CoreFn.ToJSON
                     Language.PureScript.CoreFn.Traversals
                     Language.PureScript.CoreImp.AST
                     Language.PureScript.CoreImp.Optimizer
                     Language.PureScript.CoreImp.Optimizer.Blocks
                     Language.PureScript.CoreImp.Optimizer.Common
                     Language.PureScript.CoreImp.Optimizer.Inliner
                     Language.PureScript.CoreImp.Optimizer.MagicDo
                     Language.PureScript.CoreImp.Optimizer.TCO
                     Language.PureScript.CoreImp.Optimizer.Unused
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Errors.JSON
                     Language.PureScript.Externs Language.PureScript.Ide.Error
                     Language.PureScript.Ide.Logging Language.PureScript.Ide.Types
                     Language.PureScript.Ide.Util Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Linter
                     Language.PureScript.Linter.Exhaustive
                     Language.PureScript.Linter.Imports Language.PureScript.Make
                     Language.PureScript.Make.Actions Language.PureScript.Make.BuildPlan
                     Language.PureScript.Make.Monad
                     Language.PureScript.ModuleDependencies Language.PureScript.Names
                     Language.PureScript.Options Language.PureScript.PSString
                     Language.PureScript.Parser Language.PureScript.Parser.Common
                     Language.PureScript.Parser.Declarations
                     Language.PureScript.Parser.Kinds Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Parser.Types
                     Language.PureScript.Pretty Language.PureScript.Pretty.Common
                     Language.PureScript.Pretty.Kinds Language.PureScript.Pretty.Types
                     Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Renamer Language.PureScript.Sugar
                     Language.PureScript.Sugar.AdoNotation
                     Language.PureScript.Sugar.BindingGroups
                     Language.PureScript.Sugar.CaseDeclarations
                     Language.PureScript.Sugar.DoNotation
                     Language.PureScript.Sugar.LetPattern
                     Language.PureScript.Sugar.Names
                     Language.PureScript.Sugar.Names.Common
                     Language.PureScript.Sugar.Names.Env
                     Language.PureScript.Sugar.Names.Exports
                     Language.PureScript.Sugar.Names.Imports
                     Language.PureScript.Sugar.ObjectWildcards
                     Language.PureScript.Sugar.Operators
                     Language.PureScript.Sugar.Operators.Binders
                     Language.PureScript.Sugar.Operators.Common
                     Language.PureScript.Sugar.Operators.Expr
                     Language.PureScript.Sugar.Operators.Types
                     Language.PureScript.Sugar.TypeClasses
                     Language.PureScript.Sugar.TypeClasses.Deriving
                     Language.PureScript.Sugar.TypeDeclarations
                     Language.PureScript.Traversals Language.PureScript.TypeChecker
                     Language.PureScript.TypeChecker.Entailment
                     Language.PureScript.TypeChecker.Kinds
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeChecker.Skolems
                     Language.PureScript.TypeChecker.Subsumption
                     Language.PureScript.TypeChecker.Synonyms
                     Language.PureScript.TypeChecker.TypeSearch
                     Language.PureScript.TypeChecker.Types
                     Language.PureScript.TypeChecker.Unify
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript System.IO.UTF8
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 auto-update-0.1.4
                      base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 boxes-0.1.5 bytestring-0.10.8.2 clock-0.7.2
                      colour-2.3.4 conduit-1.3.0.3 conduit-extra-1.3.0
                      containers-0.5.11.0 data-ordlist-0.4.7.0 deepseq-1.4.3.0
                      directory-1.3.1.5 dlist-0.8.0.4 easy-file-0.2.2 exceptions-0.10.0
                      fast-logger-2.4.11 filepath-1.4.2 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      lifted-base-0.2.3.12 microlens-0.4.9.1 microlens-ghc-0.4.9
                      microlens-mtl-0.1.11.1 microlens-platform-0.3.10
                      microlens-th-0.4.2.1 monad-control-1.0.2.3 monad-logger-0.3.28.5
                      monad-loops-0.4.3 mtl-2.2.2 old-locale-1.0.0.7 old-time-1.1.0.3
                      parallel-3.2.1.1 parsec-3.1.13.0 pattern-arrows-0.0.2
                      pretty-1.1.3.6 primitive-0.6.3.0 protolude-0.2.2 random-1.1
                      resourcet-1.2.1 safe-0.3.17 scientific-0.3.6.2 sourcemap-0.1.6
                      split-0.2.3.3 stm-2.4.5.0 stm-chans-3.0.0.4 stringsearch-0.3.6.6
                      syb-0.7 tagged-0.8.5 template-haskell-2.13.0.0 text-1.2.3.0
                      th-abstraction-0.2.8.0 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.5.0 transformers-base-0.4.5.2 unix-2.7.2.2
                      unix-time-0.3.8 unliftio-core-0.1.1.0 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: unix-time-0.3.8:Data.UnixTime.Diff
         syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic text-1.2.3.0:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         clock-0.7.2:System.Clock
                         conduit-1.3.0.3:Data.Conduit.Internal.Conduit
                         conduit-1.3.0.3:Data.Conduit.Internal.Pipe
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         monad-logger-0.3.28.5:Control.Monad.Logger
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Logger
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Ide.Types
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Make.Monad
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         resourcet-1.2.1:Control.Monad.Trans.Resource.Internal
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  containers-0.5.11.0:Data.Map 0dbdaec812ef695a364aa6c69e7f7d53
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  parallel-3.2.1.1:Control.Parallel.Strategies c4ad57b4c83509e5393e66a9499d773c
import  -/  protolude-0.2.2:Protolude 2c2d16096c8a60f59f646a3b93b0eb7b
import  -/  Language.PureScript 4a24ccd892adbf021daf2410ebd61e22
  exports: 139dcaa90af8ddcee6aa0492159f351d
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  DataDeclaration 2fcba6ad709595ed3c4d0926de54bc2c
  Declaration e92f6ee78a22c0eadc3566d7d1f48d5b
  ExternDataDeclaration 45e3d2e61e8f85403449183876d3af2f
  ExternDeclaration 180e172298441327dfef1022795a10e0
  ExternKindDeclaration 88852d174ecb6f9a3f22350e4bed5723
  FixityDeclaration 95c5fd24977a7e9400ec16a2317bcd12
  Module 305128e30e200d34d712365aa2d509df
  Module 3342e00ee072addfd009ee61e87fb865
  TypeClassDeclaration 19936abcaf3693a6825ccbc13b2590dc
  TypeDeclaration 28394461dbd073cca9cdbd263dbb4335
  TypeDeclarationData 3e894c7cbf790244173310e6e620d669
  TypeFixity 422dbbc62f61e8d72aabe0ec3c32e2e8
  TypeSynonymDeclaration 1cfe9af195a40456074b96ff0ca4519c
  ValueDecl 97b38919d86cd9182cb8d86b6f4ae734
  ValueFixity 9e475bb09c95e859fc062456332129d5
  getTypeDeclaration eea7233e2bcca06180e0fde9a4729425
  unwrapTypeDeclaration 348c99c29975a5b33457904ffa9aebcc
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  SourceSpan 1e0cf2bd3ea18f97a2ff152297f09219
import  -/  Language.PureScript.Ide.Error b6eb0f8da112a6cbb4342061d1afef05
  exports: 618489d4d27b48ee8032da6edee10f0b
  IdeError 347304649e024d1c6990f4b438ecc115
import  -/  Language.PureScript.Ide.Types 4bb81e9de3788f7f63a68a23e190eb73
  exports: e5ee4d37ef25d4dfedd36ea1d435a17a
  DefinitionSites c161e16528e3e8b1440d99e361f106f0
  IdeNSKind 63c32c9e96311fb6e946631828a18da8
  IdeNSType 5ff5d8cffb71ed2b7340691cc23499b1
  IdeNSValue b1143d15c5f600d17f9f80fdbd679c78
  IdeNamespaced b530543e75a3b859e16ce1b8a5d60e4a
  IdeNamespaced a433d742d266c5a84cd109a4a3bf8314
  TypeAnnotations ccd1ccf94d43b6da534c378dbd72ecc7
import  -/  Language.PureScript.Ide.Util 23feade20e7d884b8e398315c4ffa11e
  exports: b783a834cebd9a63a606ae4111317a86
  ideReadFile e90a75f47b35d9b93bb00b2e97526cbb
import  -/  Language.PureScript.Names 00f694509122478d97b327fbbccae327
  Ident bad3562aa6138b6192713ac281080869
  runIdent f4727e6f001b3b7d933fd4e8122af572
  runOpName 9af301165f72160425c5e0dde6525338
  runProperName a7268334e0b909381550b9329cb80fcc
import  -/  Language.PureScript.Parser.Declarations 4331277871d8b757c9139b8595a399c8
  parseModuleFromFile a5e431f010c7cf005e06404183762fa6
import  -/  Language.PureScript.Types 80a51f62cb3e6c71f024289b88f07b7f
  SourceType 0ac818517c14fedd280ef5885ae0cdc3
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
9affb7d4c7d30062bc0ce9013bdbbce1
  $sfromList ::
    [(Language.PureScript.Names.Ident, a)]
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(Language.PureScript.Names.Ident, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Internal.Bin
                             @ Language.PureScript.Names.Ident
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a)
                             (Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case Language.PureScript.Names.$fOrdIdent_$c< kx ky of wild4 {
                             GHC.Types.False
                             -> case kx of dt { DEFAULT ->
                                Language.PureScript.Ide.SourceFile.$sfromList_$spoly_go14
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ Language.PureScript.Names.Ident
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a)
                                     (Data.Map.Internal.Tip
                                        @ Language.PureScript.Names.Ident
                                        @ a)) }
                             GHC.Types.True
                             -> case kx of dt { DEFAULT ->
                                Language.PureScript.Ide.SourceFile.$sfromList_$s$wpoly_go13
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ Language.PureScript.Names.Ident
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a)
                                     (Data.Map.Internal.Tip @ Language.PureScript.Names.Ident @ a))
                                  1# } } } } } }) -}
fea60ea293bf54bb78049426ef3a6d60
  $sfromList1 ::
    [(Language.PureScript.Ide.Types.IdeNamespaced, a)]
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a
                   (ds :: [(Language.PureScript.Ide.Types.IdeNamespaced, a)]) ->
                 case ds of wild {
                   []
                   -> Data.Map.Internal.Tip
                        @ Language.PureScript.Ide.Types.IdeNamespaced
                        @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { Language.PureScript.Ide.Types.IdeNamespaced ipv ipv1 ->
                           Data.Map.Internal.Bin
                             @ Language.PureScript.Ide.Types.IdeNamespaced
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Internal.Tip
                                @ Language.PureScript.Ide.Types.IdeNamespaced
                                @ a)
                             (Data.Map.Internal.Tip
                                @ Language.PureScript.Ide.Types.IdeNamespaced
                                @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case kx of ww { Language.PureScript.Ide.Types.IdeNamespaced ww1 ww2 ->
                           case ky of ww3 { Language.PureScript.Ide.Types.IdeNamespaced ww4 ww5 ->
                           case Language.PureScript.Ide.Types.$w$c>=
                                  ww1
                                  ww2
                                  ww4
                                  ww5 of wild4 {
                             GHC.Types.False
                             -> Language.PureScript.Ide.SourceFile.$sfromList_$s$wpoly_go1
                                  @ a
                                  ww4
                                  ww5
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ Language.PureScript.Ide.Types.IdeNamespaced
                                     @ a
                                     1#
                                     ww
                                     x
                                     (Data.Map.Internal.Tip
                                        @ Language.PureScript.Ide.Types.IdeNamespaced
                                        @ a)
                                     (Data.Map.Internal.Tip
                                        @ Language.PureScript.Ide.Types.IdeNamespaced
                                        @ a))
                                  1#
                             GHC.Types.True
                             -> Language.PureScript.Ide.SourceFile.$sfromList_$spoly_go1
                                  @ a
                                  ww4
                                  ww5
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ Language.PureScript.Ide.Types.IdeNamespaced
                                     @ a
                                     1#
                                     ww
                                     x
                                     (Data.Map.Internal.Tip
                                        @ Language.PureScript.Ide.Types.IdeNamespaced
                                        @ a)
                                     (Data.Map.Internal.Tip
                                        @ Language.PureScript.Ide.Types.IdeNamespaced
                                        @ a)) } } } } } } }) -}
a94b68779b4cbfd2c6cfb7075045202f
  $sfromList_$s$wpoly_go1 ::
    Language.PureScript.Ide.Types.IdeNamespace
    -> Data.Text.Internal.Text
    -> a
    -> [(Language.PureScript.Ide.Types.IdeNamespaced, a)]
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U)><L,U><S,1*U><S,1*U><L,U> -}
40c814094c9af6a19cbc21f3c3b8c7df
  $sfromList_$s$wpoly_go13 ::
    Language.PureScript.Names.Ident
    -> a
    -> [(Language.PureScript.Names.Ident, a)]
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
  {- Arity: 5, Strictness: <S,U><L,U><S,1*U><S,1*U><L,U> -}
5c35f8ef3752c11ae5feffd8739c9ea9
  $sfromList_$spoly_go1 ::
    Language.PureScript.Ide.Types.IdeNamespace
    -> Data.Text.Internal.Text
    -> a
    -> [(Language.PureScript.Ide.Types.IdeNamespaced, a)]
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a
  {- Arity: 5, Strictness: <L,U><L,U(U,U,U)><L,U><S,1*U><S,1*U> -}
d8b7297fd5f877412c62342cc0e34182
  $sfromList_$spoly_go14 ::
    Language.PureScript.Names.Ident
    -> a
    -> [(Language.PureScript.Names.Ident, a)]
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a
  {- Arity: 4, Strictness: <S,U><L,U><S,1*U><S,1*U> -}
b6f9f4ac4393481c6a54e8d2c67ff678
  $sinsert_$sgo13 ::
    Language.PureScript.Names.Ident
    -> Language.PureScript.Names.Ident
    -> a1
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a1
    -> Data.Map.Internal.Map Language.PureScript.Names.Ident a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
b7bc30014f9a104ab32a0c7e95ac8d42
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Ide.SourceFile.$trModule3
                   Language.PureScript.Ide.SourceFile.$trModule1) -}
feee2202794e14b1b48dae129c75718e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.SourceFile.$trModule2) -}
f33b8e164571a39d38a9a9f4f265c314
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.Ide.SourceFile"#) -}
ed232a9ea8205ecb2361a8ecea0022cb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Ide.SourceFile.$trModule4) -}
7dc6bd5da263b095286571a624642d41
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
744a136468699e5d70f741d9ab6495d6
  $w$sgo13 ::
    Language.PureScript.Ide.Types.IdeNamespaced
    -> Language.PureScript.Ide.Types.IdeNamespace
    -> Data.Text.Internal.Text
    -> a1
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a1
    -> Data.Map.Internal.Map
         Language.PureScript.Ide.Types.IdeNamespaced a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U(U,U,U)><L,U><S,1*U>,
     Inline: [0] -}
6d3086164192b85a28398de5c43773bd
  extractAstInformation ::
    Language.PureScript.AST.Declarations.Module
    -> (Language.PureScript.Ide.Types.DefinitionSites
          Language.PureScript.AST.SourcePos.SourceSpan,
        Language.PureScript.Ide.Types.TypeAnnotations)
  {- Arity: 1, Strictness: <S,1*U(A,A,A,U,A)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.PureScript.AST.Declarations.Module) ->
                 case w of ww { Language.PureScript.AST.Declarations.Module ww1 ww2 ww3 ww4 ww5 ->
                 (Language.PureScript.Ide.SourceFile.$sfromList1
                    @ Language.PureScript.AST.SourcePos.SourceSpan
                    (Language.PureScript.Ide.SourceFile.extractAstInformation_go ww4),
                  Language.PureScript.Ide.SourceFile.$sfromList
                    @ (Language.PureScript.Types.Type
                         Language.PureScript.AST.SourcePos.SourceAnn)
                    (Data.Maybe.mapMaybe
                       @ Language.PureScript.AST.Declarations.Declaration
                       @ (Language.PureScript.Names.Ident,
                          Language.PureScript.Types.SourceType)
                       Language.PureScript.Ide.SourceFile.extractAstInformation1
                       ww4)) }) -}
2326b76ea062065ebf0d03ac1e5b3f94
  extractAstInformation1 ::
    Language.PureScript.AST.Declarations.Declaration
    -> GHC.Base.Maybe
         (Language.PureScript.Names.Ident,
          Language.PureScript.Types.SourceType)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Language.PureScript.AST.Declarations.Declaration) ->
                 case x of wild {
                   DEFAULT
                   -> GHC.Base.Nothing
                        @ (Language.PureScript.Names.Ident,
                           Language.PureScript.Types.SourceType)
                   Language.PureScript.AST.Declarations.TypeDeclaration dt dt1 dt2
                   -> GHC.Base.Just
                        @ (Language.PureScript.Names.Ident,
                           Language.PureScript.Types.SourceType)
                        (dt1, dt2) }) -}
91212b84be1869f0de51e5693204c2fd
  extractAstInformation_go ::
    [Language.PureScript.AST.Declarations.Declaration]
    -> [(Language.PureScript.Ide.Types.IdeNamespaced,
         Language.PureScript.AST.SourcePos.SourceSpan)]
  {- Arity: 1, Strictness: <S,1*U> -}
73d02a70d30c9858005f50bc4050fdbf
  extractSpans ::
    Language.PureScript.AST.Declarations.Declaration
    -> [(Language.PureScript.Ide.Types.IdeNamespaced,
         Language.PureScript.AST.SourcePos.SourceSpan)]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (d :: Language.PureScript.AST.Declarations.Declaration) ->
                 case d of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                   Language.PureScript.AST.Declarations.DataDeclaration ds ds1 name ds2 ctors
                   -> case ds of wild1 { (,) ss ds3 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSType
                           name
                             `cast`
                           (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.TypeName>_P),
                         ss)
                        (GHC.Base.map
                           @ (Language.PureScript.Names.ProperName
                                'Language.PureScript.Names.ConstructorName,
                              [Language.PureScript.Types.SourceType])
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)
                           (\ (ds4 :: (Language.PureScript.Names.ProperName
                                         'Language.PureScript.Names.ConstructorName,
                                       [Language.PureScript.Types.SourceType])) ->
                            case ds4 of wild2 { (,) cname ds5 ->
                            (Language.PureScript.Ide.Types.IdeNamespaced
                               Language.PureScript.Ide.Types.IdeNSValue
                               cname
                                 `cast`
                               (Language.PureScript.Names.N:ProperName[0]
                                    <'Language.PureScript.Names.ConstructorName>_P),
                             ss) })
                           ctors) }
                   Language.PureScript.AST.Declarations.TypeSynonymDeclaration ds name ds1 ds2
                   -> case ds of wild1 { (,) ss ds3 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSType
                           name
                             `cast`
                           (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.TypeName>_P),
                         ss)
                        (GHC.Types.[]
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)) }
                   Language.PureScript.AST.Declarations.ValueDeclaration dt dt1 dt2 dt3 dt4
                   -> case dt of wild1 { (,) ss ds ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSValue
                           (Language.PureScript.Names.runIdent dt1),
                         ss)
                        (GHC.Types.[]
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)) }
                   Language.PureScript.AST.Declarations.ExternDeclaration ds ident ds1
                   -> case ds of wild1 { (,) ss ds2 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSValue
                           (Language.PureScript.Names.runIdent ident),
                         ss)
                        (GHC.Types.[]
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)) }
                   Language.PureScript.AST.Declarations.ExternDataDeclaration ds name ds1
                   -> case ds of wild1 { (,) ss ds2 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSType
                           name
                             `cast`
                           (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.TypeName>_P),
                         ss)
                        (GHC.Types.[]
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)) }
                   Language.PureScript.AST.Declarations.ExternKindDeclaration ds name
                   -> case ds of wild1 { (,) ss ds1 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSKind
                           name
                             `cast`
                           (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.KindName>_P),
                         ss)
                        (GHC.Types.[]
                           @ (Language.PureScript.Ide.Types.IdeNamespaced,
                              Language.PureScript.AST.SourcePos.SourceSpan)) }
                   Language.PureScript.AST.Declarations.FixityDeclaration ds ds1
                   -> case ds of wild1 { (,) ss ds2 ->
                      case ds1 of wild2 {
                        Data.Either.Left ds3
                        -> case ds3 of wild3 { Language.PureScript.AST.Declarations.ValueFixity ds4 ds5 opName ->
                           GHC.Types.:
                             @ (Language.PureScript.Ide.Types.IdeNamespaced,
                                Language.PureScript.AST.SourcePos.SourceSpan)
                             (Language.PureScript.Ide.Types.IdeNamespaced
                                Language.PureScript.Ide.Types.IdeNSValue
                                opName
                                  `cast`
                                (Language.PureScript.Names.N:OpName[0]
                                     <'Language.PureScript.Names.ValueOpName>_P),
                              ss)
                             (GHC.Types.[]
                                @ (Language.PureScript.Ide.Types.IdeNamespaced,
                                   Language.PureScript.AST.SourcePos.SourceSpan)) }
                        Data.Either.Right ds3
                        -> case ds3 of wild3 { Language.PureScript.AST.Declarations.TypeFixity ds4 ds5 opName ->
                           GHC.Types.:
                             @ (Language.PureScript.Ide.Types.IdeNamespaced,
                                Language.PureScript.AST.SourcePos.SourceSpan)
                             (Language.PureScript.Ide.Types.IdeNamespaced
                                Language.PureScript.Ide.Types.IdeNSType
                                opName
                                  `cast`
                                (Language.PureScript.Names.N:OpName[0]
                                     <'Language.PureScript.Names.TypeOpName>_P),
                              ss)
                             (GHC.Types.[]
                                @ (Language.PureScript.Ide.Types.IdeNamespaced,
                                   Language.PureScript.AST.SourcePos.SourceSpan)) } } }
                   Language.PureScript.AST.Declarations.TypeClassDeclaration ds name ds1 ds2 ds3 members
                   -> case ds of wild1 { (,) ss ds4 ->
                      GHC.Types.:
                        @ (Language.PureScript.Ide.Types.IdeNamespaced,
                           Language.PureScript.AST.SourcePos.SourceSpan)
                        (Language.PureScript.Ide.Types.IdeNamespaced
                           Language.PureScript.Ide.Types.IdeNSType
                           name
                             `cast`
                           (Language.PureScript.Names.N:ProperName[0]
                                <'Language.PureScript.Names.ClassName>_P),
                         ss)
                        (Language.PureScript.Ide.SourceFile.extractSpans_go
                           members) } }) -}
f5f9647d080ade79211ea4000a2315c5
  extractSpans_go ::
    [Language.PureScript.AST.Declarations.Declaration]
    -> [(Language.PureScript.Ide.Types.IdeNamespaced,
         Language.PureScript.AST.SourcePos.SourceSpan)]
  {- Arity: 1, Strictness: <S,1*U> -}
60e8c493ba24457bc296107604ea0bb0
  extractTypeAnnotations ::
    [Language.PureScript.AST.Declarations.Declaration]
    -> [(Language.PureScript.Names.Ident,
         Language.PureScript.Types.SourceType)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Data.Maybe.mapMaybe
                   @ Language.PureScript.AST.Declarations.Declaration
                   @ (Language.PureScript.Names.Ident,
                      Language.PureScript.Types.SourceType)
                   Language.PureScript.Ide.SourceFile.extractAstInformation1) -}
1094e688c4c00fc3a00633cf935506cc
  parseModule ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Ide.Error.IdeError m) =>
    GHC.IO.FilePath
    -> m (Data.Either.Either
            GHC.IO.FilePath
            (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module))
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),C(U))><L,U(A,C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Ide.Error.IdeError m)
                   (eta :: GHC.IO.FilePath) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.IO.FilePath, Data.Text.Internal.Text)
                   @ (Data.Either.Either
                        GHC.IO.FilePath
                        (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module))
                   (Language.PureScript.Ide.Util.ideReadFile
                      @ m
                      $dMonadIO
                      $dMonadError
                      eta)
                   (\ (ds :: (GHC.IO.FilePath, Data.Text.Internal.Text)) ->
                    case ds of wild { (,) absPath contents ->
                    GHC.Base.pure
                      @ m
                      $dApplicative
                      @ (Data.Either.Either
                           GHC.IO.FilePath
                           (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module))
                      (case (Text.Parsec.Prim.runPT
                               @ Data.Text.Internal.Text
                               @ Data.Functor.Identity.Identity
                               @ GHC.Types.Char
                               @ ()
                               @ [Language.PureScript.Parser.Lexer.PositionedToken]
                               Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                               (Language.PureScript.Parser.Lexer.lex1 @ ())
                                 `cast`
                               (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                         <Data.Text.Internal.Text>_R
                                         <()>_R
                                         <Data.Functor.Identity.Identity>_R
                                         <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                               GHC.Tuple.()
                               absPath
                               contents)
                              `cast`
                            (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    Text.Parsec.Error.ParseError
                                    [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild1 {
                         Data.Either.Left x1
                         -> Data.Either.Left
                              @ GHC.IO.FilePath
                              @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                              absPath
                         Data.Either.Right y2
                         -> case (Text.Parsec.Prim.runPT
                                    @ [Language.PureScript.Parser.Lexer.PositionedToken]
                                    @ Data.Functor.Identity.Identity
                                    @ Language.PureScript.Parser.Lexer.PositionedToken
                                    @ Language.PureScript.Parser.State.ParseState
                                    @ Language.PureScript.AST.Declarations.Module
                                    (Language.PureScript.Parser.Common.$s$fStream[]mtok
                                       @ Language.PureScript.Parser.Lexer.PositionedToken)
                                    Language.PureScript.Parser.Declarations.parseModule1
                                      `cast`
                                    (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                              <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                                              <Language.PureScript.Parser.State.ParseState>_R
                                              <Data.Functor.Identity.Identity>_R
                                              <Language.PureScript.AST.Declarations.Module>_R))
                                    Language.PureScript.Parser.Common.runTokenParser2
                                    absPath
                                    (Language.PureScript.Parser.Lexer.updatePositions y2))
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Text.Parsec.Error.ParseError
                                         Language.PureScript.AST.Declarations.Module>_R) of wild2 {
                              Data.Either.Left l
                              -> Data.Either.Left
                                   @ GHC.IO.FilePath
                                   @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                                   absPath
                              Data.Either.Right r
                              -> Data.Either.Right
                                   @ GHC.IO.FilePath
                                   @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                                   (absPath, r) } }) })) -}
b01ff82135763c0656070a0b4f5044c4
  parseModulesFromFiles ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Error.Class.MonadError
       Language.PureScript.Ide.Error.IdeError m) =>
    [GHC.IO.FilePath]
    -> m [Data.Either.Either
            GHC.IO.FilePath
            (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)]
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(U(A,C(U),A,C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(A,C(U),A)><L,1*U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Ide.Error.IdeError m)
                   (eta :: [GHC.IO.FilePath]) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                   @ [Data.Either.Either
                        GHC.IO.FilePath
                        (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)]
                   (let {
                      z :: m [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                      = GHC.Base.pure
                          @ m
                          $dApplicative
                          @ [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                          (GHC.Types.[] @ (GHC.IO.FilePath, Data.Text.Internal.Text))
                    } in
                    letrec {
                      go :: [GHC.IO.FilePath]
                            -> m [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [GHC.IO.FilePath]) ->
                        case ds of wild {
                          [] -> z
                          : y ys
                          -> GHC.Base.liftA2
                               @ m
                               $dApplicative
                               @ (GHC.IO.FilePath, Data.Text.Internal.Text)
                               @ [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                               @ [(GHC.IO.FilePath, Data.Text.Internal.Text)]
                               (GHC.Types.: @ (GHC.IO.FilePath, Data.Text.Internal.Text))
                               (Language.PureScript.Ide.Util.ideReadFile
                                  @ m
                                  $dMonadIO
                                  $dMonadError
                                  y)
                               (go ys) }
                    } in
                    go eta)
                   (\ (files :: [(GHC.IO.FilePath, Data.Text.Internal.Text)]) ->
                    GHC.Base.pure
                      @ m
                      $dApplicative
                      @ [Data.Either.Either
                           GHC.IO.FilePath
                           (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)]
                      (let {
                         y :: [Data.Either.Either
                                 GHC.IO.FilePath
                                 (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)]
                         = GHC.Base.map
                             @ (GHC.IO.FilePath, Data.Text.Internal.Text)
                             @ (Data.Either.Either
                                  GHC.IO.FilePath
                                  (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module))
                             Language.PureScript.Ide.SourceFile.parseModulesFromFiles1
                             files
                       } in
                       case Control.Parallel.Strategies.parList1
                              @ (Data.Either.Either
                                   GHC.IO.FilePath
                                   (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module))
                              y of x1 { DEFAULT ->
                       case (GHC.Magic.lazy
                               @ (Control.Parallel.Strategies.Eval
                                    [Data.Either.Either
                                       GHC.IO.FilePath
                                       (GHC.IO.FilePath,
                                        Language.PureScript.AST.Declarations.Module)])
                               (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, y #))
                                 `cast`
                               (Sym (Control.Parallel.Strategies.N:Eval[0]
                                         <[Data.Either.Either
                                             GHC.IO.FilePath
                                             (GHC.IO.FilePath,
                                              Language.PureScript.AST.Declarations.Module)]>_R)))
                              `cast`
                            (Control.Parallel.Strategies.N:Eval[0]
                                 <[Data.Either.Either
                                     GHC.IO.FilePath
                                     (GHC.IO.FilePath,
                                      Language.PureScript.AST.Declarations.Module)]>_R)
                              GHC.Prim.realWorld# of ds { (#,#) ipv ipv1 ->
                       ipv1 } }))) -}
9a3f8a991979b9ae7d2aa524443189ec
  parseModulesFromFiles1 ::
    (GHC.IO.FilePath, Data.Text.Internal.Text)
    -> Data.Either.Either
         GHC.IO.FilePath
         (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: (\ (p :: (GHC.IO.FilePath, Data.Text.Internal.Text)) ->
                 let {
                   path :: GHC.IO.FilePath = case p of wild { (,) x ds -> x }
                 } in
                 case (Text.Parsec.Prim.runPT
                         @ Data.Text.Internal.Text
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ [Language.PureScript.Parser.Lexer.PositionedToken]
                         Language.PureScript.Parser.Lexer.$s$fStreamTextmChar0
                         (Language.PureScript.Parser.Lexer.lex1 @ ())
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[Language.PureScript.Parser.Lexer.PositionedToken]>_R))
                         GHC.Tuple.()
                         path
                         (case p of wild { (,) ds y -> y }))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              [Language.PureScript.Parser.Lexer.PositionedToken]>_R) of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.IO.FilePath
                        @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                        path
                   Data.Either.Right y2
                   -> case (Text.Parsec.Prim.runPT
                              @ [Language.PureScript.Parser.Lexer.PositionedToken]
                              @ Data.Functor.Identity.Identity
                              @ Language.PureScript.Parser.Lexer.PositionedToken
                              @ Language.PureScript.Parser.State.ParseState
                              @ Language.PureScript.AST.Declarations.Module
                              (Language.PureScript.Parser.Common.$s$fStream[]mtok
                                 @ Language.PureScript.Parser.Lexer.PositionedToken)
                              Language.PureScript.Parser.Declarations.parseModule1
                                `cast`
                              (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                        <[Language.PureScript.Parser.Lexer.PositionedToken]>_R
                                        <Language.PureScript.Parser.State.ParseState>_R
                                        <Data.Functor.Identity.Identity>_R
                                        <Language.PureScript.AST.Declarations.Module>_R))
                              Language.PureScript.Parser.Common.runTokenParser2
                              path
                              (Language.PureScript.Parser.Lexer.updatePositions y2))
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Text.Parsec.Error.ParseError
                                   Language.PureScript.AST.Declarations.Module>_R) of wild1 {
                        Data.Either.Left l
                        -> Data.Either.Left
                             @ GHC.IO.FilePath
                             @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                             path
                        Data.Either.Right r
                        -> Data.Either.Right
                             @ GHC.IO.FilePath
                             @ (GHC.IO.FilePath, Language.PureScript.AST.Declarations.Module)
                             (path, r) } }) -}
"SPEC/Language.PureScript.Ide.SourceFile fromList @ IdeNamespaced _" [orphan] forall @ a
                                                                                     ($dOrd :: GHC.Classes.Ord
                                                                                                 Language.PureScript.Ide.Types.IdeNamespaced)
  Data.Map.Internal.fromList @ Language.PureScript.Ide.Types.IdeNamespaced
                             @ a
                             $dOrd
  = Language.PureScript.Ide.SourceFile.$sfromList1 @ a
"SPEC/Language.PureScript.Ide.SourceFile fromList @ Ident _" [orphan] forall @ a
                                                                             ($dOrd :: GHC.Classes.Ord
                                                                                         Language.PureScript.Names.Ident)
  Data.Map.Internal.fromList @ Language.PureScript.Names.Ident
                             @ a
                             $dOrd
  = Language.PureScript.Ide.SourceFile.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

