
==================== FINAL INTERFACE ====================
2019-01-24 14:15:30.302913 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeChecker.Skolems 8043
  interface hash: 4812d5f5429ab706cbf225ffbf7e32da
  ABI hash: d6f507247d13250d325e185be25fccdf
  export-list hash: 301c96fa595b923bfcf06694e88d029f
  orphan hash: 69eba6f42c3c65475db60f0b63f4553e
  flag hash: 16532b0f9807287e7d68a156c2412cf2
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.Skolems.introduceSkolemScope
  Language.PureScript.TypeChecker.Skolems.newSkolemConstant
  Language.PureScript.TypeChecker.Skolems.newSkolemScope
  Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck
  Language.PureScript.TypeChecker.Skolems.skolemize
  Language.PureScript.TypeChecker.Skolems.skolemizeTypesInValue
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0 boxes-0.1.5
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.5.11.0
                      deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      microlens-0.4.9.1 microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1 mtl-2.2.2
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 scientific-0.3.6.2
                      sourcemap-0.1.6 split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  containers-0.5.11.0:Data.Set 7d3c64a641be4cacbcd8119445bab919
import  -/  containers-0.5.11.0:Data.Set.Internal 93fa3ef95853aa2a7aadf32d693bd451
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  Language.PureScript.AST e89b59f8e201961eafd3ff905a683659
  exports: be73d3bb7d4ebe5df082453f6d572075
import  -/  Language.PureScript.AST.Binders 482af52ec934a93b1ca6ec424fbe30f2
  Binder c96edaac3b5fcb24a174f6f4b3f084d4
  TypedBinder 69e3490135b9eb76e3f2c68250002721
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  DeferredDictionary 4767b924c347cb558c8259d23777dc47
  ErrorInExpression 6be781a6c814a2ac5a163f17629faf53
  ErrorMessage b0470a74191782e72607e7c5b87318de
  ErrorMessage 7268a73b9f5bbe5a70110aa90f7e1194
  EscapedSkolem f75939254730ec13cf7427aa6a78667b
  Expr e92f6ee78a22c0eadc3566d7d1f48d5b
  PositionedValue b90293950702fd6b659d7cd86d309f72
  TypedValue 0acc3ace791a36484dcda3706df33cef
import  -/  Language.PureScript.AST.SourcePos 63acacac5b7be73d04e5be0047a9a89a
  SourceAnn f5708ed135df009dfa0254486771ef74
  SourceSpan 1e0cf2bd3ea18f97a2ff152297f09219
  nonEmptySpan 232f686ce9eaef22a6239187f1de0ae3
import  -/  Language.PureScript.AST.Traversals f5adaf844c5e9d0f0678a8b574a32aa6
  everythingWithContextOnValues b6cfbe573edb2754803b960a4d02edab
  everywhereWithContextOnValuesM 8b088f6a1ad3879e25631321bc5daeec
import  -/  Language.PureScript.Crash 3dd739d57f17e8a1e9cd97afd3faf067
  exports: a9d2725f359c2d113bd38076e88ec681
  internalError d33c2a09c5cbe8e68c0bc27d1500ba1a
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  exports: 8e61484c4664eceb943d9fc4820c721b
  MultipleErrors e1ef6a17348ccfe3ef65185d3c5f9026
  positionedError 294ba93655a5845067da4cbeb75d1347
  singleError a36dd8bcfe054c062a952f4ca37285fa
import  -/  Language.PureScript.Traversals e97764d7972cc6ba421a6be0a3ce6bda
  exports: cbb821b2ee7c6d00cdf62285e1dbe432
  defS d63aa97f74d8b43282d6090aabe13394
import  -/  Language.PureScript.TypeChecker.Monad 5c6d6cca9d9f5acb98ab527615b54d6d
  exports: 64079f93a7ca5d81f53055abc7f8ac53
  CheckState 9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextSkolem 9cc3cef00c43c0c2ac24a31e9b521e29
  checkNextSkolemScope 9cc3cef00c43c0c2ac24a31e9b521e29
import  -/  Language.PureScript.Types 80a51f62cb3e6c71f024289b88f07b7f
  exports: 229bb7528146da886cffbefad5822e19
  ForAll 0750974c4b3c816f0559c95f8418f903
  Skolem aef73915115b060ec7781cdd3859082f
  SkolemScope b015529f7bcbe6a104cccde46fddc544
  SkolemScope 539a3045fa86d0049af7d21bd583b961
  SourceType 0ac818517c14fedd280ef5885ae0cdc3
  Type d5fc19231e8a71936895da17eade4f5b
  everythingOnTypes a337a56452e37b7c1eabcf74ce7ae28d
  everywhereOnTypesM 3778d2154e8de7bd894aef40e0e2cb61
  replaceTypeVars 8488f0f4aa30ef197cec44bf58c83ec2
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
059054ef8184dda7a4e9310686c9dfe9
  $s$wsplitS ::
    Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> (# Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
          Data.Set.Internal.Set Language.PureScript.Types.SkolemScope #)
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>, Inline: [~] -}
608c5364e8df20050a9201e752661fc3
  $sfromList ::
    [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.PureScript.Types.SkolemScope]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of nt { GHC.Types.I# ipv ->
                           Data.Set.Internal.Bin
                             @ Language.PureScript.Types.SkolemScope
                             1#
                             nt `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                             (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                             (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope) }
                        : ipv ipv1
                        -> case x `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of wild2 { GHC.Types.I# x1 ->
                           case ipv
                                  `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x1 y of lwild {
                             DEFAULT
                             -> Language.PureScript.TypeChecker.Skolems.$sfromList_$s$wgo3
                                  wild3 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Types.SkolemScope
                                     1#
                                     wild2 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                                     (Data.Set.Internal.Tip
                                        @ Language.PureScript.Types.SkolemScope))
                                  1#
                             1#
                             -> Language.PureScript.TypeChecker.Skolems.$sfromList_$sgo4
                                  wild3 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Types.SkolemScope
                                     1#
                                     wild2 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                                     (Data.Set.Internal.Tip
                                        @ Language.PureScript.Types.SkolemScope)) } } } } }) -}
ec11f5066b254d79583c6fa30ada8b1f
  $sfromList_$s$wgo3 ::
    Language.PureScript.Types.SkolemScope
    -> [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 4, Strictness: <S,1*U(U)><S,1*U><S,1*U><L,U> -}
29e1015b76e7d102d6a40ba1871cc908
  $sfromList_$sgo4 ::
    Language.PureScript.Types.SkolemScope
    -> [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><S,1*U> -}
24ea678405189b5145e685c13297508e
  $sinsert_$s$w$sgo3 ::
    GHC.Prim.Int#
    -> Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 6, Strictness: <L,U><S(S),1*U(U)><L,U><L,U><S,U><L,U> -}
2c2692baa4ae6f5c25d41d9b950a1e2a
  $sunion ::
    Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
88753b70438a766505158807582eeb97
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.Skolems.$trModule3
                   Language.PureScript.TypeChecker.Skolems.$trModule1) -}
b51436ad2f476275b871feca51195e0f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Skolems.$trModule2) -}
f6077b250108ad0411264637d7d1ee0e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.Skolems"#) -}
56be46e3ebcb8fc99e15211f1231a9b7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Skolems.$trModule4) -}
3b6edb9cc428d30b098aa8619337438d
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
9e74e52779a3c3856630b596a520cc77
  $w$sgo1 ::
    Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
d1d47b29106328f11c116c140af92dbf
  $w$sgo3 ::
    Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
48c5a9549241046625f82b1c0af186e3
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
cbd26872f4b44871d4fb8d52b6845a3d
  introduceSkolemScope ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Types.Type a
    -> m (Language.PureScript.Types.Type a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><S,1*U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Language.PureScript.Types.Type a) ->
                 Language.PureScript.Types.everywhereOnTypesM
                   @ m
                   @ a
                   (Control.Monad.State.Class.$p1MonadState
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.State.Class.$p1MonadState
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState
                    } in
                    let {
                      $dFunctor :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                    } in
                    let {
                      $dFunctor1 :: GHC.Base.Functor m
                      = GHC.Base.$p1Applicative @ m $dFunctor
                    } in
                    let {
                      lvl19 :: m (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                      = GHC.Base.fmap
                          @ m
                          $dFunctor1
                          @ Language.PureScript.Types.SkolemScope
                          @ (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                          (GHC.Base.Just @ Language.PureScript.Types.SkolemScope)
                          (Language.PureScript.TypeChecker.Skolems.newSkolemScope
                             @ m
                             $dMonadState)
                    } in
                    \ (ds :: Language.PureScript.Types.Type a) ->
                    case ds of wild {
                      DEFAULT
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.PureScript.Types.Type a)
                           wild
                      Language.PureScript.Types.ForAll ann ident ty ds1
                      -> case ds1 of wild1 {
                           GHC.Base.Nothing
                           -> GHC.Base.fmap
                                @ m
                                $dFunctor1
                                @ (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                                @ (Language.PureScript.Types.Type a)
                                (Language.PureScript.Types.ForAll @ a ann ident ty)
                                lvl19
                           GHC.Base.Just ipv
                           -> GHC.Base.return
                                @ m
                                $dMonad
                                @ (Language.PureScript.Types.Type a)
                                wild } })
                   eta) -}
91bed389ec61482f5cc2507a66413032
  newSkolemConstant ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ GHC.Types.Int
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          ds4 })))
                   (\ (s :: GHC.Types.Int) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ GHC.Types.Int
                      (let {
                         lvl19 :: GHC.Types.Int
                         = case s of wild { GHC.Types.I# x ->
                           GHC.Types.I# (GHC.Prim.+# x 1#) }
                       } in
                       Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                          (GHC.Tuple.(),
                           case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           Language.PureScript.TypeChecker.Monad.CheckState
                             ds
                             ds1
                             ds2
                             lvl19
                             ds4
                             ds5
                             ds6
                             ds7 })))
                      (GHC.Base.return @ m $dMonad @ GHC.Types.Int s))) -}
5099e483af3809deab291383bcf017ed
  newSkolemScope ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.Types.SkolemScope
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Types.Int
                   @ Language.PureScript.Types.SkolemScope
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ GHC.Types.Int
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          ds5 })))
                   (\ (s :: GHC.Types.Int) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ Language.PureScript.Types.SkolemScope
                      (let {
                         lvl19 :: GHC.Types.Int
                         = case s of wild { GHC.Types.I# x ->
                           GHC.Types.I# (GHC.Prim.+# x 1#) }
                       } in
                       Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                          (GHC.Tuple.(),
                           case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           Language.PureScript.TypeChecker.Monad.CheckState
                             ds
                             ds1
                             ds2
                             ds3
                             lvl19
                             ds5
                             ds6
                             ds7 })))
                      (GHC.Base.return
                         @ m
                         $dMonad
                         @ Language.PureScript.Types.SkolemScope
                         s `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))))) -}
f45ac30ef4f4772f46e9f82eb5dd08f0
  skolemEscapeCheck ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors m =>
    Language.PureScript.AST.Declarations.Expr -> m ()
  {- Arity: 1,
     Strictness: <L,U(1*U(1*U(A,1*C1(U),A,A,C(C1(U)),A),A,A,1*C1(U),A),C(U),A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Error.Class.$p1MonadError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                 } in
                 let {
                   lvl19 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   lvl20 :: m () = GHC.Base.pure @ m $dApplicative @ () GHC.Tuple.()
                 } in
                 letrec {
                   go :: [Language.PureScript.AST.Declarations.ErrorMessage] -> m ()
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Language.PureScript.AST.Declarations.ErrorMessage]) ->
                     case ds of wild {
                       [] -> lvl20
                       : y ys
                       -> GHC.Base.*>
                            @ m
                            $dApplicative
                            @ GHC.Types.Any
                            @ ()
                            (Control.Monad.Error.Class.throwError
                               @ Language.PureScript.Errors.MultipleErrors
                               @ m
                               $dMonadError
                               @ GHC.Types.Any
                               (GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  y
                                  (GHC.Types.[]
                                     @ Language.PureScript.AST.Declarations.ErrorMessage))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))
                            (go ys) }
                 } in
                 \ (ds :: Language.PureScript.AST.Declarations.Expr) ->
                 case ds of wild {
                   DEFAULT
                   -> Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck5 @ m
                   Language.PureScript.AST.Declarations.TypedValue ds1 ds2 ds3
                   -> case ds1 of wild1 {
                        GHC.Types.False -> lvl19
                        GHC.Types.True
                        -> case Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck1 of wild2 { (,,,,) ds4 toSkolemErrors ds5 ds6 ds7 ->
                           go (toSkolemErrors wild) } } }) -}
43a556cb6b765b5a552b08a688a2a40e
  skolemEscapeCheck1 ::
    (Language.PureScript.AST.Declarations.Declaration
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.Expr
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Binders.Binder
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.CaseAlternative
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.DoNotationElement
     -> [Language.PureScript.AST.Declarations.ErrorMessage])
  {- Unfolding: (case Language.PureScript.AST.Traversals.$weverythingWithContextOnValues
                        @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                        @ [Language.PureScript.AST.Declarations.ErrorMessage]
                        Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck4
                        (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (GHC.Base.++ @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.Declaration
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck2
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Binders.Binder
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.CaseAlternative
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.DoNotationElement
                           @ Language.PureScript.AST.Declarations.ErrorMessage) of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 (ww1, ww2, ww3, ww4, ww5) }) -}
1b132975b60a11b988c72f1d1efd363b
  skolemEscapeCheck2 ::
    (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
     GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
    -> Language.PureScript.AST.Declarations.Expr
    -> ((Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
         GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan),
        [Language.PureScript.AST.Declarations.ErrorMessage])
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m,
     Unfolding: (\ (ds :: (Data.Set.Internal.Set
                             Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan))
                   (ds1 :: Language.PureScript.AST.Declarations.Expr)[OneShot] ->
                 case ds of wild { (,) scopes ds2 ->
                 case ds1 of wild1 {
                   DEFAULT
                   -> (wild,
                       GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                   Language.PureScript.AST.Declarations.TypedValue ds3 ds4 ty
                   -> let {
                        allScopes :: Data.Set.Internal.Set
                                       Language.PureScript.Types.SkolemScope
                        = Language.PureScript.TypeChecker.Skolems.$sunion
                            (Language.PureScript.TypeChecker.Skolems.$sfromList
                               (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_collectScopes
                                  ty))
                            scopes
                      } in
                      ((allScopes, ds2),
                       let {
                         lvl19 :: [Language.PureScript.AST.Declarations.ErrorMessageHint]
                         = case ds2 of wild2 {
                             GHC.Base.Nothing
                             -> GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                  (Language.PureScript.AST.Declarations.ErrorInExpression wild1)
                                  (GHC.Types.[]
                                     @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             GHC.Base.Just x
                             -> GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                  (Language.PureScript.Errors.positionedError x)
                                  (GHC.Types.:
                                     @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                     (Language.PureScript.AST.Declarations.ErrorInExpression wild1)
                                     (GHC.Types.[]
                                        @ Language.PureScript.AST.Declarations.ErrorMessageHint)) }
                       } in
                       letrec {
                         go :: [(Language.PureScript.AST.SourcePos.SourceAnn,
                                 Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope)]
                               -> [Language.PureScript.AST.Declarations.ErrorMessage]
                           {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds5 :: [(Language.PureScript.AST.SourcePos.SourceAnn,
                                       Data.Text.Internal.Text,
                                       Language.PureScript.Types.SkolemScope)]) ->
                           case ds5 of wild2 {
                             []
                             -> GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage
                             : y ys
                             -> case y of wild3 { (,,) ssBound name scope ->
                                case scope
                                       `cast`
                                     (Language.PureScript.Types.N:SkolemScope[0]) of ww { GHC.Types.I# ww1 ->
                                case Language.PureScript.TypeChecker.Skolems.$wgo3
                                       ww1
                                       allScopes of wild4 {
                                  GHC.Types.False
                                  -> GHC.Types.:
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       (Language.PureScript.AST.Declarations.ErrorMessage
                                          lvl19
                                          (Language.PureScript.AST.Declarations.EscapedSkolem
                                             name
                                             (Language.PureScript.AST.SourcePos.nonEmptySpan
                                                ssBound)
                                             ty))
                                       (go ys)
                                  GHC.Types.True -> go ys } } } }
                       } in
                       go
                         (Language.PureScript.Types.everythingOnTypes
                            @ [(Language.PureScript.AST.SourcePos.SourceAnn,
                                Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope)]
                            @ Language.PureScript.AST.SourcePos.SourceAnn
                            (GHC.Base.++
                               @ (Language.PureScript.AST.SourcePos.SourceAnn,
                                  Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope))
                            Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck3
                            ty))
                   Language.PureScript.AST.Declarations.PositionedValue ss ds3 ds4
                   -> ((scopes,
                        GHC.Base.Just @ Language.PureScript.AST.SourcePos.SourceSpan ss),
                       GHC.Types.[]
                         @ Language.PureScript.AST.Declarations.ErrorMessage) } }) -}
11e0f2d85614bca2a5e21d19cfa19dea
  skolemEscapeCheck3 ::
    Language.PureScript.Types.Type
      Language.PureScript.AST.SourcePos.SourceAnn
    -> [(Language.PureScript.AST.SourcePos.SourceAnn,
         Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Types.Type
                            Language.PureScript.AST.SourcePos.SourceAnn) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.PureScript.AST.SourcePos.SourceAnn,
                           Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope)
                   Language.PureScript.Types.Skolem ss name ds1 scope
                   -> GHC.Types.:
                        @ (Language.PureScript.AST.SourcePos.SourceAnn,
                           Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope)
                        (ss, name, scope)
                        (GHC.Types.[]
                           @ (Language.PureScript.AST.SourcePos.SourceAnn,
                              Data.Text.Internal.Text,
                              Language.PureScript.Types.SkolemScope)) }) -}
b684c1cd9111280c064ab903119d012e
  skolemEscapeCheck4 ::
    (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
     GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Data.Set.Internal.Tip
                    @ Language.PureScript.Types.SkolemScope,
                  GHC.Base.Nothing
                    @ Language.PureScript.AST.SourcePos.SourceSpan)) -}
3a6050ad1249ab765336d82adf745175
  skolemEscapeCheck5 :: m ()
  {- Strictness: x -}
b88ab0c57b0179f0def5ceba2c6cc75c
  skolemEscapeCheck_collectScopes ::
    Language.PureScript.Types.SourceType
    -> [Language.PureScript.Types.SkolemScope]
  {- Arity: 1, Strictness: <S,1*U> -}
82bcde709512d9f0f0a1fdce089119e1
  skolemEscapeCheck_def :: a1 -> p -> (a1, [a2])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ p @ a1 (s :: a) (ds :: p) -> (s, GHC.Types.[] @ a1)) -}
ab7369b4aafebf4d012bef1d822de302
  skolemize ::
    a
    -> Data.Text.Internal.Text
    -> GHC.Types.Int
    -> Language.PureScript.Types.SkolemScope
    -> Language.PureScript.Types.Type a
    -> Language.PureScript.Types.Type a
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   (ann :: a)
                   (ident :: Data.Text.Internal.Text)
                   (sko :: GHC.Types.Int)
                   (scope :: Language.PureScript.Types.SkolemScope)
                   (eta :: Language.PureScript.Types.Type a) ->
                 Language.PureScript.Types.replaceAllTypeVars_go
                   @ a
                   @ a
                   (GHC.Types.[] @ Data.Text.Internal.Text)
                   (GHC.Types.:
                      @ (Data.Text.Internal.Text, Language.PureScript.Types.Type a)
                      (ident, Language.PureScript.Types.Skolem @ a ann ident sko scope)
                      (GHC.Types.[]
                         @ (Data.Text.Internal.Text, Language.PureScript.Types.Type a)))
                   eta) -}
68ed51015701e37d503a57703ecb4eda
  skolemizeTypesInValue ::
    Language.PureScript.AST.SourcePos.SourceAnn
    -> Data.Text.Internal.Text
    -> GHC.Types.Int
    -> Language.PureScript.Types.SkolemScope
    -> Language.PureScript.AST.Declarations.Expr
    -> Language.PureScript.AST.Declarations.Expr
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U> -}
"SC:$w$sgo30" [0] forall (sc :: GHC.Prim.Int#)
                         (sc1 :: Language.PureScript.Types.SkolemScope)
                         (sc2 :: Data.Set.Internal.Set
                                   Language.PureScript.Types.SkolemScope)
                         (sc3 :: Data.Set.Internal.Set
                                   Language.PureScript.Types.SkolemScope)
                         (sc4 :: GHC.Prim.Int#)
                         (sc5 :: Language.PureScript.Types.SkolemScope)
  Language.PureScript.TypeChecker.Skolems.$w$sgo3 sc5
                                                  sc4
                                                  (Data.Set.Internal.Bin
                                                     @ Language.PureScript.Types.SkolemScope
                                                     sc
                                                     sc1
                                                     sc2
                                                     sc3)
  = Language.PureScript.TypeChecker.Skolems.$sinsert_$s$w$sgo3
      sc
      sc1
      sc2
      sc3
      sc4
      sc5
"SPEC/Language.PureScript.TypeChecker.Skolems $wsplitS @ SkolemScope" [orphan] [0] forall (w :: GHC.Classes.Ord
                                                                                                  Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.$wsplitS @ Language.PureScript.Types.SkolemScope
                             w
  = Language.PureScript.TypeChecker.Skolems.$s$wsplitS
"SPEC/Language.PureScript.TypeChecker.Skolems fromList @ SkolemScope" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                  Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.fromList @ Language.PureScript.Types.SkolemScope
                             $dOrd
  = Language.PureScript.TypeChecker.Skolems.$sfromList
"SPEC/Language.PureScript.TypeChecker.Skolems union @ SkolemScope" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                               Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.union @ Language.PureScript.Types.SkolemScope
                          $dOrd
  = Language.PureScript.TypeChecker.Skolems.$sunion
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

