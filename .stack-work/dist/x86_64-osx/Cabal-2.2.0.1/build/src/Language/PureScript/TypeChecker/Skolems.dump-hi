
==================== FINAL INTERFACE ====================
2018-11-30 20:47:24.880026 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeChecker.Skolems 8043
  interface hash: 32338b5e1019a4df3ff21625d57be21c
  ABI hash: f177d1401fc0e1a8b89ef83cdae40ba1
  export-list hash: 96cf1a567f2e8b0e83ff8cd880c3e6bb
  orphan hash: 923b0ba86d52fbb4da13817c7fddbeed
  flag hash: 16532b0f9807287e7d68a156c2412cf2
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.TypeChecker.Skolems.introduceSkolemScope
  Language.PureScript.TypeChecker.Skolems.newSkolemConstant
  Language.PureScript.TypeChecker.Skolems.newSkolemScope
  Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck
  Language.PureScript.TypeChecker.Skolems.skolemize
  Language.PureScript.TypeChecker.Skolems.skolemizeTypesInValue
module dependencies: Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.PSString Language.PureScript.Parser.Lexer
                     Language.PureScript.Parser.State Language.PureScript.Pretty
                     Language.PureScript.Pretty.Common Language.PureScript.Pretty.Kinds
                     Language.PureScript.Pretty.Types Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeChecker.Monad
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 boxes-0.1.5 bytestring-0.10.8.2 colour-2.3.4
                      containers-0.5.11.0 deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 mtl-2.2.2 parsec-3.1.13.0
                      pattern-arrows-0.0.2 pretty-1.1.3.6 primitive-0.6.3.0
                      protolude-0.2.2 random-1.1 scientific-0.3.6.2 sourcemap-0.1.6
                      split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances colour-2.3.4:Data.Colour
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Declarations
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Operators
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.SourcePos
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Environment
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Kinds
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Label
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Names
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Functor.Identity 9430dcaadd71c129eeb5ca7b963c9b54
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  containers-0.5.11.0:Data.Set 7d3c64a641be4cacbcd8119445bab919
import  -/  containers-0.5.11.0:Data.Set.Internal 93fa3ef95853aa2a7aadf32d693bd451
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  Language.PureScript.AST 7ed0e74bfed5b6489b8a5eabab5c0241
  exports: 0d53d92339536cd6d8d7dcfcad8e7c7e
import  -/  Language.PureScript.AST.Binders 9d60985147b34b89300370e810fed430
  Binder 50aa153193e190eabd8ac7530e604f9c
  TypedBinder f780e44b8446316aee6b532b3afc4341
import  -/  Language.PureScript.AST.Declarations 568e046fbf27b243bfc96f09017d4782
  DeferredDictionary 7a56aac6dc1b7f4256df8373658d67a5
  ErrorInExpression 358d86f3d7f781558b2b7efc3f66ec3a
  ErrorMessage bc889ae8d74a01dbbd95e220faa4631d
  ErrorMessage cebd18718f7c34278cac50a2f0ab0386
  EscapedSkolem f37e734bbe28d00cd39992993f1e8b25
  Expr b31d94d0c7b90700d40f9ba6ec420e41
  PositionedValue ce9f35ccf631ea46c29b12e823f5cdda
  TypedValue d9e4565826b9abbfd5d9b0aba42f2e58
import  -/  Language.PureScript.AST.SourcePos b3f67f807f2dce79528bbb15bd9c7104
  SourceSpan 73c071552214b3f18e94970349d3affc
import  -/  Language.PureScript.AST.Traversals a3d1a9b4309f1aa3055f23e3fb101c5e
  everythingWithContextOnValues 96100f22de180f7be1760582c2409ed4
  everywhereWithContextOnValuesM 4fdd13188200e3f571550d8ad6f3de86
import  -/  Language.PureScript.Crash 1bc11bf824676e9581610d0d05d26761
  exports: 8a971f39d6ef3f27956f413640cb0a24
  internalError f3db7e23c75878c9d13888d6d114012d
import  -/  Language.PureScript.Errors 15d6eb6b2d4d480750061a0585d4e64c
  exports: 142ea650dec62642d1cff09ef1eee74e
  MultipleErrors ad1de73a1d5a6b0ccd9657dedebc94f3
  positionedError d8ca57e35818a7e93c5200eeb190e167
  singleError 8cdec4403bbf7ee5542ebca436a64fe1
import  -/  Language.PureScript.Traversals 0b1167883a6d6cc72496ff4af9cd7535
  exports: ff3aac3cd7b378c02751a42ba037de7e
  defS 6ddff71af3ee79c0e480484d77dbcf66
import  -/  Language.PureScript.TypeChecker.Monad 36a86b5cfef989dae17621bbace19db6
  exports: 9d9d275b045efb93172c1bb44957da47
  CheckState 5c23016b2e80baec4bdda0c92644cfa1
  checkNextSkolem 5c23016b2e80baec4bdda0c92644cfa1
  checkNextSkolemScope 5c23016b2e80baec4bdda0c92644cfa1
import  -/  Language.PureScript.Types 74562e642f5297557b3a23aac7819ad1
  exports: ae97bc75fcebc59f59c970736847a827
  ForAll 8e5cfabdac15777ed3387d8a0029598b
  Skolem e2f87ac818d8dc245fc6ff263c6e89ee
  SkolemScope 1bf86ad2a24dfb6f1cc38c159a9c7293
  SkolemScope a310b02c3c8476040cc9bad12d250769
  Type 93223f8afa90d0facc05a03f863dc72d
  everythingOnTypes ba4f3716db899e239fbb16fb1fa82a8f
  everywhereOnTypesM 46428778ed53c5878c6229be3528079b
  replaceTypeVars 8aa821bc3a9244ffb7cf21d6ffc31f22
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  text-1.2.3.0:Data.Text.Internal 30a0a123f71f63b26cd34c6b24f23411
545fbbc6b77a8463ab3f2455fe9ff94d
  $s$wsplitS ::
    Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> (# Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
          Data.Set.Internal.Set Language.PureScript.Types.SkolemScope #)
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>, Inline: [~] -}
4b8df1c117e0c32b38ec8475814b2911
  $sfromList ::
    [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.PureScript.Types.SkolemScope]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of nt { GHC.Types.I# ipv ->
                           Data.Set.Internal.Bin
                             @ Language.PureScript.Types.SkolemScope
                             1#
                             nt `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                             (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                             (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope) }
                        : ipv ipv1
                        -> case x `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of wild2 { GHC.Types.I# x1 ->
                           case ipv
                                  `cast`
                                (Language.PureScript.Types.N:SkolemScope[0]) of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x1 y of lwild {
                             DEFAULT
                             -> Language.PureScript.TypeChecker.Skolems.$sfromList_$s$wgo3
                                  wild3 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Types.SkolemScope
                                     1#
                                     wild2 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                                     (Data.Set.Internal.Tip
                                        @ Language.PureScript.Types.SkolemScope))
                                  1#
                             1#
                             -> Language.PureScript.TypeChecker.Skolems.$sfromList_$sgo4
                                  wild3 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                  ipv1
                                  (Data.Set.Internal.Bin
                                     @ Language.PureScript.Types.SkolemScope
                                     1#
                                     wild2 `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))
                                     (Data.Set.Internal.Tip @ Language.PureScript.Types.SkolemScope)
                                     (Data.Set.Internal.Tip
                                        @ Language.PureScript.Types.SkolemScope)) } } } } }) -}
891df90b368488e93b021111bad69c52
  $sfromList_$s$wgo3 ::
    Language.PureScript.Types.SkolemScope
    -> [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 4, Strictness: <S,1*U(U)><S,1*U><S,1*U><L,U> -}
009db3242ffca372b43736c4373f46b7
  $sfromList_$sgo4 ::
    Language.PureScript.Types.SkolemScope
    -> [Language.PureScript.Types.SkolemScope]
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><S,1*U> -}
d5cfca4ef2c6db9a99f2188af7e51a8e
  $sinsert_$s$w$sgo3 ::
    GHC.Prim.Int#
    -> Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 6, Strictness: <L,U><S(S),1*U(U)><L,U><L,U><S,U><L,U> -}
baf1f85ac183b3175c9111b2a10d5dcf
  $sunion ::
    Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
d4bb865389d8649a9ac83c21acbcabc7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.TypeChecker.Skolems.$trModule3
                   Language.PureScript.TypeChecker.Skolems.$trModule1) -}
eff065895b20dbd9658a6cae52d67d4c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Skolems.$trModule2) -}
75ec050139845836940a248776a10ad9
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.TypeChecker.Skolems"#) -}
1a3cc4590f889f5731b47a0fe8916c2a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.TypeChecker.Skolems.$trModule4) -}
3dfa663262c8aa4e697202c7e636e9e3
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
12ff6f31bd9bc47a2370d24997059998
  $w$sgo1 ::
    Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
cc7cef78b2b18f48476e4fa31e27f481
  $w$sgo3 ::
    Language.PureScript.Types.SkolemScope
    -> GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
3f696d6d555103176e620040be78f975
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set Language.PureScript.Types.SkolemScope
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
80e9b7ccd3f749b385f0a6b18602483d
  introduceSkolemScope ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    Language.PureScript.Types.Type -> m Language.PureScript.Types.Type
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),C(C1(U)),C(U),A),U,A,C(U))><S,1*U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m)
                   (eta :: Language.PureScript.Types.Type) ->
                 Language.PureScript.Types.everywhereOnTypesM
                   @ m
                   (Control.Monad.State.Class.$p1MonadState
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ m
                      $dMonadState)
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.State.Class.$p1MonadState
                          @ Language.PureScript.TypeChecker.Monad.CheckState
                          @ m
                          $dMonadState
                    } in
                    let {
                      $dFunctor :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                    } in
                    let {
                      $dFunctor1 :: GHC.Base.Functor m
                      = GHC.Base.$p1Applicative @ m $dFunctor
                    } in
                    let {
                      lvl19 :: m (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                      = GHC.Base.fmap
                          @ m
                          $dFunctor1
                          @ Language.PureScript.Types.SkolemScope
                          @ (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                          (GHC.Base.Just @ Language.PureScript.Types.SkolemScope)
                          (Language.PureScript.TypeChecker.Skolems.newSkolemScope
                             @ m
                             $dMonadState)
                    } in
                    \ (ds :: Language.PureScript.Types.Type) ->
                    case ds of wild {
                      DEFAULT
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.PureScript.Types.Type
                           wild
                      Language.PureScript.Types.ForAll ident ty ds1
                      -> case ds1 of wild1 {
                           GHC.Base.Nothing
                           -> GHC.Base.fmap
                                @ m
                                $dFunctor1
                                @ (GHC.Base.Maybe Language.PureScript.Types.SkolemScope)
                                @ Language.PureScript.Types.Type
                                (Language.PureScript.Types.ForAll ident ty)
                                lvl19
                           GHC.Base.Just ipv
                           -> GHC.Base.return
                                @ m
                                $dMonad
                                @ Language.PureScript.Types.Type
                                wild } })
                   eta) -}
5b6080edfec8521657cf465342cd5618
  newSkolemConstant ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ GHC.Types.Int
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          ds4 })))
                   (\ (s :: GHC.Types.Int) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ GHC.Types.Int
                      (let {
                         lvl19 :: GHC.Types.Int
                         = case s of wild { GHC.Types.I# x ->
                           GHC.Types.I# (GHC.Prim.+# x 1#) }
                       } in
                       Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                          (GHC.Tuple.(),
                           case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           Language.PureScript.TypeChecker.Monad.CheckState
                             ds
                             ds1
                             ds2
                             lvl19
                             ds4
                             ds5
                             ds6
                             ds7 })))
                      (GHC.Base.return @ m $dMonad @ GHC.Types.Int s))) -}
231e08acc836c43563bcf9a64cc2874f
  newSkolemScope ::
    Control.Monad.State.Class.MonadState
      Language.PureScript.TypeChecker.Monad.CheckState m =>
    m Language.PureScript.Types.SkolemScope
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLL),U(1*U(A,C(C1(U)),C(C1(U)),C(U),A),1*U,A,C(U))>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadState :: Control.Monad.State.Class.MonadState
                                      Language.PureScript.TypeChecker.Monad.CheckState m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.State.Class.$p1MonadState
                       @ Language.PureScript.TypeChecker.Monad.CheckState
                       @ m
                       $dMonadState
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ GHC.Types.Int
                   @ Language.PureScript.Types.SkolemScope
                   (GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.PureScript.TypeChecker.Monad.CheckState
                      @ GHC.Types.Int
                      (Control.Monad.State.Class.get
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState)
                      (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         (case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          ds5 })))
                   (\ (s :: GHC.Types.Int) ->
                    GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ Language.PureScript.Types.SkolemScope
                      (let {
                         lvl19 :: GHC.Types.Int
                         = case s of wild { GHC.Types.I# x ->
                           GHC.Types.I# (GHC.Prim.+# x 1#) }
                       } in
                       Control.Monad.State.Class.state
                         @ Language.PureScript.TypeChecker.Monad.CheckState
                         @ m
                         $dMonadState
                         @ ()
                         (\ (s1 :: Language.PureScript.TypeChecker.Monad.CheckState) ->
                          (GHC.Tuple.(),
                           case s1 of wild { Language.PureScript.TypeChecker.Monad.CheckState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           Language.PureScript.TypeChecker.Monad.CheckState
                             ds
                             ds1
                             ds2
                             ds3
                             lvl19
                             ds5
                             ds6
                             ds7 })))
                      (GHC.Base.return
                         @ m
                         $dMonad
                         @ Language.PureScript.Types.SkolemScope
                         s `cast` (Sym (Language.PureScript.Types.N:SkolemScope[0]))))) -}
1ac509a82ed60beaab1278ae93e533d1
  skolemEscapeCheck ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors m =>
    Language.PureScript.AST.Declarations.Expr -> m ()
  {- Arity: 1,
     Strictness: <L,U(1*U(1*U(A,1*C1(U),A,A,C(C1(U)),A),A,A,1*C1(U),A),C(U),A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      Language.PureScript.Errors.MultipleErrors m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Error.Class.$p1MonadError
                       @ Language.PureScript.Errors.MultipleErrors
                       @ m
                       $dMonadError
                 } in
                 let {
                   lvl19 :: m () = GHC.Base.return @ m $dMonad @ () GHC.Tuple.()
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   lvl20 :: m () = GHC.Base.pure @ m $dApplicative @ () GHC.Tuple.()
                 } in
                 letrec {
                   go :: [Language.PureScript.AST.Declarations.ErrorMessage] -> m ()
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Language.PureScript.AST.Declarations.ErrorMessage]) ->
                     case ds of wild {
                       [] -> lvl20
                       : y ys
                       -> GHC.Base.*>
                            @ m
                            $dApplicative
                            @ GHC.Types.Any
                            @ ()
                            (Control.Monad.Error.Class.throwError
                               @ Language.PureScript.Errors.MultipleErrors
                               @ m
                               $dMonadError
                               @ GHC.Types.Any
                               (GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  y
                                  (GHC.Types.[]
                                     @ Language.PureScript.AST.Declarations.ErrorMessage))
                                 `cast`
                               (Sym (Language.PureScript.Errors.N:MultipleErrors[0])))
                            (go ys) }
                 } in
                 \ (ds :: Language.PureScript.AST.Declarations.Expr) ->
                 case ds of wild {
                   DEFAULT
                   -> Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck5 @ m
                   Language.PureScript.AST.Declarations.TypedValue ds1 ds2 ds3
                   -> case ds1 of wild1 {
                        GHC.Types.False -> lvl19
                        GHC.Types.True
                        -> case Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck1 of wild2 { (,,,,) ds4 toSkolemErrors ds5 ds6 ds7 ->
                           go (toSkolemErrors wild) } } }) -}
9e09cc74ec06c787e95840beb756f233
  skolemEscapeCheck1 ::
    (Language.PureScript.AST.Declarations.Declaration
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.Expr
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Binders.Binder
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.CaseAlternative
     -> [Language.PureScript.AST.Declarations.ErrorMessage],
     Language.PureScript.AST.Declarations.DoNotationElement
     -> [Language.PureScript.AST.Declarations.ErrorMessage])
  {- Unfolding: (case Language.PureScript.AST.Traversals.$weverythingWithContextOnValues
                        @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                        @ [Language.PureScript.AST.Declarations.ErrorMessage]
                        Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck4
                        (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (GHC.Base.++ @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.Declaration
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck2
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Binders.Binder
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.CaseAlternative
                           @ Language.PureScript.AST.Declarations.ErrorMessage)
                        (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_def
                           @ (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                           @ Language.PureScript.AST.Declarations.DoNotationElement
                           @ Language.PureScript.AST.Declarations.ErrorMessage) of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 (ww1, ww2, ww3, ww4, ww5) }) -}
fbffebb057f25527a92e7eeff1ed4cb3
  skolemEscapeCheck2 ::
    (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
     GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
    -> Language.PureScript.AST.Declarations.Expr
    -> ((Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
         GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan),
        [Language.PureScript.AST.Declarations.ErrorMessage])
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m,
     Unfolding: (\ (ds :: (Data.Set.Internal.Set
                             Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan))
                   (ds1 :: Language.PureScript.AST.Declarations.Expr)[OneShot] ->
                 case ds of wild { (,) scopes ds2 ->
                 case ds1 of wild1 {
                   DEFAULT
                   -> (wild,
                       GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                   Language.PureScript.AST.Declarations.TypedValue ds3 ds4 ty
                   -> let {
                        allScopes :: Data.Set.Internal.Set
                                       Language.PureScript.Types.SkolemScope
                        = Language.PureScript.TypeChecker.Skolems.$sunion
                            (Language.PureScript.TypeChecker.Skolems.$sfromList
                               (Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck_collectScopes
                                  ty))
                            scopes
                      } in
                      ((allScopes, ds2),
                       let {
                         lvl19 :: [Language.PureScript.AST.Declarations.ErrorMessageHint]
                         = case ds2 of wild2 {
                             GHC.Base.Nothing
                             -> GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                  (Language.PureScript.AST.Declarations.ErrorInExpression wild1)
                                  (GHC.Types.[]
                                     @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                             GHC.Base.Just x
                             -> GHC.Types.:
                                  @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                  (Language.PureScript.Errors.positionedError x)
                                  (GHC.Types.:
                                     @ Language.PureScript.AST.Declarations.ErrorMessageHint
                                     (Language.PureScript.AST.Declarations.ErrorInExpression wild1)
                                     (GHC.Types.[]
                                        @ Language.PureScript.AST.Declarations.ErrorMessageHint)) }
                       } in
                       letrec {
                         go :: [(Data.Text.Internal.Text,
                                 Language.PureScript.Types.SkolemScope,
                                 GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)]
                               -> [Language.PureScript.AST.Declarations.ErrorMessage]
                           {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds5 :: [(Data.Text.Internal.Text,
                                       Language.PureScript.Types.SkolemScope,
                                       GHC.Base.Maybe
                                         Language.PureScript.AST.SourcePos.SourceSpan)]) ->
                           case ds5 of wild2 {
                             []
                             -> GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage
                             : y ys
                             -> case y of wild3 { (,,) name scope ssBound ->
                                case scope
                                       `cast`
                                     (Language.PureScript.Types.N:SkolemScope[0]) of ww { GHC.Types.I# ww1 ->
                                case Language.PureScript.TypeChecker.Skolems.$wgo3
                                       ww1
                                       allScopes of wild4 {
                                  GHC.Types.False
                                  -> GHC.Types.:
                                       @ Language.PureScript.AST.Declarations.ErrorMessage
                                       (Language.PureScript.AST.Declarations.ErrorMessage
                                          lvl19
                                          (Language.PureScript.AST.Declarations.EscapedSkolem
                                             name
                                             ssBound
                                             ty))
                                       (go ys)
                                  GHC.Types.True -> go ys } } } }
                       } in
                       go
                         (Language.PureScript.Types.everythingOnTypes
                            @ [(Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope,
                                GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)]
                            (GHC.Base.++
                               @ (Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope,
                                  GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan))
                            Language.PureScript.TypeChecker.Skolems.skolemEscapeCheck3
                            ty))
                   Language.PureScript.AST.Declarations.PositionedValue ss ds3 ds4
                   -> ((scopes,
                        GHC.Base.Just @ Language.PureScript.AST.SourcePos.SourceSpan ss),
                       GHC.Types.[]
                         @ Language.PureScript.AST.Declarations.ErrorMessage) } }) -}
8c931afd2beadbae46e99cea0af60476
  skolemEscapeCheck3 ::
    Language.PureScript.Types.Type
    -> [(Data.Text.Internal.Text,
         Language.PureScript.Types.SkolemScope,
         GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.PureScript.Types.Type) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                   Language.PureScript.Types.Skolem name ds1 scope srcSpan
                   -> GHC.Types.:
                        @ (Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope,
                           GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                        (name, scope, srcSpan)
                        (GHC.Types.[]
                           @ (Data.Text.Internal.Text, Language.PureScript.Types.SkolemScope,
                              GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)) }) -}
76c1c3d2e6e511af823ffcdbd84addde
  skolemEscapeCheck4 ::
    (Data.Set.Internal.Set Language.PureScript.Types.SkolemScope,
     GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Data.Set.Internal.Tip
                    @ Language.PureScript.Types.SkolemScope,
                  GHC.Base.Nothing
                    @ Language.PureScript.AST.SourcePos.SourceSpan)) -}
839595ea2d59c5907f0a82ab9c31b6bf
  skolemEscapeCheck5 :: m ()
  {- Strictness: x -}
b612eb8437d0525f2ca3fd0ce20c8614
  skolemEscapeCheck_collectScopes ::
    Language.PureScript.Types.Type
    -> [Language.PureScript.Types.SkolemScope]
  {- Arity: 1, Strictness: <S,1*U> -}
966d2037898c80abb26c69f89c4cd964
  skolemEscapeCheck_def :: a1 -> p -> (a1, [a2])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ p @ a1 (s :: a) (ds :: p) -> (s, GHC.Types.[] @ a1)) -}
de5aa18c557b3d076ec90257b3b337ae
  skolemize ::
    Data.Text.Internal.Text
    -> GHC.Types.Int
    -> Language.PureScript.Types.SkolemScope
    -> GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan
    -> Language.PureScript.Types.Type
    -> Language.PureScript.Types.Type
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U>,
     Unfolding: InlineRule (5, True, False)
                (\ (ident :: Data.Text.Internal.Text)
                   (sko :: GHC.Types.Int)
                   (scope :: Language.PureScript.Types.SkolemScope)
                   (ss :: GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan)
                   (eta :: Language.PureScript.Types.Type) ->
                 Language.PureScript.Types.replaceAllTypeVars_go
                   (GHC.Types.[] @ Data.Text.Internal.Text)
                   (GHC.Types.:
                      @ (Data.Text.Internal.Text, Language.PureScript.Types.Type)
                      (ident, Language.PureScript.Types.Skolem ident sko scope ss)
                      (GHC.Types.[]
                         @ (Data.Text.Internal.Text, Language.PureScript.Types.Type)))
                   eta) -}
9186408ce4aee258d393a5c011057a7b
  skolemizeTypesInValue ::
    Data.Text.Internal.Text
    -> GHC.Types.Int
    -> Language.PureScript.Types.SkolemScope
    -> GHC.Base.Maybe Language.PureScript.AST.SourcePos.SourceSpan
    -> Language.PureScript.AST.Declarations.Expr
    -> Language.PureScript.AST.Declarations.Expr
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U> -}
"SC:$w$sgo30" [0] forall (sc :: GHC.Prim.Int#)
                         (sc1 :: Language.PureScript.Types.SkolemScope)
                         (sc2 :: Data.Set.Internal.Set
                                   Language.PureScript.Types.SkolemScope)
                         (sc3 :: Data.Set.Internal.Set
                                   Language.PureScript.Types.SkolemScope)
                         (sc4 :: GHC.Prim.Int#)
                         (sc5 :: Language.PureScript.Types.SkolemScope)
  Language.PureScript.TypeChecker.Skolems.$w$sgo3 sc5
                                                  sc4
                                                  (Data.Set.Internal.Bin
                                                     @ Language.PureScript.Types.SkolemScope
                                                     sc
                                                     sc1
                                                     sc2
                                                     sc3)
  = Language.PureScript.TypeChecker.Skolems.$sinsert_$s$w$sgo3
      sc
      sc1
      sc2
      sc3
      sc4
      sc5
"SPEC/Language.PureScript.TypeChecker.Skolems $wsplitS @ SkolemScope" [orphan] [0] forall (w :: GHC.Classes.Ord
                                                                                                  Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.$wsplitS @ Language.PureScript.Types.SkolemScope
                             w
  = Language.PureScript.TypeChecker.Skolems.$s$wsplitS
"SPEC/Language.PureScript.TypeChecker.Skolems fromList @ SkolemScope" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                                  Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.fromList @ Language.PureScript.Types.SkolemScope
                             $dOrd
  = Language.PureScript.TypeChecker.Skolems.$sfromList
"SPEC/Language.PureScript.TypeChecker.Skolems union @ SkolemScope" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                                               Language.PureScript.Types.SkolemScope)
  Data.Set.Internal.union @ Language.PureScript.Types.SkolemScope
                          $dOrd
  = Language.PureScript.TypeChecker.Skolems.$sunion
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

