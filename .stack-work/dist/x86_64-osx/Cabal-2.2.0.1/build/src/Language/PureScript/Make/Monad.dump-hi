
==================== FINAL INTERFACE ====================
2019-01-24 14:16:01.996765 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Make.Monad [family instance module] 8043
  interface hash: be306b14eecc1d25276183f6a6074b3f
  ABI hash: 31242626e8d67103dbe8824cd3d4896a
  export-list hash: 41e56279602585a94789ab2db04fcf5f
  orphan hash: fa608d717e2dda4d42614555f7bbc411
  flag hash: 964ca6959d8816591051842cb80443f3
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Make.Monad.makeIO
  Language.PureScript.Make.Monad.readTextFile
  Language.PureScript.Make.Monad.runMake
  Language.PureScript.Make.Monad.Make{Language.PureScript.Make.Monad.Make unMake}
module dependencies: Control.Monad.Logger Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.Options Language.PureScript.PSString
                     Language.PureScript.Parser.Lexer Language.PureScript.Parser.State
                     Language.PureScript.Pretty Language.PureScript.Pretty.Common
                     Language.PureScript.Pretty.Kinds Language.PureScript.Pretty.Types
                     Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 ansi-terminal-0.8.0.4
                      array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2 base-4.11.1.0
                      base-compat-0.10.4 binary-0.8.5.1 blaze-builder-0.4.1.0 boxes-0.1.5
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.5.11.0
                      deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.1 language-javascript-0.6.0.11
                      microlens-0.4.9.1 microlens-ghc-0.4.9 microlens-mtl-0.1.11.1
                      microlens-platform-0.3.10 microlens-th-0.4.2.1
                      monad-control-1.0.2.3 mtl-2.2.2 parsec-3.1.13.0
                      pattern-arrows-0.0.2 pretty-1.1.3.6 primitive-0.6.3.0
                      protolude-0.2.2 random-1.1 scientific-0.3.6.2 sourcemap-0.1.6
                      split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      transformers-base-0.4.5.2 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         microlens-platform-0.3.10:Lens.Micro.Platform
         microlens-ghc-0.4.9:Lens.Micro.GHC
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle colour-2.3.4:Data.Colour
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         microlens-0.4.9.1:Lens.Micro.Internal
                         microlens-ghc-0.4.9:Lens.Micro.GHC
                         microlens-mtl-0.1.11.1:Lens.Micro.Mtl.Internal
                         microlens-platform-0.3.10:Lens.Micro.Platform
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Control.Monad.Logger
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Declarations
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Operators
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.SourcePos
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Comments
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Environment
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Kinds
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Label
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Names
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.IO.Exception acc060dca2e46d8b8275d06ee7d5d60d
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO.Error e9cae3ab377d64b36ad020e6acace3fb
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy b6cb59a78204810b2a79502bf5b4c1fc
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Internal af245ead1f52eca50149d040b0b86693
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  monad-control-1.0.2.3:Control.Monad.Trans.Control 82c27f877a1c7cc212232dcea6f7b8e9
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader a496a2f5c2c54feee0ad154b4fe8533d
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  Control.Monad.Logger 7ce28f5655d854c20c31601b5979a9bd
  exports: 3f3ab269c0ac18f7e4ca63a6b0fe7337
  Logger f4473efc589a46d9d0cdaec9bf6774cf
  runLogger' 8b92479f02f6dbc6ea9156395e779867
import  -/  Language.PureScript.AST e89b59f8e201961eafd3ff905a683659
  exports: be73d3bb7d4ebe5df082453f6d572075
import  -/  Language.PureScript.AST.Declarations 586bc75044e8737d02875208d17d4395
  CannotReadFile 14dc16d8c2f8a03a9a3da680e342d754
  ErrorMessage b0470a74191782e72607e7c5b87318de
  ErrorMessage 7268a73b9f5bbe5a70110aa90f7e1194
import  -/  Language.PureScript.Errors 3c1ad933587510f8b20a8c9ec2e86ce9
  exports: 8e61484c4664eceb943d9fc4820c721b
  MultipleErrors e1ef6a17348ccfe3ef65185d3c5f9026
  singleError a36dd8bcfe054c062a952f4ca37285fa
import  -/  Language.PureScript.Options 2e36bd5fcc2b2ebbc36ff47b336cef60
  exports: 95606a481170637dfadecf960e8d7bae
  Options 43e82b7ea0c416dc61c77c04548dbdd3
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
import  -/  transformers-base-0.4.5.2:Control.Monad.Base 0525bddaf47f5bace6a58bd35649c995
2384e2052993ac0b8b29c8eccd939cb5
  $fApplicativeMake ::
    GHC.Base.Applicative Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fFunctorMake
                  Language.PureScript.Make.Monad.$fApplicativeMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a -> b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (\ @ a @ b @ c ->
                   Language.PureScript.Make.Monad.$fApplicativeMake1 @ c @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <c>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <c>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
26e5d1695ed2113c14face1c14742806
  $fApplicativeMake1 ::
    (a -> b -> c)
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Unfolding: (\ @ c
                   @ b
                   @ a
                   (eta :: a -> b -> c)
                   (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Options.Options
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              a)
                   (eta2 :: Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Options.Options
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (eta3 :: Language.PureScript.Options.Options) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       eta3
                 } in
                 let {
                   w2 :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           b
                   = eta2
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <b>_N)
                       eta3
                 } in
                 (\ (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left x
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ c
                            x #)
                    Data.Either.Right y
                    -> case (w2
                               `cast`
                             (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors>_R
                                  <b>_N ; Control.Monad.Logger.N:Logger[0]
                                              <Language.PureScript.Errors.MultipleErrors>_R
                                              <Data.Either.Either
                                                 Language.PureScript.Errors.MultipleErrors b>_R)
                               r)
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                              ipv of ds2 { (#,#) ipv2 ipv3 ->
                       case ipv3 of wild1 {
                         Data.Either.Left e1
                         -> (# ipv2,
                               Data.Either.Left
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ c
                                 e1 #)
                         Data.Either.Right x
                         -> (# ipv2,
                               Data.Either.Right
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ c
                                 (eta y x) #) } } } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    c>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          c>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <c>_N)))) -}
85b49af834f068dac6a311c7683a019c
  $fApplicativeMake2 ::
    a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (x :: a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      x #)) -}
307bb813af450847143ce06b5f0f6b67
  $fApplicativeMake_$s$fApplicativeLogger ::
    GHC.Base.Applicative
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  (Control.Monad.Logger.$fFunctorLogger
                     @ Language.PureScript.Errors.MultipleErrors)
                  (\ @ a
                     (x :: a)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# eta1, x #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ @ a
                     @ b
                     (m1 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors (a -> b))
                     (m2 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (m1
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a -> b>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a -> b>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   case (m2
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          ipv of ds2 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors (a -> b)>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors a)
                     (eta :: Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors b)
                     (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (x `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta2 of ds { (#,#) ipv ipv1 ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, f1 ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <c>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <c>_R))
                  (\ @ a
                     @ b
                     (a1 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (a2 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors b)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (a1
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta1 of ds { (#,#) ipv ipv1 ->
                   (a2
                      `cast`
                    (Control.Monad.Logger.N:Logger[0]
                         <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                      eta)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors a)
                     (eta :: Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors b)
                     (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (x `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta2 of ds { (#,#) ipv ipv1 ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R)) -}
ea98ae6ef9590f2b314e26c1a0159fee
  $fApplicativeMake_$s$fApplicativeReaderT_$c*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (r1 :: r) ->
                 let {
                   m1 :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = u `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 let {
                   k :: Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)
                          b
                   = v `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <b>_N)
                       r1
                 } in
                 (\ (r2 :: GHC.IORef.IORef
                             Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ b
                            e1 #)
                    Data.Either.Right x
                    -> (k `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <b>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors b>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                         ipv } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <b>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
0b7a547b7b73fd329dcaeeb55e20e610
  $fApplicativeMake_$s$fApplicativeReaderT_$c<* ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (r1 :: r) ->
                 let {
                   x :: Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)
                          a
                   = u `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Logger.$fFunctorLogger
                      @ Language.PureScript.Errors.MultipleErrors)
                   Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                   @ b
                   @ a
                   (\ (r2 :: GHC.IORef.IORef
                               Language.PureScript.Errors.MultipleErrors)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (x `cast`
                          (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               <a>_N ; Control.Monad.Logger.N:Logger[0]
                                           <Language.PureScript.Errors.MultipleErrors>_R
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors a>_R)
                            r2)
                           `cast`
                         (GHC.Types.N:IO[0]
                              <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                           s of ds1 { (#,#) ipv ipv1 ->
                    (# ipv,
                       Control.Monad.Trans.Except.$fApplicativeExceptT1
                         @ a
                         @ b
                         @ Language.PureScript.Errors.MultipleErrors
                         ipv1 #) })
                     `cast`
                   ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a)>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                <Language.PureScript.Errors.MultipleErrors>_R
                                                                <Data.Either.Either
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (b
                                                                    -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                                                         <Control.Monad.Logger.Logger
                                                                                            Language.PureScript.Errors.MultipleErrors>_R
                                                                                         <b
                                                                                          -> a>_N)))
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <b>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <a>_N)) -}
ef4acf85cae41cf03a38dfab0c9de557
  $fApplicativeMake_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Logger.$fFunctorLogger
                      @ Language.PureScript.Errors.MultipleErrors)
                   Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                   @ a
                   @ b
                   (f `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a -> b>_N)
                      r1)
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
6a041d9959f382a86822ad2a05f891e0
  $fApplicativeMake_$s$fMonadLogger ::
    GHC.Base.Monad
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeLogger
                  (\ @ a
                     @ b
                     (ds :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (f :: a
                           -> Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors b)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   ((f ipv1)
                      `cast`
                    (Control.Monad.Logger.N:Logger[0]
                         <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                      r)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <a
                         -> Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger_$c>>
                  (\ @ a
                     (x :: a)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# eta1, x #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors a)) -}
fec508cc8507f16df346ffa8c4101309
  $fApplicativeMake_$s$fMonadLogger_$c>> ::
    Control.Monad.Logger.Logger
      Language.PureScript.Errors.MultipleErrors a
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors a)
                   (k :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (k `cast`
                  (Control.Monad.Logger.N:Logger[0]
                       <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                    r)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.Logger
                    Language.PureScript.Errors.MultipleErrors a>_R
                 ->_R <Control.Monad.Logger.Logger
                         Language.PureScript.Errors.MultipleErrors b>_R
                 ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        <b>_R)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fFunctorMake ::
    GHC.Base.Functor Language.PureScript.Make.Monad.Make
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$cfmap
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$c<$
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
144a3ea6e563cd5bc8f1f03dc939753b
  $fFunctorMake_$s$fFunctorExceptT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors (Data.Either.Either e a))
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (ds
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R
                            <Data.Either.Either e a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.$fApplicativeEither_$cfmap @ e @ a @ b f ipv1 #) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               <a>_N)
                 ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        e b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                             <Language.PureScript.Errors.MultipleErrors>_R
                                                             <Data.Either.Either
                                                                e
                                                                b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <e>_N
                                                                                 <Control.Monad.Logger.Logger
                                                                                    Language.PureScript.Errors.MultipleErrors>_R
                                                                                 <b>_N))) -}
9d3e9033fdad7ec55d9d8555a751d251
  $fFunctorMake_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (x :: a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b) ->
                 let {
                   lvl18 :: Data.Either.Either
                              Language.PureScript.Errors.MultipleErrors a
                   = Data.Either.Right
                       @ Language.PureScript.Errors.MultipleErrors
                       @ a
                       x
                 } in
                 (\ (x1 :: r) ->
                  let {
                    ds :: Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            b
                    = v `cast`
                      (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <r>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <b>_N)
                        x1
                  } in
                  (\ (r1 :: GHC.IORef.IORef
                              Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors>_R
                              <b>_N ; Control.Monad.Logger.N:Logger[0]
                                          <Language.PureScript.Errors.MultipleErrors>_R
                                          <Data.Either.Either
                                             Language.PureScript.Errors.MultipleErrors b>_R)
                           r1)
                          `cast`
                        (GHC.Types.N:IO[0]
                             <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   (# ipv,
                      case ipv1 of wild {
                        Data.Either.Left x2
                        -> Data.Either.Left
                             @ Language.PureScript.Errors.MultipleErrors
                             @ a
                             x2
                        Data.Either.Right y -> lvl18 } #) })
                    `cast`
                  ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        <Data.Either.Either
                                                           Language.PureScript.Errors.MultipleErrors
                                                           a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                            <Control.Monad.Logger.Logger
                                                                               Language.PureScript.Errors.MultipleErrors>_R
                                                                            <a>_N))))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <r>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <a>_N))) -}
a0a9e25b92daa6932545845d97b73813
  $fFunctorMake_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        (Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors))
                   @ a
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        (Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors))
                   @ b
                   @ r
                   (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorExceptT_$cfmap
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      @ b
                      f)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadBaseControlIOMake ::
    Control.Monad.Trans.Control.MonadBaseControl
      GHC.Types.IO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake
                  Language.PureScript.Make.Monad.$fMonadBaseControlIOMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.Control.RunInBase
                      Language.PureScript.Make.Monad.Make GHC.Types.IO
                    -> GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadBaseControlIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sub (Sym (Language.PureScript.Make.Monad.D:R:StMMakea[0] <a>_N))
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             (Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                            <Control.Monad.Trans.Control.StT
                                                               (Control.Monad.Trans.Reader.ReaderT
                                                                  Language.PureScript.Options.Options)
                                                               a>_N))))) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                     <Language.PureScript.Errors.MultipleErrors>_R
                                                                                     <Data.Either.Either
                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                        (Control.Monad.Trans.Control.StT
                                                                                           (Control.Monad.Trans.Reader.ReaderT
                                                                                              Language.PureScript.Options.Options)
                                                                                           a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                             <Control.Monad.Logger.Logger
                                                                                                                Language.PureScript.Errors.MultipleErrors>_R
                                                                                                             (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                                                                                                       <Language.PureScript.Options.Options>_N
                                                                                                                       <a>_N))))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                              <*>_N
                                                                                                                                              <Language.PureScript.Options.Options>_R
                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                 (Control.Monad.Logger.Logger
                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                              <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
432e327883232b0a394fa92cb1aec949
  $fMonadBaseControlIOMake1 ::
    Data.Either.Either Language.PureScript.Errors.MultipleErrors a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Control.Monad.Trans.Control.StT
            (Control.Monad.Trans.Except.ExceptT
               Language.PureScript.Errors.MultipleErrors)
            (Control.Monad.Trans.Control.StT
               (Control.Monad.Trans.Reader.ReaderT
                  Language.PureScript.Options.Options)
               a) #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (x :: Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    x `cast`
                    ((Data.Either.Either
                        <Language.PureScript.Errors.MultipleErrors>_R
                        (Sub (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                       <Language.PureScript.Options.Options>_N
                                       <a>_N))))_R ; Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Control.Monad.Trans.Control.StT
                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                         Language.PureScript.Options.Options)
                                                                      a>_N))) #)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadBaseControlIOMake2 ::
    (Control.Monad.Trans.Control.RunInBase
       Language.PureScript.Make.Monad.Make GHC.Types.IO
     -> GHC.Types.IO a)
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (f :: Control.Monad.Trans.Control.RunInBase
                           Language.PureScript.Make.Monad.Make GHC.Types.IO
                         -> GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (f (\ @ a1
                            (x :: Control.Monad.Trans.Reader.ReaderT
                                    Language.PureScript.Options.Options
                                    (Control.Monad.Trans.Except.ExceptT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Logger.Logger
                                          Language.PureScript.Errors.MultipleErrors))
                                    a1) ->
                          (x `cast`
                           (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N
                                <Language.PureScript.Options.Options>_R
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Logger.Logger
                                      Language.PureScript.Errors.MultipleErrors)>_R
                                <a1>_N)
                             eta)
                            `cast`
                          (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                         <Language.PureScript.Options.Options>_N
                                         <a1>_N)) ; Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        (Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Control.Monad.Trans.Control.StT
                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                             Language.PureScript.Options.Options)
                                                                          a1>_N))))
                            eta1)
                           `cast`
                         (forall (a1 :: <*>_N).
                          Sym (Language.PureScript.Make.Monad.N:Make[0]) <a1>_N
                          ->_R (GHC.Types.IO
                                  (Sub (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                            <Language.PureScript.Errors.MultipleErrors>_N
                                            <Control.Monad.Trans.Control.StT
                                               (Control.Monad.Trans.Reader.ReaderT
                                                  Language.PureScript.Options.Options)
                                               a1>_N) ; ((Data.Either.Either
                                                            <Language.PureScript.Errors.MultipleErrors>_R
                                                            (Sub (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                                                      <Language.PureScript.Options.Options>_N
                                                                      <a1>_N)))_R ; Sub (Sym (Language.PureScript.Make.Monad.D:R:StMMakea[0]
                                                                                                  <a1>_N)))))_R))
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      ipv1 #) }) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadBaseIOMake ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  @ Language.PureScript.Make.Monad.Make
                  GHC.Base.$fApplicativeIO
                  Language.PureScript.Make.Monad.$fApplicativeMake
                  GHC.Base.$fMonadIO
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
1b7f37a73269a916f020796e57a5f6ac
  $fMonadBaseIOMake1 ::
    GHC.Types.IO a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(S(SL)),1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (x :: GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case x `cast` (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      ipv1 #) }) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadErrorMake ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadErrorMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadErrorMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R (<Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
e742bd96a33a906d13489139c6879c99
  $fMonadErrorMake1 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (Language.PureScript.Errors.MultipleErrors
        -> Control.Monad.Trans.Reader.ReaderT
             Language.PureScript.Options.Options
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Logger.Logger
                   Language.PureScript.Errors.MultipleErrors))
             a)
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,U))))><L,C(C1(C1(C1(U))))><L,U>,
     Unfolding: (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             a)
                   (eta1 :: Language.PureScript.Errors.MultipleErrors
                            -> Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Options.Options
                                 (Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors))
                                 a)
                   (eta2 :: Language.PureScript.Options.Options) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = eta
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       eta2
                 } in
                 (\ (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left l
                    -> (((eta1 l)
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <Language.PureScript.Options.Options>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         ipv
                    Data.Either.Right r1 -> ds1 } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <a>_N)))) -}
5a99ef64f2bd08ea5d04447fbb7079e0
  $fMonadErrorMake2 ::
    Language.PureScript.Errors.MultipleErrors
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (eta :: Language.PureScript.Errors.MultipleErrors)
                   (eta1 :: Language.PureScript.Options.Options)
                   (eta2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta3,
                    Data.Either.Left
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      eta #)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadIOMake ::
    Control.Monad.IO.Class.MonadIO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadMake :: GHC.Base.Monad Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fApplicativeMake
                  (Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$c>>=
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  Language.PureScript.Make.Monad.$fApplicativeMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  (Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$cfail
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
7ec6e542626bd265c1673b793005399b
  $fMonadMake_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (a
        -> Control.Monad.Trans.Reader.ReaderT
             r
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Logger.Logger
                   Language.PureScript.Errors.MultipleErrors))
             b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(C1(U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Reader.ReaderT
                              r
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (r1 :: r) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = m1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 (\ (r2 :: GHC.IORef.IORef
                             Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ b
                            e1 #)
                    Data.Either.Right x
                    -> (((k x)
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <r>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <b>_N)
                           r1)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <b>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors b>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                         ipv } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <b>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
5962855ad5ecce19c063c9d927e41f14
  $fMonadMake_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) ->
                 let {
                   m1 :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors
                           (Data.Either.Either Language.PureScript.Errors.MultipleErrors a)
                     {- Strictness: x -}
                   = GHC.Err.errorWithoutStackTrace
                       @ 'GHC.Types.LiftedRep
                       @ (Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors
                            (Data.Either.Either Language.PureScript.Errors.MultipleErrors a))
                       msg
                 } in
                 (\ (ds :: r) -> m1)
                   `cast`
                 ((<r>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors>_R
                                 <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                    <*>_N
                                                    <r>_R
                                                    <Control.Monad.Trans.Except.ExceptT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors)>_R
                                                    <a>_N))) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadReaderMake ::
    Control.Monad.Reader.Class.MonadReader
      Language.PureScript.Options.Options
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Options.Options
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadReaderMake1
                    `cast`
                  ((<Language.PureScript.Options.Options>_R
                    ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           Language.PureScript.Options.Options>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                <Data.Either.Either
                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                   Language.PureScript.Options.Options>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                      <Control.Monad.Logger.Logger
                                                                                                                                                         Language.PureScript.Errors.MultipleErrors>_R
                                                                                                                                                      <Language.PureScript.Options.Options>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                                                             <*>_N
                                                                                                                                                                                                             <Language.PureScript.Options.Options>_R
                                                                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                (Control.Monad.Logger.Logger
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                             <Language.PureScript.Options.Options>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <Language.PureScript.Options.Options>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ Language.PureScript.Options.Options
                     @ Language.PureScript.Options.Options
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)))
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Options.Options
                    -> Language.PureScript.Options.Options>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)
                  (Language.PureScript.Make.Monad.$fMonadReaderMake_$sreader
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Options.Options -> a>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
a9580f5484f2aa47ddede4ddde24c701
  $fMonadReaderMake1 ::
    Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Language.PureScript.Options.Options #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ Language.PureScript.Options.Options
                      eta #)) -}
b59bd376148010bb422a726b6970c8b8
  $fMonadReaderMake_$sreader ::
    (r -> a)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (f :: r -> a) (x :: r) ->
                 let {
                   eta :: a = f x
                 } in
                 let {
                   x1 :: Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors a
                   = Data.Either.Right
                       @ Language.PureScript.Errors.MultipleErrors
                       @ a
                       eta
                 } in
                 (\ (eta1 :: GHC.IORef.IORef
                               Language.PureScript.Errors.MultipleErrors)
                    (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta2, x1 #))
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <a>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N).
                 <r -> a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <a>_N)) -}
2384e2052993ac0b8b29c8eccd939cb5
  $fMonadWriterMake ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadWriterMake4
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadWriterMake3
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                ()>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_R
                                                                    <Data.Either.Either
                                                                       Language.PureScript.Errors.MultipleErrors
                                                                       ()>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                                                         <Control.Monad.Logger.Logger
                                                                                            Language.PureScript.Errors.MultipleErrors>_R
                                                                                         <()>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                               <*>_N
                                                                                                               <Language.PureScript.Options.Options>_R
                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                               <()>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <()>_N))
                  Language.PureScript.Make.Monad.$fMonadWriterMake2
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <(a,
                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <(a,
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)
                  Language.PureScript.Make.Monad.$fMonadWriterMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <(a,
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    -> Language.PureScript.Errors.MultipleErrors)>_N
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                       <Language.PureScript.Errors.MultipleErrors>_N
                                       <Control.Monad.Logger.Logger
                                          Language.PureScript.Errors.MultipleErrors>_R
                                       <a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                           <*>_N
                                                           <Language.PureScript.Options.Options>_R
                                                           <Control.Monad.Trans.Except.ExceptT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Logger.Logger
                                                                 Language.PureScript.Errors.MultipleErrors)>_R
                                                           <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
b393f567d090ec302afa00ea3c7b4419
  $fMonadWriterMake1 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      (a,
       Language.PureScript.Errors.MultipleErrors
       -> Language.PureScript.Errors.MultipleErrors)
    -> Language.PureScript.Options.Options
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors
         (Data.Either.Either Language.PureScript.Errors.MultipleErrors a)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             (a,
                              Language.PureScript.Errors.MultipleErrors
                              -> Language.PureScript.Errors.MultipleErrors))
                   (eta1 :: Language.PureScript.Options.Options) ->
                 Control.Monad.Writer.Class.$fMonadWriterwExceptT1
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
                   @ a
                   (eta
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <Language.PureScript.Options.Options>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <(a,
                           Language.PureScript.Errors.MultipleErrors
                           -> Language.PureScript.Errors.MultipleErrors)>_N)
                      eta1)) -}
45f3701299362e7f08d2d13fa7d5b2d3
  $fMonadWriterMake2 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         (a, Language.PureScript.Errors.MultipleErrors)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             a)
                   (eta1 :: Language.PureScript.Options.Options) ->
                 Control.Monad.Writer.Class.$fMonadWriterwExceptT_$clisten
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
                   @ a
                   (eta
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <Language.PureScript.Options.Options>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a>_N)
                      eta1)) -}
d7f4fddb5fdab111dd257bc4f00384bc
  $fMonadWriterMake3 ::
    Language.PureScript.Errors.MultipleErrors
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors () #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,A><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                   (ds :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case eta1
                        `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        r#
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.augment
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                (\ @ b
                                   (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                         -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   @ b
                                   c
                                   n
                                   a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                eta
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ ()
                      GHC.Tuple.() #) } } }) -}
0c599ac6977e5810a47f060553957872
  $fMonadWriterMake4 ::
    (a, Language.PureScript.Errors.MultipleErrors)
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U,U)><L,A><S(S),1*U(U)><S,U>, Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: (a, Language.PureScript.Errors.MultipleErrors))
                   (w1 :: Language.PureScript.Options.Options)
                   (w2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2
                        `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of ww { GHC.STRef.STRef ww1 ->
                 Language.PureScript.Make.Monad.$w$cwriter @ a w ww1 w3 }) -}
7e478d80f55071876002b4081094c8e9
  $fMonadWriterMake_$s$fMonadWriterwLogger ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                  (Control.Monad.Logger.$fMonadWriterwLogger4
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ (w1 :: Language.PureScript.Errors.MultipleErrors)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case r `cast`
                        (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                   case GHC.Prim.atomicModifyMutVar#
                          @ GHC.Prim.RealWorld
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (Language.PureScript.Errors.MultipleErrors, ())
                          @ ()
                          r#
                          (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                           case GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b -> b)[OneShot]
                                     (n :: b)[OneShot] ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b
                                     c
                                     n
                                     a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                  w1
                                    `cast`
                                  (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                           (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                            GHC.Tuple.()) })
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of b1 { () -> (# ipv, GHC.Tuple.() #) } } })
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <()>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                           <Language.PureScript.Errors.MultipleErrors>_R
                                                           <()>_R))
                  (Control.Monad.Logger.$fMonadWriterwLogger2
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <(a,
                                         Language.PureScript.Errors.MultipleErrors)>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                    <(a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R))
                  (Control.Monad.Logger.$fMonadWriterwLogger1
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors
                      (a,
                       Language.PureScript.Errors.MultipleErrors
                       -> Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R)) -}
56202f1bc4eb493c6d4aff17b300e795
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
      (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w1 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            (a -> b))
                   (w2 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            a)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (w1
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <e>_N
                            <Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors>_R
                            <a -> b>_N ; Control.Monad.Logger.N:Logger[0]
                                             <Language.PureScript.Errors.MultipleErrors>_R
                                             <Data.Either.Either e (a -> b)>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Either.Either e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case (w2
                              `cast`
                            (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N
                                 <Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors>_R
                                 <a>_N ; Control.Monad.Logger.N:Logger[0]
                                             <Language.PureScript.Errors.MultipleErrors>_R
                                             <Data.Either.Either e a>_R)
                              r)
                             `cast`
                           (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
2e77dc0907e01d76a662e5ec6cf3e506
  $s$fApplicativeLogger1 ::
    (a -> b -> c)
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors a
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><C(C(S(SL))),1*C1(C1(U(U,U)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (f1 :: a -> b -> c)
                   (x :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a)
                   (eta :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors b)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (x `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         eta1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds { (#,#) ipv ipv1 ->
                 case (eta
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                         eta1)
                        `cast`
                      (GHC.Types.N:IO[0] <b>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, f1 ipv1 ipv3 #) } }) -}
7df9867d462a73e40f756cd0d925ef89
  $s$fApplicativeLogger2 ::
    Control.Monad.Logger.Logger
      Language.PureScript.Errors.MultipleErrors (a -> b)
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors a
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors (a -> b))
                   (m2 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors a)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a -> b>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case (m2
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } }) -}
42f02732453c12223150b0e5379d9bf5
  $s$fMonadWriterwLogger3 ::
    Language.PureScript.Errors.MultipleErrors
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (w1 :: Language.PureScript.Errors.MultipleErrors)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case r `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        r#
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.augment
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                (\ @ b
                                   (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                         -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   @ b
                                   c
                                   n
                                   a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                w1
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () -> (# ipv, GHC.Tuple.() #) } } }) -}
8a1f752fc2daedb9dcc20430e2a31e8d
  $tc'Make :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15200028788335488738##
                   13641983198174119053##
                   Language.PureScript.Make.Monad.$trModule
                   Language.PureScript.Make.Monad.$tc'Make2
                   1#
                   Language.PureScript.Make.Monad.$tc'Make1) -}
1c2fd48e32f1a3596600a36ab9343201
  $tc'Make1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e8adfe83c4fe065c0fdbefdcc793568
  $tc'Make2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$tc'Make3) -}
d0072626e60404b148d9123bb623d615
  $tc'Make3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Make"#) -}
28f483f8fdb32e32ee556069a67f0513
  $tcMake :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2355018467753470627##
                   17003995873524656694##
                   Language.PureScript.Make.Monad.$trModule
                   Language.PureScript.Make.Monad.$tcMake1
                   0#
                   GHC.Types.krep$*Arr*) -}
001668cfed2a928fecdce83a6ff6d87d
  $tcMake1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$tcMake2) -}
98f3bc1c58ce2ba17158500b79acf540
  $tcMake2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Make"#) -}
e766f9c1cbfe7e3be250ce9b1c15049b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Make.Monad.$trModule3
                   Language.PureScript.Make.Monad.$trModule1) -}
265747d5508e361fbbaf1857650898d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$trModule2) -}
6134e4c7fd4ce7cb85be7ead04841838
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.PureScript.Make.Monad"#) -}
fb3ec6edc3e3df8d18a1acc6aa94b4c6
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$trModule4) -}
d09a3304f8dce84a7d832d2ddf61acf2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
6ae7da7fcd2e22fae3a56315a40fa26c
  $w$cwriter ::
    (a, Language.PureScript.Errors.MultipleErrors)
    -> GHC.Prim.MutVar#
         GHC.Prim.RealWorld Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(1*U,1*U)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: (a, Language.PureScript.Errors.MultipleErrors))
                   (ww :: GHC.Prim.MutVar#
                            GHC.Prim.RealWorld Language.PureScript.Errors.MultipleErrors)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   w4 :: Language.PureScript.Errors.MultipleErrors
                   = case w of wild { (,) a1 w5 -> w5 }
                 } in
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        ww
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.++
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0])
                                w4
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      (case w of wild { (,) a1 w5 -> a1 }) #) } }) -}
c312defee06543f207653c194060a49b
  $wreadTextFile ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Data.ByteString.Lazy.Internal.ByteString #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.IO.FilePath)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ (Data.Either.Either
                             GHC.IO.Exception.IOError Data.ByteString.Lazy.Internal.ByteString)
                        @ GHC.Exception.SomeException
                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.IO.Handle.FD.openBinaryFile1
                                w
                                GHC.IO.IOMode.ReadMode
                                s of ds1 { (#,#) ipv ipv1 ->
                         case Data.ByteString.Lazy.getContents2
                                ipv1
                                ipv of ds2 { (#,#) ipv2 ipv3 ->
                         (# ipv2,
                            Data.Either.Right
                              @ GHC.IO.Exception.IOError
                              @ Data.ByteString.Lazy.Internal.ByteString
                              ipv3 #) } })
                        (System.IO.Error.tryIOError2
                           @ Data.ByteString.Lazy.Internal.ByteString)
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left x
                   -> (# ipv,
                         Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ Data.ByteString.Lazy.Internal.ByteString
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessage
                              (Language.PureScript.AST.Declarations.ErrorMessage
                                 (GHC.Types.[]
                                    @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                 (Language.PureScript.AST.Declarations.CannotReadFile w))
                              (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                             `cast`
                           (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) #)
                   Data.Either.Right y
                   -> (# ipv,
                         Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ Data.ByteString.Lazy.Internal.ByteString
                           y #) } }) -}
2384e2052993ac0b8b29c8eccd939cb5
  axiom Language.PureScript.Make.Monad.D:R:StMMakea::
      Control.Monad.Trans.Control.StM
        Language.PureScript.Make.Monad.Make a
        = Data.Either.Either Language.PureScript.Errors.MultipleErrors a
2384e2052993ac0b8b29c8eccd939cb5
  type role Make nominal
  newtype Make a
    = Make {unMake :: Control.Monad.Trans.Reader.ReaderT
                        Language.PureScript.Options.Options
                        (Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors))
                        a}
57242a678839a970dd53909b7207d2e8
  makeIO ::
    (GHC.IO.Exception.IOError
     -> Language.PureScript.AST.Declarations.ErrorMessage)
    -> GHC.Types.IO a -> Language.PureScript.Make.Monad.Make a
  {- Arity: 5,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.makeIO1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.IO.Exception.IOError
                  -> Language.PureScript.AST.Declarations.ErrorMessage>_R
                 ->_R <GHC.Types.IO a>_R
                 ->_R (<Language.PureScript.Options.Options>_R
                       ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                             ->_R Sym (GHC.Types.N:IO[0]
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors
                                              a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                 <Language.PureScript.Errors.MultipleErrors>_R
                                                                 <Data.Either.Either
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                     <Control.Monad.Logger.Logger
                                                                                        Language.PureScript.Errors.MultipleErrors>_R
                                                                                     <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                          <*>_N
                                                                                                          <Language.PureScript.Options.Options>_R
                                                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                             (Control.Monad.Logger.Logger
                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                          <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
0d7e5c6df4a6c8a39b24f0829493772e
  makeIO1 ::
    (GHC.IO.Exception.IOError
     -> Language.PureScript.AST.Declarations.ErrorMessage)
    -> GHC.Types.IO a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 5,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   (f :: GHC.IO.Exception.IOError
                         -> Language.PureScript.AST.Declarations.ErrorMessage)
                   (io :: GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ (Data.Either.Either GHC.IO.Exception.IOError a)
                        @ GHC.Exception.SomeException
                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case io `cast` (GHC.Types.N:IO[0] <a>_R)
                                s of ds1 { (#,#) ipv ipv1 ->
                         (# ipv, Data.Either.Right @ GHC.IO.Exception.IOError @ a ipv1 #) })
                        (System.IO.Error.tryIOError2 @ a)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left x
                   -> (# ipv,
                         Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ a
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessage
                              (f x)
                              (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                             `cast`
                           (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) #)
                   Data.Either.Right y
                   -> (# ipv,
                         Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ a
                           y #) } }) -}
831c92e7074ddb1aeca50e6c8d41a6bc
  readTextFile ::
    GHC.IO.FilePath
    -> Language.PureScript.Make.Monad.Make
         Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 4, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.readTextFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R (<Language.PureScript.Options.Options>_R
                       ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                             ->_R Sym (GHC.Types.N:IO[0]
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors
                                              Data.ByteString.Lazy.Internal.ByteString>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           Data.ByteString.Lazy.Internal.ByteString>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Logger.Logger
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors>_R
                                                                                                                                                                   <Data.ByteString.Lazy.Internal.ByteString>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                                                                               <*>_N
                                                                                                                                                                                                                               <Language.PureScript.Options.Options>_R
                                                                                                                                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                               <Data.ByteString.Lazy.Internal.ByteString>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <Data.ByteString.Lazy.Internal.ByteString>_N)) -}
cb255b4b2a6e6538fbd05577f2393b53
  readTextFile1 ::
    GHC.IO.FilePath
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Data.ByteString.Lazy.Internal.ByteString #)
  {- Arity: 4, Strictness: <L,U><L,A><L,A><S,U>, Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ (w :: GHC.IO.FilePath)
                   (w1 :: Language.PureScript.Options.Options)
                   (w2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Language.PureScript.Make.Monad.$wreadTextFile w w3) -}
ab2867f8bdf000c620b889012835e285
  runMake ::
    Language.PureScript.Options.Options
    -> Language.PureScript.Make.Monad.Make a
    -> GHC.Types.IO
         (Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
          Language.PureScript.Errors.MultipleErrors)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SL)))),1*C1(C1(C1(U(U,U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.runMake1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Options.Options>_R
                 ->_R <Language.PureScript.Make.Monad.Make a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <(Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
                                 Language.PureScript.Errors.MultipleErrors)>_R)) -}
1476c56b9114097f5bb204db9d80b7a2
  runMake1 ::
    Language.PureScript.Options.Options
    -> Language.PureScript.Make.Monad.Make a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
           Language.PureScript.Errors.MultipleErrors) #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SL)))),1*C1(C1(C1(U(U,U))))><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (opts :: Language.PureScript.Options.Options)
                   (eta :: Language.PureScript.Make.Monad.Make a)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.newMutVar#
                        @ Language.PureScript.Errors.MultipleErrors
                        @ GHC.Prim.RealWorld
                        (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                          `cast`
                        (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                        eta1 of ds { (#,#) ipv ipv1 ->
                 case ((eta
                          `cast`
                        (Language.PureScript.Make.Monad.N:Make[0] <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                              <*>_N
                                                                              <Language.PureScript.Options.Options>_R
                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Logger.Logger
                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                              <a>_N)
                          opts)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors>_R
                            <a>_N ; Control.Monad.Logger.N:Logger[0]
                                        <Language.PureScript.Errors.MultipleErrors>_R
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors a>_R)
                         (GHC.STRef.STRef
                            @ GHC.Prim.RealWorld
                            @ Language.PureScript.Errors.MultipleErrors
                            ipv1)
                           `cast`
                         (Sym (GHC.IORef.N:IORef[0]) <Language.PureScript.Errors.MultipleErrors>_N))
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 case GHC.Prim.readMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        ipv1
                        ipv2 of ds2 { (#,#) ipv4 ipv5 ->
                 (# ipv4, (ipv3, ipv5) #) } } }) -}
2384e2052993ac0b8b29c8eccd939cb5
  unMake ::
    Language.PureScript.Make.Monad.Make a
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  RecSel Left Language.PureScript.Make.Monad.Make
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.unMake1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Make.Monad.Make a>_R
                 ->_R Language.PureScript.Make.Monad.N:Make[0] <a>_N) -}
2384e2052993ac0b8b29c8eccd939cb5
  unMake1 ::
    Language.PureScript.Make.Monad.Make a
    -> Language.PureScript.Make.Monad.Make a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Language.PureScript.Make.Monad.Make a) -> ds) -}
instance GHC.Base.Applicative [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fApplicativeMake
instance GHC.Base.Functor [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fFunctorMake
instance Control.Monad.Trans.Control.MonadBaseControl [GHC.Types.IO,
                                                       Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadBaseControlIOMake
instance Control.Monad.Base.MonadBase [GHC.Types.IO,
                                       Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadBaseIOMake
instance Control.Monad.Error.Class.MonadError [Language.PureScript.Errors.MultipleErrors,
                                               Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadErrorMake
instance Control.Monad.IO.Class.MonadIO [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadIOMake
instance GHC.Base.Monad [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadMake
instance Control.Monad.Reader.Class.MonadReader [Language.PureScript.Options.Options,
                                                 Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadReaderMake
instance Control.Monad.Writer.Class.MonadWriter [Language.PureScript.Errors.MultipleErrors,
                                                 Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadWriterMake
family instance Control.Monad.Trans.Control.StM [Language.PureScript.Make.Monad.Make],
                                                [.]
  = Language.PureScript.Make.Monad.D:R:StMMakea
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                                   Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger @ Language.PureScript.Errors.MultipleErrors
                                           v
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeLogger
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger1 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                           Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger1 @ Language.PureScript.Errors.MultipleErrors
                                            $dMonoid
  = Language.PureScript.Make.Monad.$s$fApplicativeLogger1
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger2 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                           Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger2 @ Language.PureScript.Errors.MultipleErrors
                                            $dMonoid
  = Language.PureScript.Make.Monad.$s$fApplicativeLogger2
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c*> @ (ExceptT
                                                                   MultipleErrors
                                                                   (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                           ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*> @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Logger.Logger
                                                               Language.PureScript.Errors.MultipleErrors))
                                                       @ r
                                                       $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
      @ r
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c<* @ (ExceptT
                                                                   MultipleErrors
                                                                   (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                           ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<* @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Logger.Logger
                                                               Language.PureScript.Errors.MultipleErrors))
                                                       @ r
                                                       $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*
      @ r
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c<*> @ (ExceptT
                                                                    MultipleErrors
                                                                    (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                              ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                     (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Logger.Logger
                                                                Language.PureScript.Errors.MultipleErrors))
                                                        @ r
                                                        $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/Language.PureScript.Make.Monad $fFunctorExceptT_$cfmap @ (Logger
                                                                 MultipleErrors) _" [orphan] forall @ e
                                                                                                                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                           (Control.Monad.Logger.Logger
                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors))
  Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap @ (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors)
                                                     @ e
                                                     $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorExceptT_$cfmap
      @ e
"SPEC/Language.PureScript.Make.Monad $fFunctorReaderT_$c<$ @ (ExceptT
                                                               MultipleErrors
                                                               (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        (Control.Monad.Logger.Logger
                                                           Language.PureScript.Errors.MultipleErrors))
                                                   @ r
                                                   $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$c<$
      @ r
"SPEC/Language.PureScript.Make.Monad $fFunctorReaderT_$cfmap @ (ExceptT
                                                                 MultipleErrors
                                                                 (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                        (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                          Language.PureScript.Errors.MultipleErrors
                                                          (Control.Monad.Logger.Logger
                                                             Language.PureScript.Errors.MultipleErrors))
                                                     @ r
                                                     $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$cfmap
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                             Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadLogger @ Language.PureScript.Errors.MultipleErrors
                                     v
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
"SPEC/Language.PureScript.Make.Monad $fMonadLogger_$c>> @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                         Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadLogger_$c>> @ Language.PureScript.Errors.MultipleErrors
                                          $dMonoid
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger_$c>>
"SPEC/Language.PureScript.Make.Monad $fMonadReaderT_$c>>= @ (ExceptT
                                                              MultipleErrors
                                                              (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                             (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors))
                                                  @ r
                                                  $dMonad
  = Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$c>>=
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadReaderT_$cfail @ (ExceptT
                                                               MultipleErrors
                                                               (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                               ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        (Control.Monad.Logger.Logger
                                                           Language.PureScript.Errors.MultipleErrors))
                                                   @ r
                                                   $dMonad
  = Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$cfail
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadWriterwLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                                    Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadWriterwLogger @ Language.PureScript.Errors.MultipleErrors
                                            v
  = Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
"SPEC/Language.PureScript.Make.Monad $fMonadWriterwLogger3 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                            Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadWriterwLogger3 @ Language.PureScript.Errors.MultipleErrors
                                             $dMonoid
  = Language.PureScript.Make.Monad.$s$fMonadWriterwLogger3
"SPEC/Language.PureScript.Make.Monad reader @ (ExceptT
                                                MultipleErrors (Logger MultipleErrors)) _ _" [orphan] forall @ r
                                                                                                                                                                    @ a
                                                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                     (Control.Monad.Logger.Logger
                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.reader @ (Control.Monad.Trans.Except.ExceptT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Logger.Logger
                                            Language.PureScript.Errors.MultipleErrors))
                                    @ r
                                    @ a
                                    $dMonad
  = Language.PureScript.Make.Monad.$fMonadReaderMake_$sreader @ r @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

