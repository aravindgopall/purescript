
==================== FINAL INTERFACE ====================
2018-11-30 20:47:46.977137 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Make.Monad [family instance module] 8043
  interface hash: 08824b3bd454e7c42da2d611fc4b82d0
  ABI hash: 0cf50a6714897adf0be9853da80fce0b
  export-list hash: 8d0a2d6b070f225b4a8d6fee61814383
  orphan hash: 2205edfbf9e2d88819cd9edbe6721838
  flag hash: 964ca6959d8816591051842cb80443f3
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.Make.Monad.makeIO
  Language.PureScript.Make.Monad.readTextFile
  Language.PureScript.Make.Monad.runMake
  Language.PureScript.Make.Monad.Make{Language.PureScript.Make.Monad.Make unMake}
module dependencies: Control.Monad.Logger Control.Monad.Supply
                     Control.Monad.Supply.Class Language.PureScript.AST
                     Language.PureScript.AST.Binders
                     Language.PureScript.AST.Declarations
                     Language.PureScript.AST.Exported Language.PureScript.AST.Literals
                     Language.PureScript.AST.Operators Language.PureScript.AST.SourcePos
                     Language.PureScript.AST.Traversals Language.PureScript.Bundle
                     Language.PureScript.Comments Language.PureScript.Constants
                     Language.PureScript.Crash Language.PureScript.Environment
                     Language.PureScript.Errors Language.PureScript.Kinds
                     Language.PureScript.Label Language.PureScript.Names
                     Language.PureScript.Options Language.PureScript.PSString
                     Language.PureScript.Parser.Lexer Language.PureScript.Parser.State
                     Language.PureScript.Pretty Language.PureScript.Pretty.Common
                     Language.PureScript.Pretty.Kinds Language.PureScript.Pretty.Types
                     Language.PureScript.Pretty.Values
                     Language.PureScript.Publish.BoxesHelpers
                     Language.PureScript.Traversals
                     Language.PureScript.TypeClassDictionaries Language.PureScript.Types
                     Paths_purescript
package dependencies: aeson-1.3.1.1 aeson-better-errors-0.9.1.0
                      ansi-terminal-0.8.0.4 array-0.5.2.0 async-2.2.1 attoparsec-0.13.2.2
                      base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      blaze-builder-0.4.1.0 boxes-0.1.5 bytestring-0.10.8.2 colour-2.3.4
                      containers-0.5.11.0 deepseq-1.4.3.0 dlist-0.8.0.4 filepath-1.4.2
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      language-javascript-0.6.0.11 monad-control-1.0.2.3 mtl-2.2.2
                      parsec-3.1.13.0 pattern-arrows-0.0.2 pretty-1.1.3.6
                      primitive-0.6.3.0 protolude-0.2.2 random-1.1 scientific-0.3.6.2
                      sourcemap-0.1.6 split-0.2.3.3 stm-2.4.5.0 syb-0.7 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 th-abstraction-0.2.8.0
                      time-1.8.0.2 time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      transformers-base-0.4.5.2 unordered-containers-0.2.9.0
                      utf8-string-1.0.1.1 uuid-types-1.0.3 vector-0.12.0.1
orphans: syb-0.7:Data.Generics.Instances
         stm-2.4.5.0:Control.Monad.STM
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic
         vector-0.12.0.1:Data.Vector.Fusion.Bundle colour-2.3.4:Data.Colour
         text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Graph
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Control.Monad.Logger
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Declarations
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Operators
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.SourcePos
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Environment
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Kinds
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Label
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Names
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.TypeClassDictionaries
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.Types
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.8.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Monad.IO.Class 96109c36cb3c919872278540487fa39e
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.IO.Exception acc060dca2e46d8b8275d06ee7d5d60d
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO.Error e9cae3ab377d64b36ad020e6acace3fb
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy b6cb59a78204810b2a79502bf5b4c1fc
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Internal af245ead1f52eca50149d040b0b86693
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  monad-control-1.0.2.3:Control.Monad.Trans.Control 82c27f877a1c7cc212232dcea6f7b8e9
import  -/  mtl-2.2.2:Control.Monad.Error.Class df146c18e27154b8df4c8637c59fd61b
import  -/  mtl-2.2.2:Control.Monad.Reader a496a2f5c2c54feee0ad154b4fe8533d
import  -/  mtl-2.2.2:Control.Monad.Reader.Class a5ac59953d953ab8532b5c11f5e8e0b0
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 69f540e019eada69892c26d267276458
import  -/  Control.Monad.Logger 6a73d687216af879d8ea091fe68fc2d0
  exports: e8f8f1773f117be4556dc4826c5d72b7
  Logger 1f34a77b548e00109c402b46b25d90ee
  runLogger' dd008480b5d4475b1df61b0e46f5eb13
import  -/  Language.PureScript.AST 7ed0e74bfed5b6489b8a5eabab5c0241
  exports: 0d53d92339536cd6d8d7dcfcad8e7c7e
import  -/  Language.PureScript.AST.Declarations 568e046fbf27b243bfc96f09017d4782
  CannotReadFile bf83034dadcb55abb40fc0b3ef02c899
  ErrorMessage bc889ae8d74a01dbbd95e220faa4631d
  ErrorMessage cebd18718f7c34278cac50a2f0ab0386
import  -/  Language.PureScript.Errors 15d6eb6b2d4d480750061a0585d4e64c
  exports: 142ea650dec62642d1cff09ef1eee74e
  MultipleErrors ad1de73a1d5a6b0ccd9657dedebc94f3
  singleError 8cdec4403bbf7ee5542ebca436a64fe1
import  -/  Language.PureScript.Options 41178707a96359e93f10aa9345b25f64
  exports: 0c988ddc260707f6c03a83826c104ef5
  Options 3d4c612f0e93f04d7e7834ac0f92767f
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Except 1cac4acbba7f36bd732fcc993d3cc20d
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 42962052353a5a0f766912058b765b5d
import  -/  transformers-base-0.4.5.2:Control.Monad.Base 0525bddaf47f5bace6a58bd35649c995
3e3b14b08c410e5ba3c590f1d3af7206
  $fApplicativeMake ::
    GHC.Base.Applicative Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fFunctorMake
                  Language.PureScript.Make.Monad.$fApplicativeMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a -> b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (\ @ a @ b @ c ->
                   Language.PureScript.Make.Monad.$fApplicativeMake1 @ c @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <c>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <c>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
71f45a92b1f18e4ac0098345aa4ccf65
  $fApplicativeMake1 ::
    (a -> b -> c)
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Unfolding: (\ @ c
                   @ b
                   @ a
                   (eta :: a -> b -> c)
                   (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Options.Options
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              a)
                   (eta2 :: Control.Monad.Trans.Reader.ReaderT
                              Language.PureScript.Options.Options
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (eta3 :: Language.PureScript.Options.Options) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       eta3
                 } in
                 let {
                   w2 :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           b
                   = eta2
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <b>_N)
                       eta3
                 } in
                 (\ (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left x
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ c
                            x #)
                    Data.Either.Right y
                    -> case (w2
                               `cast`
                             (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <Language.PureScript.Errors.MultipleErrors>_N
                                  <Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors>_R
                                  <b>_N ; Control.Monad.Logger.N:Logger[0]
                                              <Language.PureScript.Errors.MultipleErrors>_R
                                              <Data.Either.Either
                                                 Language.PureScript.Errors.MultipleErrors b>_R)
                               r)
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                              ipv of ds2 { (#,#) ipv2 ipv3 ->
                       case ipv3 of wild1 {
                         Data.Either.Left e1
                         -> (# ipv2,
                               Data.Either.Left
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ c
                                 e1 #)
                         Data.Either.Right x
                         -> (# ipv2,
                               Data.Either.Right
                                 @ Language.PureScript.Errors.MultipleErrors
                                 @ c
                                 (eta y x) #) } } } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    c>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          c>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <c>_N)))) -}
94c8ac23dac348b34dcb27a5feaf8149
  $fApplicativeMake2 ::
    a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (x :: a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      x #)) -}
c5e3f3fa11b4ec9fc3a3d16c15a81646
  $fApplicativeMake_$s$fApplicativeLogger ::
    GHC.Base.Applicative
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  (Control.Monad.Logger.$fFunctorLogger
                     @ Language.PureScript.Errors.MultipleErrors)
                  (\ @ a
                     (x :: a)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# eta1, x #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ @ a
                     @ b
                     (m1 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors (a -> b))
                     (m2 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (m1
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a -> b>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a -> b>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   case (m2
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          ipv of ds2 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors (a -> b)>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  (\ @ a
                     @ b
                     @ c
                     (f1 :: a -> b -> c)
                     (x :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors a)
                     (eta :: Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors b)
                     (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (x `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta2 of ds { (#,#) ipv ipv1 ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, f1 ipv1 ipv3 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <c>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <c>_R))
                  (\ @ a
                     @ b
                     (a1 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (a2 :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors b)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (a1
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta1 of ds { (#,#) ipv ipv1 ->
                   (a2
                      `cast`
                    (Control.Monad.Logger.N:Logger[0]
                         <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                      eta)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors a)
                     (eta :: Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors b)
                     (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (x `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          eta2 of ds { (#,#) ipv ipv1 ->
                   case (eta
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <b>_R)
                          ipv of ds1 { (#,#) ipv2 ipv3 ->
                   (# ipv2, ipv1 #) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R)) -}
30468a00bf2a6ea2bf680101bfa4f6d9
  $fApplicativeMake_$s$fApplicativeReaderT_$c*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (r1 :: r) ->
                 let {
                   m1 :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = u `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 let {
                   k :: Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)
                          b
                   = v `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <b>_N)
                       r1
                 } in
                 (\ (r2 :: GHC.IORef.IORef
                             Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ b
                            e1 #)
                    Data.Either.Right x
                    -> (k `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <b>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors b>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                         ipv } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <b>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
cade69f5fb7f2bbde000a2869cf3f3c5
  $fApplicativeMake_$s$fApplicativeReaderT_$c<* ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b)
                   (r1 :: r) ->
                 let {
                   x :: Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)
                          a
                   = u `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Logger.$fFunctorLogger
                      @ Language.PureScript.Errors.MultipleErrors)
                   Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                   @ b
                   @ a
                   (\ (r2 :: GHC.IORef.IORef
                               Language.PureScript.Errors.MultipleErrors)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case (x `cast`
                          (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               <a>_N ; Control.Monad.Logger.N:Logger[0]
                                           <Language.PureScript.Errors.MultipleErrors>_R
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors a>_R)
                            r2)
                           `cast`
                         (GHC.Types.N:IO[0]
                              <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                           s of ds1 { (#,#) ipv ipv1 ->
                    (# ipv,
                       Control.Monad.Trans.Except.$fApplicativeExceptT1
                         @ a
                         @ b
                         @ Language.PureScript.Errors.MultipleErrors
                         ipv1 #) })
                     `cast`
                   ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <Data.Either.Either
                                      Language.PureScript.Errors.MultipleErrors
                                      (b -> a)>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                <Language.PureScript.Errors.MultipleErrors>_R
                                                                <Data.Either.Either
                                                                   Language.PureScript.Errors.MultipleErrors
                                                                   (b
                                                                    -> a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                                                         <Control.Monad.Logger.Logger
                                                                                            Language.PureScript.Errors.MultipleErrors>_R
                                                                                         <b
                                                                                          -> a>_N)))
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <b>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <a>_N)) -}
08a3f06a2014e895e51bac8c716cfb73
  $fApplicativeMake_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           a)
                   (r1 :: r) ->
                 Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   (Control.Monad.Logger.$fFunctorLogger
                      @ Language.PureScript.Errors.MultipleErrors)
                   Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                   @ a
                   @ b
                   (f `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a -> b>_N)
                      r1)
                   (v `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <r>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a>_N)
                      r1))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors))
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
0c45cd45cd4d030b85defebb4321d06f
  $fApplicativeMake_$s$fMonadLogger ::
    GHC.Base.Monad
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeLogger
                  (\ @ a
                     @ b
                     (ds :: Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors a)
                     (f :: a
                           -> Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors b)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Logger.N:Logger[0]
                              <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                           r)
                          `cast`
                        (GHC.Types.N:IO[0] <a>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   ((f ipv1)
                      `cast`
                    (Control.Monad.Logger.N:Logger[0]
                         <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                      r)
                     `cast`
                   (GHC.Types.N:IO[0] <b>_R)
                     ipv })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R <a
                         -> Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors b>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <b>_R))
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger_$c>>
                  (\ @ a
                     (x :: a)
                     (eta :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# eta1, x #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors a)) -}
50e277c9fb12f7656aef7fd01a5491c9
  $fApplicativeMake_$s$fMonadLogger_$c>> ::
    Control.Monad.Logger.Logger
      Language.PureScript.Errors.MultipleErrors a
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors a)
                   (k :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors b)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (k `cast`
                  (Control.Monad.Logger.N:Logger[0]
                       <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                    r)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Logger.Logger
                    Language.PureScript.Errors.MultipleErrors a>_R
                 ->_R <Control.Monad.Logger.Logger
                         Language.PureScript.Errors.MultipleErrors b>_R
                 ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        <b>_R)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fFunctorMake ::
    GHC.Base.Functor Language.PureScript.Make.Monad.Make
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$cfmap
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$c<$
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
c6649cd0eeebbef8e82f52a2b5499b43
  $fFunctorMake_$s$fFunctorExceptT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors (Data.Either.Either e a))
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (ds
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R
                            <Data.Either.Either e a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.$fApplicativeEither_$cfmap @ e @ a @ b f ipv1 #) })
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               <a>_N)
                 ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Either.Either
                                        e b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                             <Language.PureScript.Errors.MultipleErrors>_R
                                                             <Data.Either.Either
                                                                e
                                                                b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <e>_N
                                                                                 <Control.Monad.Logger.Logger
                                                                                    Language.PureScript.Errors.MultipleErrors>_R
                                                                                 <b>_N))) -}
7b6455680923c62d0a5045df7b36d40f
  $fFunctorMake_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (x :: a)
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors))
                           b) ->
                 let {
                   lvl18 :: Data.Either.Either
                              Language.PureScript.Errors.MultipleErrors a
                   = Data.Either.Right
                       @ Language.PureScript.Errors.MultipleErrors
                       @ a
                       x
                 } in
                 (\ (x1 :: r) ->
                  let {
                    ds :: Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            b
                    = v `cast`
                      (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <r>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <b>_N)
                        x1
                  } in
                  (\ (r1 :: GHC.IORef.IORef
                              Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (ds
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Language.PureScript.Errors.MultipleErrors>_N
                              <Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors>_R
                              <b>_N ; Control.Monad.Logger.N:Logger[0]
                                          <Language.PureScript.Errors.MultipleErrors>_R
                                          <Data.Either.Either
                                             Language.PureScript.Errors.MultipleErrors b>_R)
                           r1)
                          `cast`
                        (GHC.Types.N:IO[0]
                             <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                          s of ds1 { (#,#) ipv ipv1 ->
                   (# ipv,
                      case ipv1 of wild {
                        Data.Either.Left x2
                        -> Data.Either.Left
                             @ Language.PureScript.Errors.MultipleErrors
                             @ a
                             x2
                        Data.Either.Right y -> lvl18 } #) })
                    `cast`
                  ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Data.Either.Either
                                     Language.PureScript.Errors.MultipleErrors
                                     a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        <Data.Either.Either
                                                           Language.PureScript.Errors.MultipleErrors
                                                           a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                                            <Control.Monad.Logger.Logger
                                                                               Language.PureScript.Errors.MultipleErrors>_R
                                                                            <a>_N))))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <r>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Language.PureScript.Errors.MultipleErrors
                              (Control.Monad.Logger.Logger
                                 Language.PureScript.Errors.MultipleErrors)>_R
                           <a>_N))) -}
1c85189722d25976bb0a1a952ffa66cd
  $fFunctorMake_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><L,1*C1(C(C1(U(U,1*U))))><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        (Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors))
                   @ a
                   @ (Control.Monad.Trans.Except.ExceptT
                        Language.PureScript.Errors.MultipleErrors
                        (Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors))
                   @ b
                   @ r
                   (Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorExceptT_$cfmap
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      @ b
                      f)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadBaseControlIOMake ::
    Control.Monad.Trans.Control.MonadBaseControl
      GHC.Types.IO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake
                  Language.PureScript.Make.Monad.$fMonadBaseControlIOMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.Control.RunInBase
                      Language.PureScript.Make.Monad.Make GHC.Types.IO
                    -> GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadBaseControlIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sub (Sym (Language.PureScript.Make.Monad.D:R:StMMakea[0] <a>_N))
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             (Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                            <Language.PureScript.Errors.MultipleErrors>_N
                                                            <Control.Monad.Trans.Control.StT
                                                               (Control.Monad.Trans.Reader.ReaderT
                                                                  Language.PureScript.Options.Options)
                                                               a>_N))))) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                     <Language.PureScript.Errors.MultipleErrors>_R
                                                                                     <Data.Either.Either
                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                        (Control.Monad.Trans.Control.StT
                                                                                           (Control.Monad.Trans.Reader.ReaderT
                                                                                              Language.PureScript.Options.Options)
                                                                                           a)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                             <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                             <Control.Monad.Logger.Logger
                                                                                                                Language.PureScript.Errors.MultipleErrors>_R
                                                                                                             (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                                                                                                       <Language.PureScript.Options.Options>_N
                                                                                                                       <a>_N))))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                              <*>_N
                                                                                                                                              <Language.PureScript.Options.Options>_R
                                                                                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                                                                                 (Control.Monad.Logger.Logger
                                                                                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                              <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
9558af37da4590c32a4f0d5bfae69702
  $fMonadBaseControlIOMake1 ::
    Data.Either.Either Language.PureScript.Errors.MultipleErrors a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Control.Monad.Trans.Control.StT
            (Control.Monad.Trans.Except.ExceptT
               Language.PureScript.Errors.MultipleErrors)
            (Control.Monad.Trans.Control.StT
               (Control.Monad.Trans.Reader.ReaderT
                  Language.PureScript.Options.Options)
               a) #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (x :: Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    x `cast`
                    ((Data.Either.Either
                        <Language.PureScript.Errors.MultipleErrors>_R
                        (Sub (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                       <Language.PureScript.Options.Options>_N
                                       <a>_N))))_R ; Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                   <Control.Monad.Trans.Control.StT
                                                                      (Control.Monad.Trans.Reader.ReaderT
                                                                         Language.PureScript.Options.Options)
                                                                      a>_N))) #)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadBaseControlIOMake2 ::
    (Control.Monad.Trans.Control.RunInBase
       Language.PureScript.Make.Monad.Make GHC.Types.IO
     -> GHC.Types.IO a)
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (f :: Control.Monad.Trans.Control.RunInBase
                           Language.PureScript.Make.Monad.Make GHC.Types.IO
                         -> GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (f (\ @ a1
                            (x :: Control.Monad.Trans.Reader.ReaderT
                                    Language.PureScript.Options.Options
                                    (Control.Monad.Trans.Except.ExceptT
                                       Language.PureScript.Errors.MultipleErrors
                                       (Control.Monad.Logger.Logger
                                          Language.PureScript.Errors.MultipleErrors))
                                    a1) ->
                          (x `cast`
                           (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N
                                <Language.PureScript.Options.Options>_R
                                <Control.Monad.Trans.Except.ExceptT
                                   Language.PureScript.Errors.MultipleErrors
                                   (Control.Monad.Logger.Logger
                                      Language.PureScript.Errors.MultipleErrors)>_R
                                <a1>_N)
                             eta)
                            `cast`
                          (Control.Monad.Trans.Except.N:ExceptT[0]
                               <Language.PureScript.Errors.MultipleErrors>_N
                               <Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors>_R
                               (Sym (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                         <Language.PureScript.Options.Options>_N
                                         <a1>_N)) ; Control.Monad.Logger.N:Logger[0]
                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                        (Sub (Sym (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                       <Control.Monad.Trans.Control.StT
                                                                          (Control.Monad.Trans.Reader.ReaderT
                                                                             Language.PureScript.Options.Options)
                                                                          a1>_N))))
                            eta1)
                           `cast`
                         (forall (a1 :: <*>_N).
                          Sym (Language.PureScript.Make.Monad.N:Make[0]) <a1>_N
                          ->_R (GHC.Types.IO
                                  (Sub (Control.Monad.Trans.Control.D:R:StTExceptTa[0]
                                            <Language.PureScript.Errors.MultipleErrors>_N
                                            <Control.Monad.Trans.Control.StT
                                               (Control.Monad.Trans.Reader.ReaderT
                                                  Language.PureScript.Options.Options)
                                               a1>_N) ; ((Data.Either.Either
                                                            <Language.PureScript.Errors.MultipleErrors>_R
                                                            (Sub (Control.Monad.Trans.Control.D:R:StTReaderTa[0]
                                                                      <Language.PureScript.Options.Options>_N
                                                                      <a1>_N)))_R ; Sub (Sym (Language.PureScript.Make.Monad.D:R:StMMakea[0]
                                                                                                  <a1>_N)))))_R))
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      ipv1 #) }) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadBaseIOMake ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  @ Language.PureScript.Make.Monad.Make
                  GHC.Base.$fApplicativeIO
                  Language.PureScript.Make.Monad.$fApplicativeMake
                  GHC.Base.$fMonadIO
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
8bd7e09c2949aadf88d5360a5c01b262
  $fMonadBaseIOMake1 ::
    GHC.Types.IO a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(S(SL)),1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (x :: GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case x `cast` (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      ipv1 #) }) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadErrorMake ::
    Control.Monad.Error.Class.MonadError
      Language.PureScript.Errors.MultipleErrors
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadErrorMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadErrorMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R (<Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
da9d33b00ef0eba51f56114ac7744e3b
  $fMonadErrorMake1 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (Language.PureScript.Errors.MultipleErrors
        -> Control.Monad.Trans.Reader.ReaderT
             Language.PureScript.Options.Options
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Logger.Logger
                   Language.PureScript.Errors.MultipleErrors))
             a)
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,U))))><L,C(C1(C1(C1(U))))><L,U>,
     Unfolding: (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             a)
                   (eta1 :: Language.PureScript.Errors.MultipleErrors
                            -> Control.Monad.Trans.Reader.ReaderT
                                 Language.PureScript.Options.Options
                                 (Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors))
                                 a)
                   (eta2 :: Language.PureScript.Options.Options) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = eta
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <Language.PureScript.Options.Options>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       eta2
                 } in
                 (\ (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left l
                    -> (((eta1 l)
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <Language.PureScript.Options.Options>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <a>_N)
                           eta2)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         ipv
                    Data.Either.Right r1 -> ds1 } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <a>_N)))) -}
f32710b9dcad3e25301054df8d6786f5
  $fMonadErrorMake2 ::
    Language.PureScript.Errors.MultipleErrors
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (eta :: Language.PureScript.Errors.MultipleErrors)
                   (eta1 :: Language.PureScript.Options.Options)
                   (eta2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta3,
                    Data.Either.Left
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      eta #)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadIOMake ::
    Control.Monad.IO.Class.MonadIO Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadBaseIOMake1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadMake :: GHC.Base.Monad Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fApplicativeMake
                  (Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$c>>=
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  (Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <b>_N)
                  Language.PureScript.Make.Monad.$fApplicativeMake2
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  (Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$cfail
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
a68fb15402d866d14bb56c1bbca6aa2d
  $fMonadMake_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> (a
        -> Control.Monad.Trans.Reader.ReaderT
             r
             (Control.Monad.Trans.Except.ExceptT
                Language.PureScript.Errors.MultipleErrors
                (Control.Monad.Logger.Logger
                   Language.PureScript.Errors.MultipleErrors))
             b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(C1(U(U,1*U))))><L,C(C1(C1(C1(U))))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors))
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Reader.ReaderT
                              r
                              (Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors))
                              b)
                   (r1 :: r) ->
                 let {
                   ds :: Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors)
                           a
                   = m1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <r>_R
                          <Control.Monad.Trans.Except.ExceptT
                             Language.PureScript.Errors.MultipleErrors
                             (Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors)>_R
                          <a>_N)
                       r1
                 } in
                 (\ (r2 :: GHC.IORef.IORef
                             Language.PureScript.Errors.MultipleErrors)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case (ds
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <a>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors a>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                         s of ds1 { (#,#) ipv ipv1 ->
                  case ipv1 of wild {
                    Data.Either.Left e1
                    -> (# ipv,
                          Data.Either.Left
                            @ Language.PureScript.Errors.MultipleErrors
                            @ b
                            e1 #)
                    Data.Either.Right x
                    -> (((k x)
                           `cast`
                         (Control.Monad.Trans.Reader.N:ReaderT[0]
                              <*>_N
                              <r>_R
                              <Control.Monad.Trans.Except.ExceptT
                                 Language.PureScript.Errors.MultipleErrors
                                 (Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors)>_R
                              <b>_N)
                           r1)
                          `cast`
                        (Control.Monad.Trans.Except.N:ExceptT[0]
                             <Language.PureScript.Errors.MultipleErrors>_N
                             <Control.Monad.Logger.Logger
                                Language.PureScript.Errors.MultipleErrors>_R
                             <b>_N ; Control.Monad.Logger.N:Logger[0]
                                         <Language.PureScript.Errors.MultipleErrors>_R
                                         <Data.Either.Either
                                            Language.PureScript.Errors.MultipleErrors b>_R)
                          r2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either Language.PureScript.Errors.MultipleErrors b>_R)
                         ipv } })
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    b>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          b>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <b>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Reader.ReaderT
                    r
                    (Control.Monad.Trans.Except.ExceptT
                       Language.PureScript.Errors.MultipleErrors
                       (Control.Monad.Logger.Logger
                          Language.PureScript.Errors.MultipleErrors))
                    a>_R
                 ->_R <a
                       -> Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Language.PureScript.Errors.MultipleErrors
                               (Control.Monad.Logger.Logger
                                  Language.PureScript.Errors.MultipleErrors))
                            b>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <b>_N)) -}
8526e6100211b69685a4bdc549db7883
  $fMonadMake_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) ->
                 let {
                   m1 :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors
                           (Data.Either.Either Language.PureScript.Errors.MultipleErrors a)
                     {- Strictness: x -}
                   = GHC.Err.errorWithoutStackTrace
                       @ 'GHC.Types.LiftedRep
                       @ (Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors
                            (Data.Either.Either Language.PureScript.Errors.MultipleErrors a))
                       msg
                 } in
                 (\ (ds :: r) -> m1)
                   `cast`
                 ((<r>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <Language.PureScript.Errors.MultipleErrors>_N
                                 <Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors>_R
                                 <a>_N)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                    <*>_N
                                                    <r>_R
                                                    <Control.Monad.Trans.Except.ExceptT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors)>_R
                                                    <a>_N))) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadReaderMake ::
    Control.Monad.Reader.Class.MonadReader
      Language.PureScript.Options.Options
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Options.Options
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadReaderMake1
                    `cast`
                  ((<Language.PureScript.Options.Options>_R
                    ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors
                                           Language.PureScript.Options.Options>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                <Data.Either.Either
                                                                                                   Language.PureScript.Errors.MultipleErrors
                                                                                                   Language.PureScript.Options.Options>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                      <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                      <Control.Monad.Logger.Logger
                                                                                                                                                         Language.PureScript.Errors.MultipleErrors>_R
                                                                                                                                                      <Language.PureScript.Options.Options>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                                                             <*>_N
                                                                                                                                                                                                             <Language.PureScript.Options.Options>_R
                                                                                                                                                                                                             <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                (Control.Monad.Logger.Logger
                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                             <Language.PureScript.Options.Options>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <Language.PureScript.Options.Options>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ Language.PureScript.Options.Options
                     @ Language.PureScript.Options.Options
                     @ (Control.Monad.Trans.Except.ExceptT
                          Language.PureScript.Errors.MultipleErrors
                          (Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors)))
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Options.Options
                    -> Language.PureScript.Options.Options>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)
                  (Language.PureScript.Make.Monad.$fMonadReaderMake_$sreader
                     @ Language.PureScript.Options.Options)
                    `cast`
                  (forall (a :: <*>_N).
                   <Language.PureScript.Options.Options -> a>_R
                   ->_R Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N) -}
060ba2da3304829499ae9d0127a31ce3
  $fMonadReaderMake1 ::
    Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Language.PureScript.Options.Options #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# eta2,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ Language.PureScript.Options.Options
                      eta #)) -}
3c9cf0a4e7989a4934b094b7b775c022
  $fMonadReaderMake_$sreader ::
    (r -> a)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (f :: r -> a) (x :: r) ->
                 let {
                   eta :: a = f x
                 } in
                 let {
                   x1 :: Data.Either.Either
                           Language.PureScript.Errors.MultipleErrors a
                   = Data.Either.Right
                       @ Language.PureScript.Errors.MultipleErrors
                       @ a
                       eta
                 } in
                 (\ (eta1 :: GHC.IORef.IORef
                               Language.PureScript.Errors.MultipleErrors)
                    (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta2, x1 #))
                   `cast`
                 ((<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Data.Either.Either
                                    Language.PureScript.Errors.MultipleErrors
                                    a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                       <Language.PureScript.Errors.MultipleErrors>_R
                                                       <Data.Either.Either
                                                          Language.PureScript.Errors.MultipleErrors
                                                          a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Language.PureScript.Errors.MultipleErrors>_N
                                                                           <Control.Monad.Logger.Logger
                                                                              Language.PureScript.Errors.MultipleErrors>_R
                                                                           <a>_N))))
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N).
                 <r -> a>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Language.PureScript.Errors.MultipleErrors
                                  (Control.Monad.Logger.Logger
                                     Language.PureScript.Errors.MultipleErrors)>_R
                               <a>_N)) -}
3e3b14b08c410e5ba3c590f1d3af7206
  $fMonadWriterMake ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      Language.PureScript.Make.Monad.Make
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ Language.PureScript.Make.Monad.Make
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.Make.Monad.$fMonadMake
                  Language.PureScript.Make.Monad.$fMonadWriterMake4
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                   <Language.PureScript.Errors.MultipleErrors>_R
                                                                   <Data.Either.Either
                                                                      Language.PureScript.Errors.MultipleErrors
                                                                      a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                       <Language.PureScript.Errors.MultipleErrors>_N
                                                                                       <Control.Monad.Logger.Logger
                                                                                          Language.PureScript.Errors.MultipleErrors>_R
                                                                                       <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                            <*>_N
                                                                                                            <Language.PureScript.Options.Options>_R
                                                                                                            <Control.Monad.Trans.Except.ExceptT
                                                                                                               Language.PureScript.Errors.MultipleErrors
                                                                                                               (Control.Monad.Logger.Logger
                                                                                                                  Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                            <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N))
                  Language.PureScript.Make.Monad.$fMonadWriterMake3
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.Either.Either
                                                Language.PureScript.Errors.MultipleErrors
                                                ()>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                    <Language.PureScript.Errors.MultipleErrors>_R
                                                                    <Data.Either.Either
                                                                       Language.PureScript.Errors.MultipleErrors
                                                                       ()>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                         <Language.PureScript.Errors.MultipleErrors>_N
                                                                                         <Control.Monad.Logger.Logger
                                                                                            Language.PureScript.Errors.MultipleErrors>_R
                                                                                         <()>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                               <*>_N
                                                                                                               <Language.PureScript.Options.Options>_R
                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                               <()>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <()>_N))
                  Language.PureScript.Make.Monad.$fMonadWriterMake2
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <Language.PureScript.Options.Options>_R
                                 <Control.Monad.Trans.Except.ExceptT
                                    Language.PureScript.Errors.MultipleErrors
                                    (Control.Monad.Logger.Logger
                                       Language.PureScript.Errors.MultipleErrors)>_R
                                 <(a,
                                   Language.PureScript.Errors.MultipleErrors)>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <(a,
                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_N)
                  Language.PureScript.Make.Monad.$fMonadWriterMake1
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (Language.PureScript.Make.Monad.N:Make[0]) <(a,
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    -> Language.PureScript.Errors.MultipleErrors)>_N
                   ->_R (<Language.PureScript.Options.Options>_R
                         ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                       <Language.PureScript.Errors.MultipleErrors>_N
                                       <Control.Monad.Logger.Logger
                                          Language.PureScript.Errors.MultipleErrors>_R
                                       <a>_N)) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                           <*>_N
                                                           <Language.PureScript.Options.Options>_R
                                                           <Control.Monad.Trans.Except.ExceptT
                                                              Language.PureScript.Errors.MultipleErrors
                                                              (Control.Monad.Logger.Logger
                                                                 Language.PureScript.Errors.MultipleErrors)>_R
                                                           <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
43a7e88e7bcbc56f60cd7555b94afef0
  $fMonadWriterMake1 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      (a,
       Language.PureScript.Errors.MultipleErrors
       -> Language.PureScript.Errors.MultipleErrors)
    -> Language.PureScript.Options.Options
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors
         (Data.Either.Either Language.PureScript.Errors.MultipleErrors a)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             (a,
                              Language.PureScript.Errors.MultipleErrors
                              -> Language.PureScript.Errors.MultipleErrors))
                   (eta1 :: Language.PureScript.Options.Options) ->
                 Control.Monad.Writer.Class.$fMonadWriterwExceptT1
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
                   @ a
                   (eta
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <Language.PureScript.Options.Options>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <(a,
                           Language.PureScript.Errors.MultipleErrors
                           -> Language.PureScript.Errors.MultipleErrors)>_N)
                      eta1)) -}
b6537796335e7e57fbca7d8bfabccd8a
  $fMonadWriterMake2 ::
    Control.Monad.Trans.Reader.ReaderT
      Language.PureScript.Options.Options
      (Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors))
      a
    -> Language.PureScript.Options.Options
    -> Control.Monad.Trans.Except.ExceptT
         Language.PureScript.Errors.MultipleErrors
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         (a, Language.PureScript.Errors.MultipleErrors)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (eta :: Control.Monad.Trans.Reader.ReaderT
                             Language.PureScript.Options.Options
                             (Control.Monad.Trans.Except.ExceptT
                                Language.PureScript.Errors.MultipleErrors
                                (Control.Monad.Logger.Logger
                                   Language.PureScript.Errors.MultipleErrors))
                             a)
                   (eta1 :: Language.PureScript.Options.Options) ->
                 Control.Monad.Writer.Class.$fMonadWriterwExceptT_$clisten
                   @ Language.PureScript.Errors.MultipleErrors
                   @ (Control.Monad.Logger.Logger
                        Language.PureScript.Errors.MultipleErrors)
                   @ Language.PureScript.Errors.MultipleErrors
                   Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
                   @ a
                   (eta
                      `cast`
                    (Control.Monad.Trans.Reader.N:ReaderT[0]
                         <*>_N
                         <Language.PureScript.Options.Options>_R
                         <Control.Monad.Trans.Except.ExceptT
                            Language.PureScript.Errors.MultipleErrors
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)>_R
                         <a>_N)
                      eta1)) -}
e629bc8681effb3722fcee48e563218a
  $fMonadWriterMake3 ::
    Language.PureScript.Errors.MultipleErrors
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors () #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,A><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (eta :: Language.PureScript.Errors.MultipleErrors)
                   (ds :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case eta1
                        `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        r#
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.augment
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                (\ @ b
                                   (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                         -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   @ b
                                   c
                                   n
                                   a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                eta
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ ()
                      GHC.Tuple.() #) } } }) -}
c5f0dd7d9daad049543898a9aed15655
  $fMonadWriterMake4 ::
    (a, Language.PureScript.Errors.MultipleErrors)
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U,U)><L,A><S(S),1*U(U)><S,U>, Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: (a, Language.PureScript.Errors.MultipleErrors))
                   (w1 :: Language.PureScript.Options.Options)
                   (w2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2
                        `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of ww { GHC.STRef.STRef ww1 ->
                 Language.PureScript.Make.Monad.$w$cwriter @ a w ww1 w3 }) -}
a857448beddbd456859177396319c845
  $fMonadWriterMake_$s$fMonadWriterwLogger ::
    Control.Monad.Writer.Class.MonadWriter
      Language.PureScript.Errors.MultipleErrors
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.Errors.MultipleErrors
                  @ (Control.Monad.Logger.Logger
                       Language.PureScript.Errors.MultipleErrors)
                  Language.PureScript.Errors.$fMonoidMultipleErrors
                  Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
                  (Control.Monad.Logger.$fMonadWriterwLogger4
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <(a, Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R))
                  (\ (w1 :: Language.PureScript.Errors.MultipleErrors)
                     (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                     (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case r `cast`
                        (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                   case GHC.Prim.atomicModifyMutVar#
                          @ GHC.Prim.RealWorld
                          @ Language.PureScript.Errors.MultipleErrors
                          @ (Language.PureScript.Errors.MultipleErrors, ())
                          @ ()
                          r#
                          (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                           case GHC.Base.augment
                                  @ Language.PureScript.AST.Declarations.ErrorMessage
                                  (\ @ b
                                     (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                           -> b -> b)[OneShot]
                                     (n :: b)[OneShot] ->
                                   GHC.Base.foldr
                                     @ Language.PureScript.AST.Declarations.ErrorMessage
                                     @ b
                                     c
                                     n
                                     a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                  w1
                                    `cast`
                                  (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                           (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                            GHC.Tuple.()) })
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of b1 { () -> (# ipv, GHC.Tuple.() #) } } })
                    `cast`
                  (<Language.PureScript.Errors.MultipleErrors>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <()>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                           <Language.PureScript.Errors.MultipleErrors>_R
                                                           <()>_R))
                  (Control.Monad.Logger.$fMonadWriterwLogger2
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors a>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <(a,
                                         Language.PureScript.Errors.MultipleErrors)>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                    <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                    <(a,
                                                                                                      Language.PureScript.Errors.MultipleErrors)>_R))
                  (Control.Monad.Logger.$fMonadWriterwLogger1
                     @ Language.PureScript.Errors.MultipleErrors
                     Language.PureScript.Errors.$fMonoidMultipleErrors)
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Logger.Logger
                      Language.PureScript.Errors.MultipleErrors
                      (a,
                       Language.PureScript.Errors.MultipleErrors
                       -> Language.PureScript.Errors.MultipleErrors)>_R
                   ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <a>_R)) ; Sym (Control.Monad.Logger.N:Logger[0]
                                                          <Language.PureScript.Errors.MultipleErrors>_R
                                                          <a>_R)) -}
93b0c6bbfbab87a5a9b18fbb2f303092
  $s$fApplicativeExceptT_$c<*>1 ::
    Control.Monad.Trans.Except.ExceptT
      e
      (Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors)
      (a -> b)
    -> Control.Monad.Trans.Except.ExceptT
         e
         (Control.Monad.Logger.Logger
            Language.PureScript.Errors.MultipleErrors)
         a
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Either.Either e b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U)))><L,1*C1(C1(U(U,1*U)))><L,U><S,U>,
     Unfolding: (\ @ e
                   @ a
                   @ b
                   (w1 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            (a -> b))
                   (w2 :: Control.Monad.Trans.Except.ExceptT
                            e
                            (Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors)
                            a)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (w1
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <e>_N
                            <Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors>_R
                            <a -> b>_N ; Control.Monad.Logger.N:Logger[0]
                                             <Language.PureScript.Errors.MultipleErrors>_R
                                             <Data.Either.Either e (a -> b)>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Either.Either e (a -> b)>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left e1 -> (# ipv, Data.Either.Left @ e @ b e1 #)
                   Data.Either.Right k
                   -> case (w2
                              `cast`
                            (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N
                                 <Control.Monad.Logger.Logger
                                    Language.PureScript.Errors.MultipleErrors>_R
                                 <a>_N ; Control.Monad.Logger.N:Logger[0]
                                             <Language.PureScript.Errors.MultipleErrors>_R
                                             <Data.Either.Either e a>_R)
                              r)
                             `cast`
                           (GHC.Types.N:IO[0] <Data.Either.Either e a>_R)
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3 of wild1 {
                        Data.Either.Left e1 -> (# ipv2, Data.Either.Left @ e @ b e1 #)
                        Data.Either.Right x
                        -> (# ipv2, Data.Either.Right @ e @ b (k x) #) } } } }) -}
35b797fca54974938fbbf5b441fbf1ed
  $s$fApplicativeLogger1 ::
    (a -> b -> c)
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors a
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors b
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><C(C(S(SL))),1*C1(C1(U(U,U)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (f1 :: a -> b -> c)
                   (x :: Control.Monad.Logger.Logger
                           Language.PureScript.Errors.MultipleErrors a)
                   (eta :: Control.Monad.Logger.Logger
                             Language.PureScript.Errors.MultipleErrors b)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (x `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         eta1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        eta2 of ds { (#,#) ipv ipv1 ->
                 case (eta
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <b>_R)
                         eta1)
                        `cast`
                      (GHC.Types.N:IO[0] <b>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, f1 ipv1 ipv3 #) } }) -}
2e768ea789d571a4a7cdda2a190b3b94
  $s$fApplicativeLogger2 ::
    Control.Monad.Logger.Logger
      Language.PureScript.Errors.MultipleErrors (a -> b)
    -> Control.Monad.Logger.Logger
         Language.PureScript.Errors.MultipleErrors a
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors (a -> b))
                   (m2 :: Control.Monad.Logger.Logger
                            Language.PureScript.Errors.MultipleErrors a)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a -> b>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case (m2
                         `cast`
                       (Control.Monad.Logger.N:Logger[0]
                            <Language.PureScript.Errors.MultipleErrors>_R <a>_R)
                         r)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } }) -}
c67a83d6a077d17a6f8c5951a9eaeb30
  $s$fMonadWriterwLogger3 ::
    Language.PureScript.Errors.MultipleErrors
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (w1 :: Language.PureScript.Errors.MultipleErrors)
                   (r :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case r `cast`
                      (GHC.IORef.N:IORef[0] <Language.PureScript.Errors.MultipleErrors>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        r#
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.augment
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                (\ @ b
                                   (c :: Language.PureScript.AST.Declarations.ErrorMessage
                                         -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr
                                   @ Language.PureScript.AST.Declarations.ErrorMessage
                                   @ b
                                   c
                                   n
                                   a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0]))
                                w1
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () -> (# ipv, GHC.Tuple.() #) } } }) -}
8f13a9b95a0f1e201acef7aa58ae6d9c
  $tc'Make :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   960418695829144768##
                   8684237166814363410##
                   Language.PureScript.Make.Monad.$trModule
                   Language.PureScript.Make.Monad.$tc'Make2
                   1#
                   Language.PureScript.Make.Monad.$tc'Make1) -}
d14f639a7f51c72307bb77fda0fe119f
  $tc'Make1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8c5fc919d605189c4486c44af9d4ab73
  $tc'Make2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$tc'Make3) -}
36ada5bf8093a5e255cfd6adfba01be0
  $tc'Make3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Make"#) -}
bdc7abdb0460dfda90f73557f8773fdf
  $tcMake :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14829114614188917167##
                   5006432219615730975##
                   Language.PureScript.Make.Monad.$trModule
                   Language.PureScript.Make.Monad.$tcMake1
                   0#
                   GHC.Types.krep$*Arr*) -}
f1798054020616f6f67a035160b2f52c
  $tcMake1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$tcMake2) -}
1c3c7f25e9948e679c3aa8d506159de8
  $tcMake2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Make"#) -}
c3621e3e63a38d1426d73e2729407941
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.Make.Monad.$trModule3
                   Language.PureScript.Make.Monad.$trModule1) -}
08bc0e967ab277ec5d5c97d70a45288a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$trModule2) -}
756c37bc6404eaea17872223be0ea293
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.PureScript.Make.Monad"#) -}
9420458a007df359d19938ace96fbe8a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.Make.Monad.$trModule4) -}
3fea08fe057438f058dd0be157df90f1
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
2c8b98760f9b847aa2772a111da8bc4d
  $w$cwriter ::
    (a, Language.PureScript.Errors.MultipleErrors)
    -> GHC.Prim.MutVar#
         GHC.Prim.RealWorld Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(1*U,1*U)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: (a, Language.PureScript.Errors.MultipleErrors))
                   (ww :: GHC.Prim.MutVar#
                            GHC.Prim.RealWorld Language.PureScript.Errors.MultipleErrors)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   w4 :: Language.PureScript.Errors.MultipleErrors
                   = case w of wild { (,) a1 w5 -> w5 }
                 } in
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        @ (Language.PureScript.Errors.MultipleErrors, ())
                        @ ()
                        ww
                        (\ (a1 :: Language.PureScript.Errors.MultipleErrors) ->
                         case GHC.Base.++
                                @ Language.PureScript.AST.Declarations.ErrorMessage
                                a1 `cast` (Language.PureScript.Errors.N:MultipleErrors[0])
                                w4
                                  `cast`
                                (Language.PureScript.Errors.N:MultipleErrors[0]) of nt { DEFAULT ->
                         (nt `cast` (Sym (Language.PureScript.Errors.N:MultipleErrors[0])),
                          GHC.Tuple.()) })
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { () ->
                 (# ipv,
                    Data.Either.Right
                      @ Language.PureScript.Errors.MultipleErrors
                      @ a
                      (case w of wild { (,) a1 w5 -> a1 }) #) } }) -}
eabc01963aeba226db7b2caa9a4bf6b3
  $wreadTextFile ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Data.ByteString.Lazy.Internal.ByteString #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.IO.FilePath)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ (Data.Either.Either
                             GHC.IO.Exception.IOError Data.ByteString.Lazy.Internal.ByteString)
                        @ GHC.Exception.SomeException
                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.IO.Handle.FD.openBinaryFile1
                                w
                                GHC.IO.IOMode.ReadMode
                                s of ds1 { (#,#) ipv ipv1 ->
                         case Data.ByteString.Lazy.getContents2
                                ipv1
                                ipv of ds2 { (#,#) ipv2 ipv3 ->
                         (# ipv2,
                            Data.Either.Right
                              @ GHC.IO.Exception.IOError
                              @ Data.ByteString.Lazy.Internal.ByteString
                              ipv3 #) } })
                        (System.IO.Error.tryIOError2
                           @ Data.ByteString.Lazy.Internal.ByteString)
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left x
                   -> (# ipv,
                         Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ Data.ByteString.Lazy.Internal.ByteString
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessage
                              (Language.PureScript.AST.Declarations.ErrorMessage
                                 (GHC.Types.[]
                                    @ Language.PureScript.AST.Declarations.ErrorMessageHint)
                                 (Language.PureScript.AST.Declarations.CannotReadFile w))
                              (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                             `cast`
                           (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) #)
                   Data.Either.Right y
                   -> (# ipv,
                         Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ Data.ByteString.Lazy.Internal.ByteString
                           y #) } }) -}
3e3b14b08c410e5ba3c590f1d3af7206
  axiom Language.PureScript.Make.Monad.D:R:StMMakea::
      Control.Monad.Trans.Control.StM
        Language.PureScript.Make.Monad.Make a
        = Data.Either.Either Language.PureScript.Errors.MultipleErrors a
3e3b14b08c410e5ba3c590f1d3af7206
  type role Make nominal
  newtype Make a
    = Make {unMake :: Control.Monad.Trans.Reader.ReaderT
                        Language.PureScript.Options.Options
                        (Control.Monad.Trans.Except.ExceptT
                           Language.PureScript.Errors.MultipleErrors
                           (Control.Monad.Logger.Logger
                              Language.PureScript.Errors.MultipleErrors))
                        a}
00cc90af9817d7c7b877b2ad73f023f0
  makeIO ::
    (GHC.IO.Exception.IOError
     -> Language.PureScript.AST.Declarations.ErrorMessage)
    -> GHC.Types.IO a -> Language.PureScript.Make.Monad.Make a
  {- Arity: 5,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.makeIO1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.IO.Exception.IOError
                  -> Language.PureScript.AST.Declarations.ErrorMessage>_R
                 ->_R <GHC.Types.IO a>_R
                 ->_R (<Language.PureScript.Options.Options>_R
                       ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                             ->_R Sym (GHC.Types.N:IO[0]
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors
                                              a>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                 <Language.PureScript.Errors.MultipleErrors>_R
                                                                 <Data.Either.Either
                                                                    Language.PureScript.Errors.MultipleErrors
                                                                    a>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Language.PureScript.Errors.MultipleErrors>_N
                                                                                     <Control.Monad.Logger.Logger
                                                                                        Language.PureScript.Errors.MultipleErrors>_R
                                                                                     <a>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                          <*>_N
                                                                                                          <Language.PureScript.Options.Options>_R
                                                                                                          <Control.Monad.Trans.Except.ExceptT
                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                             (Control.Monad.Logger.Logger
                                                                                                                Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                          <a>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <a>_N)) -}
937192c80c26dea21563e175575c4be4
  makeIO1 ::
    (GHC.IO.Exception.IOError
     -> Language.PureScript.AST.Declarations.ErrorMessage)
    -> GHC.Types.IO a
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Language.PureScript.Errors.MultipleErrors a #)
  {- Arity: 5,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,A><L,A><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   (f :: GHC.IO.Exception.IOError
                         -> Language.PureScript.AST.Declarations.ErrorMessage)
                   (io :: GHC.Types.IO a)
                   (eta :: Language.PureScript.Options.Options)
                   (eta1 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ (Data.Either.Either GHC.IO.Exception.IOError a)
                        @ GHC.Exception.SomeException
                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case io `cast` (GHC.Types.N:IO[0] <a>_R)
                                s of ds1 { (#,#) ipv ipv1 ->
                         (# ipv, Data.Either.Right @ GHC.IO.Exception.IOError @ a ipv1 #) })
                        (System.IO.Error.tryIOError2 @ a)
                        eta2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left x
                   -> (# ipv,
                         Data.Either.Left
                           @ Language.PureScript.Errors.MultipleErrors
                           @ a
                           (GHC.Types.:
                              @ Language.PureScript.AST.Declarations.ErrorMessage
                              (f x)
                              (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage))
                             `cast`
                           (Sym (Language.PureScript.Errors.N:MultipleErrors[0])) #)
                   Data.Either.Right y
                   -> (# ipv,
                         Data.Either.Right
                           @ Language.PureScript.Errors.MultipleErrors
                           @ a
                           y #) } }) -}
263a09e2be3cabd481a9394cd39eb184
  readTextFile ::
    GHC.IO.FilePath
    -> Language.PureScript.Make.Monad.Make
         Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 4, Strictness: <L,U><L,A><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.readTextFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R (<Language.PureScript.Options.Options>_R
                       ->_R (<GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors>_R
                             ->_R Sym (GHC.Types.N:IO[0]
                                           <Data.Either.Either
                                              Language.PureScript.Errors.MultipleErrors
                                              Data.ByteString.Lazy.Internal.ByteString>_R)) ; (Sym (Control.Monad.Logger.N:Logger[0]
                                                                                                        <Language.PureScript.Errors.MultipleErrors>_R
                                                                                                        <Data.Either.Either
                                                                                                           Language.PureScript.Errors.MultipleErrors
                                                                                                           Data.ByteString.Lazy.Internal.ByteString>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                                                                                   <Language.PureScript.Errors.MultipleErrors>_N
                                                                                                                                                                   <Control.Monad.Logger.Logger
                                                                                                                                                                      Language.PureScript.Errors.MultipleErrors>_R
                                                                                                                                                                   <Data.ByteString.Lazy.Internal.ByteString>_N))) ; (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                                                                                                                                                               <*>_N
                                                                                                                                                                                                                               <Language.PureScript.Options.Options>_R
                                                                                                                                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)>_R
                                                                                                                                                                                                                               <Data.ByteString.Lazy.Internal.ByteString>_N) ; Sym (Language.PureScript.Make.Monad.N:Make[0]) <Data.ByteString.Lazy.Internal.ByteString>_N)) -}
db7d5f9229cfb269e0e6a8778272fa30
  readTextFile1 ::
    GHC.IO.FilePath
    -> Language.PureScript.Options.Options
    -> GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            Language.PureScript.Errors.MultipleErrors
            Data.ByteString.Lazy.Internal.ByteString #)
  {- Arity: 4, Strictness: <L,U><L,A><L,A><S,U>, Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ (w :: GHC.IO.FilePath)
                   (w1 :: Language.PureScript.Options.Options)
                   (w2 :: GHC.IORef.IORef Language.PureScript.Errors.MultipleErrors)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Language.PureScript.Make.Monad.$wreadTextFile w w3) -}
8977069e35c039b39b7cc3a8ba1933f5
  runMake ::
    Language.PureScript.Options.Options
    -> Language.PureScript.Make.Monad.Make a
    -> GHC.Types.IO
         (Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
          Language.PureScript.Errors.MultipleErrors)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SL)))),1*C1(C1(C1(U(U,U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.runMake1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Options.Options>_R
                 ->_R <Language.PureScript.Make.Monad.Make a>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <(Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
                                 Language.PureScript.Errors.MultipleErrors)>_R)) -}
ffecbafeee9c9f6c54a22699666af4a4
  runMake1 ::
    Language.PureScript.Options.Options
    -> Language.PureScript.Make.Monad.Make a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Either.Either Language.PureScript.Errors.MultipleErrors a,
           Language.PureScript.Errors.MultipleErrors) #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S(SL)))),1*C1(C1(C1(U(U,U))))><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (opts :: Language.PureScript.Options.Options)
                   (eta :: Language.PureScript.Make.Monad.Make a)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.newMutVar#
                        @ Language.PureScript.Errors.MultipleErrors
                        @ GHC.Prim.RealWorld
                        (GHC.Types.[] @ Language.PureScript.AST.Declarations.ErrorMessage)
                          `cast`
                        (Sym (Language.PureScript.Errors.N:MultipleErrors[0]))
                        eta1 of ds { (#,#) ipv ipv1 ->
                 case ((eta
                          `cast`
                        (Language.PureScript.Make.Monad.N:Make[0] <a>_N ; Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                              <*>_N
                                                                              <Language.PureScript.Options.Options>_R
                                                                              <Control.Monad.Trans.Except.ExceptT
                                                                                 Language.PureScript.Errors.MultipleErrors
                                                                                 (Control.Monad.Logger.Logger
                                                                                    Language.PureScript.Errors.MultipleErrors)>_R
                                                                              <a>_N)
                          opts)
                         `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <Language.PureScript.Errors.MultipleErrors>_N
                            <Control.Monad.Logger.Logger
                               Language.PureScript.Errors.MultipleErrors>_R
                            <a>_N ; Control.Monad.Logger.N:Logger[0]
                                        <Language.PureScript.Errors.MultipleErrors>_R
                                        <Data.Either.Either
                                           Language.PureScript.Errors.MultipleErrors a>_R)
                         (GHC.STRef.STRef
                            @ GHC.Prim.RealWorld
                            @ Language.PureScript.Errors.MultipleErrors
                            ipv1)
                           `cast`
                         (Sym (GHC.IORef.N:IORef[0]) <Language.PureScript.Errors.MultipleErrors>_N))
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.Either.Either Language.PureScript.Errors.MultipleErrors a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 case GHC.Prim.readMutVar#
                        @ GHC.Prim.RealWorld
                        @ Language.PureScript.Errors.MultipleErrors
                        ipv1
                        ipv2 of ds2 { (#,#) ipv4 ipv5 ->
                 (# ipv4, (ipv3, ipv5) #) } } }) -}
3e3b14b08c410e5ba3c590f1d3af7206
  unMake ::
    Language.PureScript.Make.Monad.Make a
    -> Control.Monad.Trans.Reader.ReaderT
         Language.PureScript.Options.Options
         (Control.Monad.Trans.Except.ExceptT
            Language.PureScript.Errors.MultipleErrors
            (Control.Monad.Logger.Logger
               Language.PureScript.Errors.MultipleErrors))
         a
  RecSel Left Language.PureScript.Make.Monad.Make
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Language.PureScript.Make.Monad.unMake1
                  `cast`
                (forall (a :: <*>_N).
                 <Language.PureScript.Make.Monad.Make a>_R
                 ->_R Language.PureScript.Make.Monad.N:Make[0] <a>_N) -}
3e3b14b08c410e5ba3c590f1d3af7206
  unMake1 ::
    Language.PureScript.Make.Monad.Make a
    -> Language.PureScript.Make.Monad.Make a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Language.PureScript.Make.Monad.Make a) -> ds) -}
instance GHC.Base.Applicative [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fApplicativeMake
instance GHC.Base.Functor [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fFunctorMake
instance Control.Monad.Trans.Control.MonadBaseControl [GHC.Types.IO,
                                                       Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadBaseControlIOMake
instance Control.Monad.Base.MonadBase [GHC.Types.IO,
                                       Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadBaseIOMake
instance Control.Monad.Error.Class.MonadError [Language.PureScript.Errors.MultipleErrors,
                                               Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadErrorMake
instance Control.Monad.IO.Class.MonadIO [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadIOMake
instance GHC.Base.Monad [Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadMake
instance Control.Monad.Reader.Class.MonadReader [Language.PureScript.Options.Options,
                                                 Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadReaderMake
instance Control.Monad.Writer.Class.MonadWriter [Language.PureScript.Errors.MultipleErrors,
                                                 Language.PureScript.Make.Monad.Make]
  = Language.PureScript.Make.Monad.$fMonadWriterMake
family instance Control.Monad.Trans.Control.StM [Language.PureScript.Make.Monad.Make],
                                                [.]
  = Language.PureScript.Make.Monad.D:R:StMMakea
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                                   Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger @ Language.PureScript.Errors.MultipleErrors
                                           v
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeLogger
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger1 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                           Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger1 @ Language.PureScript.Errors.MultipleErrors
                                            $dMonoid
  = Language.PureScript.Make.Monad.$s$fApplicativeLogger1
"SPEC/Language.PureScript.Make.Monad $fApplicativeLogger2 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                           Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fApplicativeLogger2 @ Language.PureScript.Errors.MultipleErrors
                                            $dMonoid
  = Language.PureScript.Make.Monad.$s$fApplicativeLogger2
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c*> @ (ExceptT
                                                                   MultipleErrors
                                                                   (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                           ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*> @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Logger.Logger
                                                               Language.PureScript.Errors.MultipleErrors))
                                                       @ r
                                                       $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c*>
      @ r
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c<* @ (ExceptT
                                                                   MultipleErrors
                                                                   (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                           ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<* @ (Control.Monad.Trans.Except.ExceptT
                                                            Language.PureScript.Errors.MultipleErrors
                                                            (Control.Monad.Logger.Logger
                                                               Language.PureScript.Errors.MultipleErrors))
                                                       @ r
                                                       $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*
      @ r
"SPEC/Language.PureScript.Make.Monad $fApplicativeReaderT_$c<*> @ (ExceptT
                                                                    MultipleErrors
                                                                    (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                              ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                                     (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ (Control.Monad.Trans.Except.ExceptT
                                                             Language.PureScript.Errors.MultipleErrors
                                                             (Control.Monad.Logger.Logger
                                                                Language.PureScript.Errors.MultipleErrors))
                                                        @ r
                                                        $dApplicative
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/Language.PureScript.Make.Monad $fFunctorExceptT_$cfmap @ (Logger
                                                                 MultipleErrors) _" [orphan] forall @ e
                                                                                                                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                           (Control.Monad.Logger.Logger
                                                                                                                                                                                              Language.PureScript.Errors.MultipleErrors))
  Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap @ (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors)
                                                     @ e
                                                     $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorExceptT_$cfmap
      @ e
"SPEC/Language.PureScript.Make.Monad $fFunctorReaderT_$c<$ @ (ExceptT
                                                               MultipleErrors
                                                               (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                  Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                  (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        (Control.Monad.Logger.Logger
                                                           Language.PureScript.Errors.MultipleErrors))
                                                   @ r
                                                   $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$c<$
      @ r
"SPEC/Language.PureScript.Make.Monad $fFunctorReaderT_$cfmap @ (ExceptT
                                                                 MultipleErrors
                                                                 (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                        (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                           Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                          Language.PureScript.Errors.MultipleErrors
                                                          (Control.Monad.Logger.Logger
                                                             Language.PureScript.Errors.MultipleErrors))
                                                     @ r
                                                     $dFunctor
  = Language.PureScript.Make.Monad.$fFunctorMake_$s$fFunctorReaderT_$cfmap
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                             Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadLogger @ Language.PureScript.Errors.MultipleErrors
                                     v
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger
"SPEC/Language.PureScript.Make.Monad $fMonadLogger_$c>> @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                         Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadLogger_$c>> @ Language.PureScript.Errors.MultipleErrors
                                          $dMonoid
  = Language.PureScript.Make.Monad.$fApplicativeMake_$s$fMonadLogger_$c>>
"SPEC/Language.PureScript.Make.Monad $fMonadReaderT_$c>>= @ (ExceptT
                                                              MultipleErrors
                                                              (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                             Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                             (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                       Language.PureScript.Errors.MultipleErrors
                                                       (Control.Monad.Logger.Logger
                                                          Language.PureScript.Errors.MultipleErrors))
                                                  @ r
                                                  $dMonad
  = Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$c>>=
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadReaderT_$cfail @ (ExceptT
                                                               MultipleErrors
                                                               (Logger MultipleErrors)) _" [orphan] forall @ r
                                                                                                                                                                                                                                                               ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                                                                                Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                                                                                                                (Control.Monad.Logger.Logger
                                                                                                                                                                                                                                                                                   Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                        Language.PureScript.Errors.MultipleErrors
                                                        (Control.Monad.Logger.Logger
                                                           Language.PureScript.Errors.MultipleErrors))
                                                   @ r
                                                   $dMonad
  = Language.PureScript.Make.Monad.$fMonadMake_$s$fMonadReaderT_$cfail
      @ r
"SPEC/Language.PureScript.Make.Monad $fMonadWriterwLogger @ MultipleErrors" [orphan] forall (v :: GHC.Base.Monoid
                                                                                                    Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadWriterwLogger @ Language.PureScript.Errors.MultipleErrors
                                            v
  = Language.PureScript.Make.Monad.$fMonadWriterMake_$s$fMonadWriterwLogger
"SPEC/Language.PureScript.Make.Monad $fMonadWriterwLogger3 @ MultipleErrors" [orphan] forall ($dMonoid :: GHC.Base.Monoid
                                                                                                            Language.PureScript.Errors.MultipleErrors)
  Control.Monad.Logger.$fMonadWriterwLogger3 @ Language.PureScript.Errors.MultipleErrors
                                             $dMonoid
  = Language.PureScript.Make.Monad.$s$fMonadWriterwLogger3
"SPEC/Language.PureScript.Make.Monad reader @ (ExceptT
                                                MultipleErrors (Logger MultipleErrors)) _ _" [orphan] forall @ r
                                                                                                                                                                    @ a
                                                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                     Language.PureScript.Errors.MultipleErrors
                                                                                                                                                                                     (Control.Monad.Logger.Logger
                                                                                                                                                                                        Language.PureScript.Errors.MultipleErrors)))
  Control.Monad.Trans.Reader.reader @ (Control.Monad.Trans.Except.ExceptT
                                         Language.PureScript.Errors.MultipleErrors
                                         (Control.Monad.Logger.Logger
                                            Language.PureScript.Errors.MultipleErrors))
                                    @ r
                                    @ a
                                    $dMonad
  = Language.PureScript.Make.Monad.$fMonadReaderMake_$sreader @ r @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

