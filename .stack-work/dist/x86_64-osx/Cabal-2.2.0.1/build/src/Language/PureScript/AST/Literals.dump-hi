
==================== FINAL INTERFACE ====================
2018-11-30 19:26:17.540945 UTC

interface purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.AST.Literals 8043
  interface hash: bc56390f66dbd10ab5f52f500ed83ce0
  ABI hash: 3440d35205601002007fae6139f2b416
  export-list hash: a6d23ec6b024fefaa1b9450acf6240d0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: de35dcd1d43076a5ced1b1f2744d7ead
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.AST.Literals.Literal{Language.PureScript.AST.Literals.ArrayLiteral Language.PureScript.AST.Literals.BooleanLiteral Language.PureScript.AST.Literals.CharLiteral Language.PureScript.AST.Literals.NumericLiteral Language.PureScript.AST.Literals.ObjectLiteral Language.PureScript.AST.Literals.StringLiteral}
module dependencies: Language.PureScript.PSString
package dependencies: aeson-1.3.1.1 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1 primitive-0.6.3.0
                      random-1.1 scientific-0.3.6.2 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 time-1.8.0.2
                      time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7:Language.PureScript.PSString
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  Language.PureScript.PSString 29492f728997dffadb84d1bf161f2ce4
  exports: 41608caf7cc5b51f34de641c9952ab6d
  PSString 0c2d9eac7fc8cff2b3ca27abf6053439
9e9b6c02bfac90a56d53685e90c059b8
  $fEqLiteral ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fEqLiteral_$c== @ a v)
                  (Language.PureScript.AST.Literals.$fEqLiteral_$c/= @ a v) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fEqLiteral_$c/= ::
    GHC.Classes.Eq a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fEqLiteral_$c==
                        @ a
                        $dEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fEqLiteral_$c== ::
    GHC.Classes.Eq a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.PureScript.PSString.PSString, a)
                   = GHC.Classes.$fEq(,)
                       @ Language.PureScript.PSString.PSString
                       @ a
                       Language.PureScript.PSString.$fEqPSString
                       $dEq
                 } in
                 \ (ds :: Language.PureScript.AST.Literals.Literal a)
                   (ds1 :: Language.PureScript.AST.Literals.Literal a) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.NumericLiteral b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.eqInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.False }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.False
                                  Data.Either.Right b2 -> GHC.Classes.eqDouble a2 b2 } } }
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.StringLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ GHC.Word.Word16
                             GHC.Word.$fEqWord16
                             a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.CharLiteral b1
                        -> GHC.Classes.eqChar a1 b1 }
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.BooleanLiteral b1
                        -> GHC.Classes.$fEqBool_$c== a1 b1 }
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.ArrayLiteral b1
                        -> GHC.Classes.$fEq[]_$c== @ a $dEq a1 b1 }
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.ObjectLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ (Language.PureScript.PSString.PSString, a)
                             $dEq1
                             a1
                             b1 } }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fFunctorLiteral ::
    GHC.Base.Functor Language.PureScript.AST.Literals.Literal
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.AST.Literals.Literal
                  Language.PureScript.AST.Literals.$fFunctorLiteral_$cfmap
                  Language.PureScript.AST.Literals.$fFunctorLiteral_$c<$ -}
9e9b6c02bfac90a56d53685e90c059b8
  $fFunctorLiteral_$c<$ ::
    a
    -> Language.PureScript.AST.Literals.Literal b
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.PureScript.AST.Literals.Literal b) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> Language.PureScript.AST.Literals.NumericLiteral @ a a1
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> Language.PureScript.AST.Literals.StringLiteral @ a a1
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> Language.PureScript.AST.Literals.CharLiteral @ a a1
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> Language.PureScript.AST.Literals.BooleanLiteral @ a a1
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> Language.PureScript.AST.Literals.ArrayLiteral
                        @ a
                        (GHC.Base.$fFunctor[]_$c<$ @ a @ b z a1)
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> Language.PureScript.AST.Literals.ObjectLiteral
                        @ a
                        (GHC.Base.map
                           @ (Language.PureScript.PSString.PSString, b)
                           @ (Language.PureScript.PSString.PSString, a)
                           (\ (b3 :: (Language.PureScript.PSString.PSString, b)) ->
                            case b3 of wild1 { (,) a2 a3 -> (a2, z) })
                           a1) }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fFunctorLiteral_$cfmap ::
    (a -> b)
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f4 :: a -> b)
                   (ds :: Language.PureScript.AST.Literals.Literal a) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> Language.PureScript.AST.Literals.NumericLiteral @ b a1
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> Language.PureScript.AST.Literals.StringLiteral @ b a1
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> Language.PureScript.AST.Literals.CharLiteral @ b a1
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> Language.PureScript.AST.Literals.BooleanLiteral @ b a1
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> Language.PureScript.AST.Literals.ArrayLiteral
                        @ b
                        (GHC.Base.map @ a @ b f4 a1)
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> Language.PureScript.AST.Literals.ObjectLiteral
                        @ b
                        (GHC.Base.map
                           @ (Language.PureScript.PSString.PSString, a)
                           @ (Language.PureScript.PSString.PSString, b)
                           (\ (b2 :: (Language.PureScript.PSString.PSString, a)) ->
                            case b2 of wild1 { (,) a2 a3 -> (a2, f4 a3) })
                           a1) }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral ::
    GHC.Classes.Ord a =>
    GHC.Classes.Ord (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cp1Ord @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c< @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c<= @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c> @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c>= @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cmax @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cmin @ a v) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$c< ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$c<= ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$c> ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$c>= ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$ccompare ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord
                               (Language.PureScript.PSString.PSString, a)
                   = GHC.Classes.$fOrd(,)
                       @ Language.PureScript.PSString.PSString
                       @ a
                       Language.PureScript.PSString.$fOrdPSString
                       $dOrd
                 } in
                 \ (a1 :: Language.PureScript.AST.Literals.Literal a)
                   (b :: Language.PureScript.AST.Literals.Literal a) ->
                 case a1 of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        Language.PureScript.AST.Literals.NumericLiteral b1
                        -> case a2 of wild2 {
                             Data.Either.Left a3
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.compareInteger a3 b2
                                  Data.Either.Right ipv -> GHC.Types.LT }
                             Data.Either.Right a3
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.GT
                                  Data.Either.Right b2
                                  -> GHC.Classes.$fOrdDouble_$ccompare a3 b2 } } }
                   Language.PureScript.AST.Literals.StringLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        Language.PureScript.AST.Literals.NumericLiteral ds -> GHC.Types.GT
                        Language.PureScript.AST.Literals.StringLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ GHC.Word.Word16
                             GHC.Word.$fOrdWord16
                             a2 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.AST.Literals.CharLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.CharLiteral ds
                        -> GHC.Classes.$fOrdChar_$ccompare a2 ds
                        Language.PureScript.AST.Literals.BooleanLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ArrayLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.BooleanLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.BooleanLiteral ds
                        -> GHC.Classes.$fOrdBool_$ccompare a2 ds
                        Language.PureScript.AST.Literals.ArrayLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.ArrayLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.ArrayLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare @ a $dOrd a2 b1
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.ObjectLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.ObjectLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ (Language.PureScript.PSString.PSString, a)
                             $dOrd1
                             a2
                             b1 } }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$cmax ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$cmin ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fOrdLiteral_$cp1Ord ::
    GHC.Classes.Ord a =>
    GHC.Classes.Eq (Language.PureScript.AST.Literals.Literal a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Language.PureScript.AST.Literals.$fEqLiteral
                   @ a
                   (GHC.Classes.$p1Ord @ a $dOrd)) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fShowLiteral ::
    GHC.Show.Show a =>
    GHC.Show.Show (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec @ a v)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshow @ a v)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshowList
                     @ a
                     v) -}
d037a94cbc11c3d19ea227f23a710e18
  $fShowLiteral1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fShowLiteral_$cshow ::
    GHC.Show.Show a =>
    Language.PureScript.AST.Literals.Literal a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Language.PureScript.AST.Literals.Literal a) ->
                 Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec
                   @ a
                   $dShow
                   Language.PureScript.AST.Literals.$fShowLiteral1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fShowLiteral_$cshowList ::
    GHC.Show.Show a =>
    [Language.PureScript.AST.Literals.Literal a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Language.PureScript.AST.Literals.Literal a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.PureScript.AST.Literals.Literal a)
                   (Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec
                      @ a
                      $dShow
                      Language.PureScript.AST.Literals.$fShowLiteral1)
                   ls
                   s) -}
9e9b6c02bfac90a56d53685e90c059b8
  $fShowLiteral_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.PureScript.AST.Literals.Literal a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.AST.Literals.$w$cshowsPrec @ a w ww1 w2 }) -}
102d8b63a93ae1ac7a0d4e3998ba4cc1
  $tc'ArrayLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4283544430309606631##
                   4882935967980112591##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral1) -}
c08ee3e751b7de1c51cfe57a245b037c
  $tc'ArrayLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cbeed05e30ec6c94235347a15f5122a7
  $tc'ArrayLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral3) -}
d53d7cfbb49cf55b446051a37f0a3556
  $tc'ArrayLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayLiteral"#) -}
0d8691cd377729a878e83d932f8704fe
  $tc'BooleanLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4252837215635758000##
                   13373256866466724982##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral1) -}
7dda0a08a1add359bc9ba524c7cd628f
  $tc'BooleanLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e0a3345b5abe42b6e88f32e88c28ddd
  $tc'BooleanLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral3) -}
052d4be97533516b3a067c2f0d2c45db
  $tc'BooleanLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BooleanLiteral"#) -}
eb490773fbb20a3abe2a4b014e8dcd5a
  $tc'CharLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6792708768855711671##
                   652131655879233159##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'CharLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'CharLiteral1) -}
45ac7e6daeb818f9fc5e8329d8755306
  $tc'CharLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bec42fc35f6aa64e97ab6f59975b2b4f
  $tc'CharLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'CharLiteral3) -}
3263d1c9eb63865bf641deeb76887b1d
  $tc'CharLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CharLiteral"#) -}
dd163634936bfdf1dfb5e4fd896c1a07
  $tc'NumericLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12968808509084785974##
                   11899277522493041000##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'NumericLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'NumericLiteral1) -}
7e6297bd99337dd2386bd2a595cd48a0
  $tc'NumericLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c4d5434a6e05bad00ce638f7f08a0260
  $tc'NumericLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'NumericLiteral3) -}
407aea2320d62737c97f67c2afe695d7
  $tc'NumericLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NumericLiteral"#) -}
3fdff9b9c2ee03c77079de6fe513de54
  $tc'ObjectLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12281160241914677160##
                   8323256797745278535##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral1) -}
70e4e3aae0130866ee0e3af09e0154f5
  $tc'ObjectLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4aad93fa171d60e046658176ecaefb41
  $tc'ObjectLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral3) -}
d5489716b4afd96410f0c208bda96fd2
  $tc'ObjectLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObjectLiteral"#) -}
9bd57162412c7cf5676b18481c999df2
  $tc'StringLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2084352711363694299##
                   13645773396723319752##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'StringLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'StringLiteral1) -}
0ebab51f25c5fa6890bc68f4fa21eb7c
  $tc'StringLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4d083a66051f9a3da38ea1eea290bb52
  $tc'StringLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'StringLiteral3) -}
f1b0fab054acb94412c56b31f3a2edd6
  $tc'StringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLiteral"#) -}
8bb71733e210b8222d2228037c743855
  $tcLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   581498468633708705##
                   3754603698264594963##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tcLiteral1
                   0#
                   GHC.Types.krep$*Arr*) -}
f73b5d0d7ccf64fc5d2a13b9ca5d809c
  $tcLiteral1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tcLiteral2) -}
a0c3d140f8ea3db0b6a477cae1d8b4d7
  $tcLiteral2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Literal"#) -}
58f30de4da202bba40a689202ab0704e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.AST.Literals.$trModule3
                   Language.PureScript.AST.Literals.$trModule1) -}
2434e2417e6daf1de1d4957510fd9efc
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$trModule2) -}
6f462f329f5c15b5d61b797582d1e8c1
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.AST.Literals"#) -}
c0a0c668a655c86652ff04b227c3691a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$trModule4) -}
4c5126ce2c0ca588643f724d19a6913b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.1-Hd7ka7pmldWKPBJH6hcve7"#) -}
9e9b6c02bfac90a56d53685e90c059b8
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,1*C1(C(U)))><S,U><S,1*U>,
     Inline: [0] -}
9e9b6c02bfac90a56d53685e90c059b8
  data Literal a
    = NumericLiteral (Data.Either.Either
                        GHC.Integer.Type.Integer GHC.Types.Double)
    | StringLiteral Language.PureScript.PSString.PSString
    | CharLiteral GHC.Types.Char
    | BooleanLiteral GHC.Types.Bool
    | ArrayLiteral [a]
    | ObjectLiteral [(Language.PureScript.PSString.PSString, a)]
instance GHC.Classes.Eq [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fEqLiteral
instance GHC.Base.Functor [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fFunctorLiteral
instance GHC.Classes.Ord [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fOrdLiteral
instance GHC.Show.Show [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fShowLiteral
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

