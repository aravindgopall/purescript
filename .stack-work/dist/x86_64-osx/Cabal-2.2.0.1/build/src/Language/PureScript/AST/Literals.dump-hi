
==================== FINAL INTERFACE ====================
2019-01-24 14:13:31.39013 UTC

interface purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.AST.Literals 8043
  interface hash: 8be6e5a2eddb00288a25bf0f465041d6
  ABI hash: da2ec269f063125450b272321f85468a
  export-list hash: ab5af4e7482c5a8cbf79fdfd52ee94e2
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: de35dcd1d43076a5ced1b1f2744d7ead
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.PureScript.AST.Literals.Literal{Language.PureScript.AST.Literals.ArrayLiteral Language.PureScript.AST.Literals.BooleanLiteral Language.PureScript.AST.Literals.CharLiteral Language.PureScript.AST.Literals.NumericLiteral Language.PureScript.AST.Literals.ObjectLiteral Language.PureScript.AST.Literals.StringLiteral}
module dependencies: Language.PureScript.PSString
package dependencies: aeson-1.3.1.1 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 base-compat-0.10.4 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      dlist-0.8.0.4 ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1 primitive-0.6.3.0
                      random-1.1 scientific-0.3.6.2 tagged-0.8.5
                      template-haskell-2.13.0.0 text-1.2.3.0 time-1.8.0.2
                      time-locale-compat-0.1.1.4 transformers-0.5.5.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: aeson-1.3.1.1:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         dlist-0.8.0.4:Data.DList ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F:Language.PureScript.PSString
                         tagged-0.8.5:Data.Tagged
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-compat-0.10.4:Prelude.Compat bb6796186ed35a1d09dc34362a3fc27e
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
import  -/  Language.PureScript.PSString 482bcd39d274b3e3efbde5749bd9d797
  exports: dedd5d31dc509736134f041863efd1d4
  PSString 96ffea2472d48cda76cc39d47ab7bb82
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fEqLiteral ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fEqLiteral_$c== @ a v)
                  (Language.PureScript.AST.Literals.$fEqLiteral_$c/= @ a v) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fEqLiteral_$c/= ::
    GHC.Classes.Eq a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fEqLiteral_$c==
                        @ a
                        $dEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fEqLiteral_$c== ::
    GHC.Classes.Eq a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.PureScript.PSString.PSString, a)
                   = GHC.Classes.$fEq(,)
                       @ Language.PureScript.PSString.PSString
                       @ a
                       Language.PureScript.PSString.$fEqPSString
                       $dEq
                 } in
                 \ (ds :: Language.PureScript.AST.Literals.Literal a)
                   (ds1 :: Language.PureScript.AST.Literals.Literal a) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.NumericLiteral b1
                        -> case a1 of wild2 {
                             Data.Either.Left a2
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.eqInteger a2 b2
                                  Data.Either.Right ipv -> GHC.Types.False }
                             Data.Either.Right a2
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.False
                                  Data.Either.Right b2 -> GHC.Classes.eqDouble a2 b2 } } }
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.StringLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ GHC.Word.Word16
                             GHC.Word.$fEqWord16
                             a1 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.CharLiteral b1
                        -> GHC.Classes.eqChar a1 b1 }
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.BooleanLiteral b1
                        -> GHC.Classes.$fEqBool_$c== a1 b1 }
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.ArrayLiteral b1
                        -> GHC.Classes.$fEq[]_$c== @ a $dEq a1 b1 }
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.PureScript.AST.Literals.ObjectLiteral b1
                        -> GHC.Classes.$fEq[]_$c==
                             @ (Language.PureScript.PSString.PSString, a)
                             $dEq1
                             a1
                             b1 } }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fFunctorLiteral ::
    GHC.Base.Functor Language.PureScript.AST.Literals.Literal
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.PureScript.AST.Literals.Literal
                  Language.PureScript.AST.Literals.$fFunctorLiteral_$cfmap
                  Language.PureScript.AST.Literals.$fFunctorLiteral_$c<$ -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fFunctorLiteral_$c<$ ::
    a
    -> Language.PureScript.AST.Literals.Literal b
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.PureScript.AST.Literals.Literal b) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> Language.PureScript.AST.Literals.NumericLiteral @ a a1
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> Language.PureScript.AST.Literals.StringLiteral @ a a1
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> Language.PureScript.AST.Literals.CharLiteral @ a a1
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> Language.PureScript.AST.Literals.BooleanLiteral @ a a1
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> Language.PureScript.AST.Literals.ArrayLiteral
                        @ a
                        (GHC.Base.$fFunctor[]_$c<$ @ a @ b z a1)
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> Language.PureScript.AST.Literals.ObjectLiteral
                        @ a
                        (GHC.Base.map
                           @ (Language.PureScript.PSString.PSString, b)
                           @ (Language.PureScript.PSString.PSString, a)
                           (\ (b3 :: (Language.PureScript.PSString.PSString, b)) ->
                            case b3 of wild1 { (,) a2 a3 -> (a2, z) })
                           a1) }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fFunctorLiteral_$cfmap ::
    (a -> b)
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f4 :: a -> b)
                   (ds :: Language.PureScript.AST.Literals.Literal a) ->
                 case ds of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a1
                   -> Language.PureScript.AST.Literals.NumericLiteral @ b a1
                   Language.PureScript.AST.Literals.StringLiteral a1
                   -> Language.PureScript.AST.Literals.StringLiteral @ b a1
                   Language.PureScript.AST.Literals.CharLiteral a1
                   -> Language.PureScript.AST.Literals.CharLiteral @ b a1
                   Language.PureScript.AST.Literals.BooleanLiteral a1
                   -> Language.PureScript.AST.Literals.BooleanLiteral @ b a1
                   Language.PureScript.AST.Literals.ArrayLiteral a1
                   -> Language.PureScript.AST.Literals.ArrayLiteral
                        @ b
                        (GHC.Base.map @ a @ b f4 a1)
                   Language.PureScript.AST.Literals.ObjectLiteral a1
                   -> Language.PureScript.AST.Literals.ObjectLiteral
                        @ b
                        (GHC.Base.map
                           @ (Language.PureScript.PSString.PSString, a)
                           @ (Language.PureScript.PSString.PSString, b)
                           (\ (b2 :: (Language.PureScript.PSString.PSString, a)) ->
                            case b2 of wild1 { (,) a2 a3 -> (a2, f4 a3) })
                           a1) }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral ::
    GHC.Classes.Ord a =>
    GHC.Classes.Ord (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cp1Ord @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c< @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c<= @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c> @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$c>= @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cmax @ a v)
                  (Language.PureScript.AST.Literals.$fOrdLiteral_$cmin @ a v) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$c< ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$c<= ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$c> ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$c>= ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$ccompare ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord
                               (Language.PureScript.PSString.PSString, a)
                   = GHC.Classes.$fOrd(,)
                       @ Language.PureScript.PSString.PSString
                       @ a
                       Language.PureScript.PSString.$fOrdPSString
                       $dOrd
                 } in
                 \ (a1 :: Language.PureScript.AST.Literals.Literal a)
                   (b :: Language.PureScript.AST.Literals.Literal a) ->
                 case a1 of wild {
                   Language.PureScript.AST.Literals.NumericLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        Language.PureScript.AST.Literals.NumericLiteral b1
                        -> case a2 of wild2 {
                             Data.Either.Left a3
                             -> case b1 of wild3 {
                                  Data.Either.Left b2 -> GHC.Integer.Type.compareInteger a3 b2
                                  Data.Either.Right ipv -> GHC.Types.LT }
                             Data.Either.Right a3
                             -> case b1 of wild3 {
                                  Data.Either.Left ipv -> GHC.Types.GT
                                  Data.Either.Right b2
                                  -> GHC.Classes.$fOrdDouble_$ccompare a3 b2 } } }
                   Language.PureScript.AST.Literals.StringLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        Language.PureScript.AST.Literals.NumericLiteral ds -> GHC.Types.GT
                        Language.PureScript.AST.Literals.StringLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ GHC.Word.Word16
                             GHC.Word.$fOrdWord16
                             a2 `cast` (Language.PureScript.PSString.N:PSString[0])
                             b1 `cast` (Language.PureScript.PSString.N:PSString[0]) }
                   Language.PureScript.AST.Literals.CharLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.CharLiteral ds
                        -> GHC.Classes.$fOrdChar_$ccompare a2 ds
                        Language.PureScript.AST.Literals.BooleanLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ArrayLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.BooleanLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.BooleanLiteral ds
                        -> GHC.Classes.$fOrdBool_$ccompare a2 ds
                        Language.PureScript.AST.Literals.ArrayLiteral ds -> GHC.Types.LT
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.ArrayLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.ArrayLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare @ a $dOrd a2 b1
                        Language.PureScript.AST.Literals.ObjectLiteral ds -> GHC.Types.LT }
                   Language.PureScript.AST.Literals.ObjectLiteral a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Language.PureScript.AST.Literals.ObjectLiteral b1
                        -> GHC.Classes.$fOrd[]_$ccompare
                             @ (Language.PureScript.PSString.PSString, a)
                             $dOrd1
                             a2
                             b1 } }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$cmax ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$cmin ::
    GHC.Classes.Ord a =>
    Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
    -> Language.PureScript.AST.Literals.Literal a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Language.PureScript.AST.Literals.Literal a)
                   (y :: Language.PureScript.AST.Literals.Literal a) ->
                 case Language.PureScript.AST.Literals.$fOrdLiteral_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fOrdLiteral_$cp1Ord ::
    GHC.Classes.Ord a =>
    GHC.Classes.Eq (Language.PureScript.AST.Literals.Literal a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Language.PureScript.AST.Literals.$fEqLiteral
                   @ a
                   (GHC.Classes.$p1Ord @ a $dOrd)) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fShowLiteral ::
    GHC.Show.Show a =>
    GHC.Show.Show (Language.PureScript.AST.Literals.Literal a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Language.PureScript.AST.Literals.Literal a)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec @ a v)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshow @ a v)
                  (Language.PureScript.AST.Literals.$fShowLiteral_$cshowList
                     @ a
                     v) -}
9f422cab6c89ec1bc129e8ffb5dc2dfd
  $fShowLiteral1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fShowLiteral_$cshow ::
    GHC.Show.Show a =>
    Language.PureScript.AST.Literals.Literal a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Language.PureScript.AST.Literals.Literal a) ->
                 Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec
                   @ a
                   $dShow
                   Language.PureScript.AST.Literals.$fShowLiteral1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fShowLiteral_$cshowList ::
    GHC.Show.Show a =>
    [Language.PureScript.AST.Literals.Literal a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Language.PureScript.AST.Literals.Literal a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.PureScript.AST.Literals.Literal a)
                   (Language.PureScript.AST.Literals.$fShowLiteral_$cshowsPrec
                      @ a
                      $dShow
                      Language.PureScript.AST.Literals.$fShowLiteral1)
                   ls
                   s) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $fShowLiteral_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,C(C(U)))><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.PureScript.AST.Literals.Literal a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.PureScript.AST.Literals.$w$cshowsPrec @ a w ww1 w2 }) -}
875caf823b1b385bf56bb470bbfafa98
  $tc'ArrayLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2987586482369616358##
                   2606315830766721441##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral1) -}
452c61fe130ca7f34510d2318985ca0c
  $tc'ArrayLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f841852279d463cba0187439106ab9f8
  $tc'ArrayLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'ArrayLiteral3) -}
618cdccbcfdd9fd24b0b4568205a1747
  $tc'ArrayLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayLiteral"#) -}
961263179f2d98da05d8f8e6005aa51f
  $tc'BooleanLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16402579597727737501##
                   10147751012239565276##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral1) -}
c5100ddc92aa3a7b1667cd9713f7f39c
  $tc'BooleanLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
699c372b2f33fa4f4f6d60bac97e4d2f
  $tc'BooleanLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'BooleanLiteral3) -}
dd073b7ae029ff67b3df4c3d9924a0c6
  $tc'BooleanLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BooleanLiteral"#) -}
ed8b22f9860e9d0b9ebcd93c51840046
  $tc'CharLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9433453689809231268##
                   15012406505502881709##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'CharLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'CharLiteral1) -}
99fd9ac0af7deff9636aba08027b2263
  $tc'CharLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4bc6b835ffc2e6d9a4fc8f459c33713f
  $tc'CharLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'CharLiteral3) -}
3410e4bbc7dff588b06e27a9201281b6
  $tc'CharLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CharLiteral"#) -}
3326ab711fb24c7e2532cfb77b04ac5f
  $tc'NumericLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10434859749943785604##
                   2152709056268594064##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'NumericLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'NumericLiteral1) -}
e31e109b40e2a871159ff6ca9b7dd6f8
  $tc'NumericLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
60d85f3b3355ae21259fcbe9088a7109
  $tc'NumericLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'NumericLiteral3) -}
5d6528d044fcd37f273c3bd58a7aed87
  $tc'NumericLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NumericLiteral"#) -}
8623e14698f21a21ab79152fa553ee39
  $tc'ObjectLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9050049710337981306##
                   3242475390801743553##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral1) -}
07a4584248ded5a0a19afd62835e5360
  $tc'ObjectLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7e70b3d73becaba478b66b3027a3a952
  $tc'ObjectLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'ObjectLiteral3) -}
1874a604d4594d751d34f24bb1b99c22
  $tc'ObjectLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObjectLiteral"#) -}
0e0e45e6d258e99549cef5998f8d36dd
  $tc'StringLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10547078985276304648##
                   17168825983539419542##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tc'StringLiteral2
                   1#
                   Language.PureScript.AST.Literals.$tc'StringLiteral1) -}
3e754530ad6df125d3201771d00922ac
  $tc'StringLiteral1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1159779608f82610fcc7fcf2794ee736
  $tc'StringLiteral2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tc'StringLiteral3) -}
bc898be998222b6c7d18b75df22be992
  $tc'StringLiteral3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLiteral"#) -}
e14eae7c0bb5436a84a68f593f14eabd
  $tcLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18029631774746679237##
                   668101096646537123##
                   Language.PureScript.AST.Literals.$trModule
                   Language.PureScript.AST.Literals.$tcLiteral1
                   0#
                   GHC.Types.krep$*Arr*) -}
e4f381a4466fd37f6d6b04c891715f50
  $tcLiteral1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$tcLiteral2) -}
e0b612a21d3a1c01e667e0d63dc19f69
  $tcLiteral2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Literal"#) -}
7321b2d68321111b57f68f14e16b28c3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.PureScript.AST.Literals.$trModule3
                   Language.PureScript.AST.Literals.$trModule1) -}
9959de299f8504df67b96976f2689ec5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$trModule2) -}
46779567d1fab82f357f39b228a28335
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Language.PureScript.AST.Literals"#) -}
48a14d5bf5eeaa5ae1b23e9aa2aab45d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.PureScript.AST.Literals.$trModule4) -}
ee3354cf141f03e7b099b80e102b199e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("purescript-0.12.2-1jEEKvd7Qrz8R80uEP8O5F"#) -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> Language.PureScript.AST.Literals.Literal a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,1*C1(C(U)))><S,U><S,1*U>,
     Inline: [0] -}
4b6b35be8d89b746a77fcd3d0c0a71d4
  data Literal a
    = NumericLiteral (Data.Either.Either
                        GHC.Integer.Type.Integer GHC.Types.Double)
    | StringLiteral Language.PureScript.PSString.PSString
    | CharLiteral GHC.Types.Char
    | BooleanLiteral GHC.Types.Bool
    | ArrayLiteral [a]
    | ObjectLiteral [(Language.PureScript.PSString.PSString, a)]
instance GHC.Classes.Eq [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fEqLiteral
instance GHC.Base.Functor [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fFunctorLiteral
instance GHC.Classes.Ord [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fOrdLiteral
instance GHC.Show.Show [Language.PureScript.AST.Literals.Literal]
  = Language.PureScript.AST.Literals.$fShowLiteral
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

